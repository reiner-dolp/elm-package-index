[{"name":"Tar","comment":" Use\n\n       encodeFiles : List ( FileRecord, Data ) -> Encode.Encoder\n\nto tar an arbitrary set of files which may contain either text or binary\ndata. To tar a set of text files, you can use\n\n       encodeTextFiles : List (FileRecord, String) -> Encode.Encoder\n\nHere is a complete example:\n\n      testArchive : Bytes\n      testArchive =\n          encodeTextFiles\n              [ ( { defaultFileRecord | filename = \"one.txt\" }, \"One\" )\n              , ( { defaultFileRecord | filename = \"two.txt\" }, \"Two\" )\n              ]\n              |> encode\n\nTo untar an archive, imitate this example:\n\n       extractArchive testArchive\n\nFor more details, see the README. See also the demo app `./examples/Main.elm`\n\n@docs Data, FileRecord, createArchive, extractArchive, testArchive, encodeFiles, encodeTextFile, encodeTextFiles, defaultFileRecord\n\n","unions":[{"name":"Data","comment":" Use `StringData String` for text data,\n`BinaryData Bytes` for binary data, e.g.,\n`StringData \"This is a test\"` or\n`BinaryData someBytes`\n","args":[],"cases":[["StringData",["String.String"]],["BinaryData",["Bytes.Bytes"]]]}],"aliases":[{"name":"FileRecord","comment":" A FileRecord contains the information needed for\ntar to construct the header for the assoicated file\nin the tar archive. You may use `defaultFileRecord` as\na starting point, modifying only what is needed.\n","args":[],"type":"{ filename : String.String, mode : Tar.Mode, ownerID : Basics.Int, groupID : Basics.Int, fileSize : Basics.Int, lastModificationTime : Basics.Int, linkIndicator : Tar.Link, linkedFileName : String.String, userName : String.String, groupName : String.String, fileNamePrefix : String.String }"}],"values":[{"name":"createArchive","comment":" Example:\n\n> data1 = ( { defaultFileRecord | filename = \"one.txt\" }, StringData \"One\" )\n> data2 = ( { defaultFileRecord | filename = \"two.txt\" }, StringData \"Two\" )\n> createArchive [data1, data2]\n\n> createArchive [data1, data2]\n> <3072 bytes> : Bytes.Bytes\n\n","type":"List.List ( Tar.FileRecord, Tar.Data ) -> Bytes.Bytes"},{"name":"defaultFileRecord","comment":" defaultFileRecord is a dummy FileRecord that you modify\nto suit your needs. It contains a lot of boilerplates\n\nExample\n\nfileRecord = { defaultFileRecord | filename = \"Test.txt\" }\n\nSee the definition of FileRecord to see what other fields you\nmay want to modify, or see `/examples/Main.elm`.\n\n","type":"Tar.FileRecord"},{"name":"encodeFiles","comment":"\n\n      Example\n\n      import Tar exposing(defaultFileRecord)\n\n      fileRecord_ =\n          defaultFileRecord\n\n      fileRecord1 =\n          { fileRecord_ | filename = \"a.txt\" }\n\n      content1 =\n          \"One two three\\n\"\n\n      fileRecord2 =\n          { fileRecord_ | filename = \"c.binary\" }\n\n      content2 =\n          Hex.toBytes \"616263646566\" |> Maybe.withDefault (encode (Bytes.Encode.unsignedInt8 0))\n\n      Tar.encodeFiles\n          [ ( fileRecord1, StringData content1 )\n          , ( fileRecord2, BinaryData content2 )\n          ]\n          |> Bytes.Encode.encode\n\n      Note: `Hex` is found in `jxxcarlson/hex`\n","type":"List.List ( Tar.FileRecord, Tar.Data ) -> Bytes.Encode.Encoder"},{"name":"encodeTextFile","comment":" Example:\n\n> encodeTextFile defaultFileRecord \"Test!\" |> encode\n> <1024 bytes> : Bytes.Bytes\n\n","type":"Tar.FileRecord -> String.String -> Bytes.Encode.Encoder"},{"name":"encodeTextFiles","comment":" Example\n\nencodeFiles [(defaultFileRecord, \"This is a test\"), (defaultFileRecord, \"Lah di dah do day!\")] |> Bytes.Encode.encode == <2594 bytes> : Bytes\n\n","type":"List.List ( Tar.FileRecord, String.String ) -> Bytes.Encode.Encoder"},{"name":"extractArchive","comment":" Try\n\n> import Tar exposing(..)\n> extractArchive testArchive\n\nto test this function\n\n","type":"Bytes.Bytes -> List.List ( Tar.FileData, Tar.Data )"},{"name":"testArchive","comment":" A small tar archive for testing purposes\n","type":"Bytes.Bytes"}],"binops":[]}]