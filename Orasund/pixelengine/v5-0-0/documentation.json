[{"name":"Grid","comment":" A `Grid` is a dictionary that has a size constraint.\nHere is an example where such a grid is used:\n[Snake Example](https://orasund.github.io/pixelengine/#Snake).\n\n\n# Grids\n\n@docs Grid\n\n\n# Build\n\n@docs fill, empty, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size, dimensions\n\n\n# List\n\n@docs positions, emptyPositions, values, toList, fromList\n\n\n# Dict\n\n@docs toDict, fromDict\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition, find\n\n\n# Combine\n\n@docs union, intersect, diff\n\n","unions":[{"name":"Grid","comment":" A grid with a fixes amount of columns and rows.\n\nIt will wrap the borders (apply ModBy), making every position valid.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> get ( -1, 0 )\n    --> grid |> get ( (dimensions |> .columns) - 1, 0 )\n\nIf instead you want to have hard border around your grid, use `Grid.Bordered` instead.\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a value when its position does not appear in the second grid.\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"dimensions","comment":" Return the dimensions of the grid.\n\n    dim : { columns:Int , rows:Int }\n    dim =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dim\n\n    grid |> dimensions\n    --> dim\n\n","type":"Grid.Grid a -> { columns : Basics.Int, rows : Basics.Int }"},{"name":"empty","comment":" Create an empty grid\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    empty dimensions\n    --> fill (always Nothing ) dimensions\n\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Grid.Grid a"},{"name":"emptyPositions","comment":" Get all empty positions in a grid, sorted from lowest to highest.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        fill\n            (always <| Just <| 42)\n            dimensions\n\n    grid |> remove (2,2) |> emptyPositions\n    --> [(2,2)]\n\n","type":"Grid.Grid a -> List.List Grid.Position.Position"},{"name":"fill","comment":" Create a grid\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    fill (always <| Just ()) dimensions |> emptyPositions\n    --> []\n\n","type":"(Grid.Position.Position -> Maybe.Maybe a) -> { rows : Basics.Int, columns : Basics.Int } -> Grid.Grid a"},{"name":"filter","comment":" Keep only the values that pass the given test.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        empty dimensions\n            |> insert (2,4) 2\n            |> insert (2,3) 42\n\n    grid |> filter (\\_ -> (==) 42) |> values\n    --> [42]\n\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> Grid.Grid a"},{"name":"find","comment":" Find the first value that passes a given test.\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> Maybe.Maybe ( Grid.Position.Position, a )"},{"name":"foldl","comment":" Fold over **all** positions in a grid, row by row, from top down.\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Grid v -> b"},{"name":"foldr","comment":" Fold over **all** positions in a grid, row by row, from bottum up.\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Grid v -> b"},{"name":"fromDict","comment":" Convert an dictionary to a grid\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        empty dimensions\n\n    grid |> toDict |> fromDict dimensions |> get (2,2)\n    --> Nothing\n\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Dict.Dict Grid.Position.Position a -> Grid.Grid a"},{"name":"fromList","comment":" Convert an association list into a grid.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        empty dimensions\n\n    [((2,2),42),((2,1),20)] |> fromList dimensions\n    --> grid |> insert (2,2) 42 |> insert (2,1) 20\n\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> List.List ( Grid.Position.Position, a ) -> Grid.Grid a"},{"name":"get","comment":" Get the value associated with a position. If the position is empty, return Nothing.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> get (2,2)\n    --> Just 42\n\n","type":"Grid.Position.Position -> Grid.Grid a -> Maybe.Maybe a"},{"name":"insert","comment":" Insert a value at a position in a grid. Replaces value when there is a collision.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> get (2,2)\n    --> Just 42\n\n","type":"Grid.Position.Position -> a -> Grid.Grid a -> Grid.Grid a"},{"name":"intersect","comment":" Keep a value when its position appears in the second grid.\nPreference is given to values in the first grid.\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"isEmpty","comment":" Determine if a grid is empty.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> isEmpty --> True\n    grid |> insert (2,2) 42 |> isEmpty --> False\n\n","type":"Grid.Grid a -> Basics.Bool"},{"name":"map","comment":" Apply a function to **all** positions in a grid.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    empty dimensions |> map (\\_ _ -> Just 42)\n    --> fill (always <| Just 42) dimensions\n\n","type":"(Grid.Position.Position -> Maybe.Maybe a -> Maybe.Maybe b) -> Grid.Grid a -> Grid.Grid b"},{"name":"member","comment":" Determine if a position is empty.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> member (2,2)\n    --> True\n\n","type":"Grid.Position.Position -> Grid.Grid a -> Basics.Bool"},{"name":"partition","comment":" Partition a grid according to some test.\n\nThe first grid contains all values which passed the test,\nand the second contains the values that did not.\n\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> ( Grid.Grid a, Grid.Grid a )"},{"name":"positions","comment":" Get all non empty positions in a grid, sorted from lowest to highest.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> positions\n    --> [(2,2)]\n\n","type":"Grid.Grid a -> List.List Grid.Position.Position"},{"name":"remove","comment":" Remove a vlaue from a grid. If the position is empty, no changes are made.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> get (2,2) --> Just 42\n    grid |> insert (2,2) 42 |> remove (2,2) |> get (2,2)\n    --> Nothing\n\n","type":"Grid.Position.Position -> Grid.Grid a -> Grid.Grid a"},{"name":"size","comment":" Determine the number of values in the grid.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> size\n    --> 1\n\n","type":"Grid.Grid a -> Basics.Int"},{"name":"toDict","comment":" Convert a grid into an associated dictionary\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        empty dimensions\n            |> insert (2,2) 42\n\n    grid |> toDict |> fromDict dimensions |> get (2,2)\n    --> Just 42\n\n","type":"Grid.Grid a -> Dict.Dict Grid.Position.Position a"},{"name":"toList","comment":" Convert a grid into an association list of position-value pairs,\nsorted by the position.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid Int\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> toList\n    --> [( (2,2), 42 )]\n\n","type":"Grid.Grid a -> List.List ( Grid.Position.Position, a )"},{"name":"union","comment":" Combine two grids.\nIf there is a collision, preference is given to the first grid.\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"update","comment":" Update the value of a grid for a specific position with a given function.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> update (2,2) (always <| Just 42)\n    --> grid |> insert (2,2) 42\n\n","type":"Grid.Position.Position -> (Maybe.Maybe a -> Maybe.Maybe a) -> Grid.Grid a -> Grid.Grid a"},{"name":"values","comment":" Get all of the values in a grid, in the order of their positions.\n\n    dimensions : { columns:Int , rows:Int }\n    dimensions =\n        { columns=42\n        , rows=3\n        }\n\n    grid : Grid a\n    grid =\n        empty dimensions\n\n    grid |> insert (2,2) 42 |> values\n    --> [42]\n\n","type":"Grid.Grid a -> List.List a"}],"binops":[]},{"name":"Grid.Bordered","comment":" A grid with a hard border around the edges. you cant read or write from squares\noutside the border.\nHere is an example where such a grid is used:\n[Space Invaders](https://orasund.github.io/pixelengine/#SpaceInvaders).\n\n\n# Error\n\n@docs Error, ignoringErrors\n\n\n# Grids\n\n@docs Grid\n\n\n# Build\n\n@docs fill, empty, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, isValid, size, dimensions\n\n\n# List\n\n@docs positions, emptyPositions, values, toList, fromList\n\n\n# Dict\n\n@docs toDict, fromDict\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition, find\n\n\n# Combine\n\n@docs union, intersect, diff\n\n","unions":[{"name":"Error","comment":" Possible Errors.\n\n  - `OutOfBounds` - the position is not valid\n  - `NotSucessful` - the function as a problem fullfilling the task. (Maybe the position is occupied?)\n\n","args":[],"cases":[]},{"name":"Grid","comment":" A grid of values.\n\nIt has a fixed amount of columns and rows.\n\nIf case of a invalid position, it returns an error.\n\n    grid |> Grid.insert ( -1, 0 ) virus == Err OutOfBounds\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a value when its position does not appear in the second grid.\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"dimensions","comment":" return the dimensions of the grid\n","type":"Grid.Bordered.Grid a -> { columns : Basics.Int, rows : Basics.Int }"},{"name":"empty","comment":" Create an empty grid\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Grid.Bordered.Grid a"},{"name":"emptyPositions","comment":" Get all empty positions in a grid, sorted from lowest to highest.\n","type":"Grid.Bordered.Grid a -> List.List Grid.Position.Position"},{"name":"fill","comment":" Create a grid\n","type":"(Grid.Position.Position -> Maybe.Maybe a) -> { rows : Basics.Int, columns : Basics.Int } -> Grid.Bordered.Grid a"},{"name":"filter","comment":" Keep only the values that pass the given test.\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"find","comment":" Find the first value that passes a given test.\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> Maybe.Maybe ( Grid.Position.Position, a )"},{"name":"foldl","comment":" Fold over **all** positions in a grid, row by row, from top down.\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Bordered.Grid v -> b"},{"name":"foldr","comment":" Fold over **all** positions in a grid, row by row, from bottum up.\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Bordered.Grid v -> b"},{"name":"fromDict","comment":" Convert an dictionary to a grid\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Dict.Dict Grid.Position.Position a -> Grid.Bordered.Grid a"},{"name":"fromList","comment":" Convert an association list into a grid.\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> List.List ( Grid.Position.Position, a ) -> Grid.Bordered.Grid a"},{"name":"get","comment":" Get the value associated with a position. If the position is empty, return Nothing.\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result () (Maybe.Maybe a)"},{"name":"ignoringErrors","comment":" Trys modifying a grid and if its fails it returns the original grid.\n\nPlease be aware, that by using this function you might introduce errors.\n\n","type":"(Grid.Bordered.Grid a -> Result.Result result (Grid.Bordered.Grid a)) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"insert","comment":" Insert a value at a position in a grid. Returns a `NotSuccessful` error if\nthe position is occupied.\n","type":"Grid.Position.Position -> a -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"intersect","comment":" Keep a value when its position appears in the second grid.\nPreference is given to values in the first grid.\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"isEmpty","comment":" Determine if a grid is empty.\n","type":"Grid.Bordered.Grid a -> Basics.Bool"},{"name":"isValid","comment":" checks if a position is valid.\n\n    grid : Grid a\n    grid =\n        empty\n            { columns=42\n            , rows=3\n            }\n\n\n    grid |> isValid (-1,0) --> False\n    grid |> isValid (41,0) --> True\n    grid |> isValid (42,0) --> False\n\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Basics.Bool"},{"name":"map","comment":" Apply a function to **all** positions in a grid.\n","type":"(Grid.Position.Position -> Maybe.Maybe a -> Maybe.Maybe b) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid b"},{"name":"member","comment":" Determine if a position is empty.\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result () Basics.Bool"},{"name":"partition","comment":" Partition a grid according to some test.\n\nThe first grid contains all values which passed the test,\nand the second contains the values that did not.\n\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> ( Grid.Bordered.Grid a, Grid.Bordered.Grid a )"},{"name":"positions","comment":" Get all non empty positions in a grid, sorted from lowest to highest.\n","type":"Grid.Bordered.Grid a -> List.List Grid.Position.Position"},{"name":"remove","comment":" Remove a vlaue from a grid. If the position is empty, it returs a\n`NotSuccessful` error.\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"size","comment":" Determine the number of values in the grid.\n","type":"Grid.Bordered.Grid a -> Basics.Int"},{"name":"toDict","comment":" Convert a grid into an associated dictionary\n","type":"Grid.Bordered.Grid a -> Dict.Dict Grid.Position.Position a"},{"name":"toList","comment":" Convert a grid into an association list of position-value pairs, sorted by the position.\n","type":"Grid.Bordered.Grid a -> List.List ( Grid.Position.Position, a )"},{"name":"union","comment":" Combine two grids.\nIf there is a collision, preference is given to the first grid.\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"update","comment":" Update the value of a grid for a specific position with a given function.\n","type":"Grid.Position.Position -> (Maybe.Maybe a -> Result.Result () (Maybe.Maybe a)) -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"values","comment":" Get all of the values in a grid, in the order of their keys.\n","type":"Grid.Bordered.Grid a -> List.List a"}],"binops":[]},{"name":"Grid.Direction","comment":"\n\n@docs Direction, flip, rotLeft, rotRight\n\n","unions":[{"name":"Direction","comment":" A abstract concept of a direction on a grid.\n","args":[],"cases":[["Up",[]],["Down",[]],["Left",[]],["Right",[]]]}],"aliases":[],"values":[{"name":"flip","comment":" Rotates a `Direction` for 180 Degrees.\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"},{"name":"rotLeft","comment":" Rotates a `Direction` clockwise\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"},{"name":"rotRight","comment":" Rotates a `Direction` counter-clockwise\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"}],"binops":[]},{"name":"Grid.Position","comment":" This module contains two ways of representing a point on a grid:\n`Position` and `Coord`. Positions are meant to be stored, and coordinates are\nmeant to to calculations with.\n\n\n# Position\n\n@docs Position, move, add, coordsTo\n\n\n# Vector\n\n@docs Coord, fromDirection, toDirection, distance, scaleBy, length\n\n","unions":[],"aliases":[{"name":"Coord","comment":" `Coord` is a non-comparable representation for 2D Coordinates.\n\nUse this type for your calculations.\n\n","args":[],"type":"{ x : Basics.Int, y : Basics.Int }"},{"name":"Position","comment":" A `Position` is a comparable representation for 2D Coordinates.\n\nYou should store your coordinates in this type.\n\n","args":[],"type":"( Basics.Int, Basics.Int )"}],"values":[{"name":"add","comment":" Apply Coordinates to a position to get the relative position.\n\n```\nmove amount direction == add ( fromDirection direction |> scaleby amount)\n```\n\n","type":"Grid.Position.Coord -> Grid.Position.Position -> Grid.Position.Position"},{"name":"coordsTo","comment":" Returns the difference between two positions.\n\n```\ndifference p1 p2 == p1 <------- p2\n```\n\n","type":"Grid.Position.Position -> Grid.Position.Position -> Grid.Position.Coord"},{"name":"distance","comment":" Gets the distance between to points.\n(The length of the difference)\n\n```\ndistance == vectorTo >> length\n```\n\n","type":"Grid.Position.Position -> Grid.Position.Position -> Basics.Float"},{"name":"fromDirection","comment":" converts a `Direction` into a `Vector` with length `1`.\n","type":"Grid.Direction.Direction -> Grid.Position.Coord"},{"name":"length","comment":" Returns the length of the coordinate (distance to (0,0)\n","type":"Grid.Position.Coord -> Basics.Float"},{"name":"move","comment":" moves a Point some amount of steps in a direction. This is the most used\nway how to change a position.\n","type":"Basics.Int -> Grid.Direction.Direction -> Grid.Position.Position -> Grid.Position.Position"},{"name":"scaleBy","comment":" Scales Coordnates. Coordnates obtained by `fromDirection` have size 1.\n\n```\nfromDirection angle |> scaleBy l |> length == l\n```\n\n","type":"Basics.Int -> Grid.Position.Coord -> Grid.Position.Coord"},{"name":"toDirection","comment":" converts **any** `Vector` into its nearest `Direction` value.\n\nfromValue (0,0) == Right\nfromValue (1,1) == Down\nfromValue (-1,1) == Down\nfromValue (1,-1) == Up\nfromValue (-1,-1) == Up\n\n","type":"Grid.Position.Coord -> Grid.Direction.Direction"}],"binops":[]},{"name":"Location","comment":" This module contains two different type for repesenting a 2D Point:\n`Location` and `Vector`. The idea is to use `Locations` to store a Point and `Vector`\nto do caluclations. This way the compiler knows exactly what you are doing and can\ngive you appropriate error messages.\n\n\n# Angle\n\n@docs Angle, toAngle\n\n\n# Location\n\n@docs Location, move, add, vectorTo\n\n\n# Vector\n\n@docs Vector, fromAngle, distance, rotate, scaleBy, length\n\n","unions":[{"name":"Angle","comment":" A Angle should store Elm angles (radians).\n\nUse the functions `degrees`,`radias`,`turns` or `pi` to obtain a Angle.\n\n```\nAngle <| degree 90\n```\n\n","args":[],"cases":[["Angle",["Basics.Float"]]]}],"aliases":[{"name":"Location","comment":" A `Location` a point, possibly stored in a dictionary. Thats why its a tuple.\nBut doing calulations with tuples can get very chaotic, thats why the module provides\n`Vectors`.\n","args":[],"type":"( Basics.Float, Basics.Float )"},{"name":"Vector","comment":" A Vector is used for calculations.\n","args":[],"type":"{ x : Basics.Float, y : Basics.Float }"}],"values":[{"name":"add","comment":" simple adds a vector to a location, from geometry we know that a vector is\nactually just an angle and a length.\n\n```\nmove length angle == add ( fromAngle angle |> scaleby length)\n```\n\n","type":"Location.Vector -> Location.Location -> Location.Location"},{"name":"distance","comment":" The `Distance` between two locations is the length of the resulting vector\n\n```\ndistance == vectorTo >> length\n```\n\n","type":"Location.Location -> Location.Location -> Basics.Float"},{"name":"fromAngle","comment":" construct a unit vector from an angle\n\n```\nfromAngle >> length == 1\n```\n\n","type":"Location.Angle -> Location.Vector"},{"name":"length","comment":" Returns the length of the coordinate (distance to (0,0)\n","type":"Location.Vector -> Basics.Float"},{"name":"move","comment":" given a `Location`, a distance in some direction. This is the most used\nway how to change a location.\n","type":"Basics.Float -> Location.Angle -> Location.Location -> Location.Location"},{"name":"rotate","comment":" rotate a Vector\n","type":"Location.Angle -> Location.Vector -> Location.Vector"},{"name":"scaleBy","comment":" Scales a Vector. Vectors obtained by `fromAngle` have size 1.\n\n```\nfromAngle angle |> scaleBy l |> length == l\n```\n\n","type":"Basics.Float -> Location.Vector -> Location.Vector"},{"name":"toAngle","comment":" An Angle can be constructed from a Vector.\n\n```\n{x=0,y=0} |> Location.toAngle == 0\n```\n\n","type":"Location.Vector -> Location.Angle"},{"name":"vectorTo","comment":" The difference between to locations is a vector.\n\n```\nloc1 <----- loc2\n```\n\nthe resulting vector points from the second value to the first.\n\n","type":"Location.Location -> Location.Location -> Location.Vector"}],"binops":[]},{"name":"PixelEngine","comment":" This module takes care of the Graphics.\n\nYou will want to add [PixelEngine.Graphics.Image](PixelEngine-Graphics-Image)\nor [PixelEngine.Graphics.Tile](PixelEngine-Graphics-Tile) to\nactually draw something.\n\n\n# Area\n\nThe main idea of this graphic engine is to arrage the content into horizontal stripes,\nso called areas.\n\n@docs Area, tiledArea, imageArea, heightOf\n\n\n# PixelEngine\n\n@docs PixelEngine\n\nIf one wants to use just use this module on its own, you can use `toHtml` instead\nof the `game` function from the main module.\n\n@docs toHtml, game, gameWithNoControls, gameWithCustomControls\n\n\n# Controls\n\nThe graphic engine provides a touch-controller for mobile devices.\n\n@docs Input, defaultInputs\n\n\n# Background\n\n@docs Background, imageBackground, colorBackground\n\n\n# Advanced\n\n@docs basicControls, customControls, withMobileSupport\n\n","unions":[{"name":"Input","comment":" all possible Inputs.\n","args":[],"cases":[["InputLeft",[]],["InputRight",[]],["InputUp",[]],["InputDown",[]],["InputA",[]],["InputB",[]],["InputX",[]],["InputY",[]]]}],"aliases":[{"name":"Area","comment":" A horizontal area of the content.\nA `Area` defines how the content should be displayed.\n\n**Note:**\nAn area can only contain elements of the same type.\nSo either you have tiles or images.\n\n![A typical game](https://orasund.github.io/pixelengine/docs/img4.png \"A typical game\")\n\n","args":["msg"],"type":"PixelEngine.Graphics.Data.Area.Area msg"},{"name":"Background","comment":" Every area has a background.\n","args":[],"type":"PixelEngine.Graphics.Data.Background"},{"name":"PixelEngine","comment":" An alias for a PixelEngine program.\n\nYour `main` function will have this type.\n\n","args":["flag","model","msg"],"type":"Platform.Program flag (PixelEngine.Model model msg) (PixelEngine.Msg msg)"}],"values":[{"name":"basicControls","comment":" Subscribes to a keypress and sends the corresponding msg. This Function uses the default key layout.\n","type":"(PixelEngine.Input -> Maybe.Maybe msg) -> Platform.Sub.Sub (Maybe.Maybe msg)"},{"name":"colorBackground","comment":" A single color background.\nIt uses [avh4/elm-color](https://package.elm-lang.org/packages/avh4/elm-color/latest).\n\n```\ncolorBackground (Color.rgb255 20 12 28)\n```\n\n","type":"Color.Color -> PixelEngine.Background"},{"name":"customControls","comment":" Subscribes to a keypress using custom key layouts.\n\nIt uses [key values](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) for the String.\nYou can use this [website](http://keycode.info) to find out the key value.\n\n","type":"(String.String -> Maybe.Maybe PixelEngine.Input) -> (PixelEngine.Input -> Maybe.Maybe msg) -> Platform.Sub.Sub (Maybe.Maybe msg)"},{"name":"defaultInputs","comment":" The default layout:\n\n  - A/ArrowLeft - `InputLeft`\n  - W/ArrowUp - `InputUp`\n  - D/ArrowRight - `InputRight`\n  - S/ArrowDown - `InputDown`\n  - Space/Enter - `InputA`\n  - X/Backspace/Esc - `InputB`\n  - Q - `InputX`\n  - E - `InputY`\n\n","type":"String.String -> Maybe.Maybe PixelEngine.Input"},{"name":"game","comment":" A prewired PixelEngine frame.\n\nUse it just like `document` from [elm/browser](https://package.elm-lang.org/packages/elm/browser/latest/Browser).\n\n","type":"{ init : flags -> ( model, Platform.Cmd.Cmd msg ), update : msg -> model -> ( model, Platform.Cmd.Cmd msg ), subscriptions : model -> Platform.Sub.Sub msg, view : model -> { title : String.String, options : Maybe.Maybe (PixelEngine.Options.Options msg), body : List.List (PixelEngine.Area msg) }, controls : PixelEngine.Input -> Maybe.Maybe msg, width : Basics.Float } -> Platform.Program flags (PixelEngine.Model model msg) (PixelEngine.Msg msg)"},{"name":"gameWithCustomControls","comment":" A game using custom controls.\n\nThe default controls should be enough to start,\nbut maybe you want to write a spelling game,\nor its nessesary that very specifc keys are used?\n\n","type":"{ init : flags -> ( model, Platform.Cmd.Cmd msg ), update : msg -> model -> ( model, Platform.Cmd.Cmd msg ), subscriptions : model -> Platform.Sub.Sub msg, width : Basics.Float, view : model -> { title : String.String, options : Maybe.Maybe (PixelEngine.Options.Options msg), body : List.List (PixelEngine.Area msg) }, controls : ( String.String -> Maybe.Maybe PixelEngine.Input, PixelEngine.Input -> Maybe.Maybe msg ) } -> Platform.Program flags (PixelEngine.Model model msg) (PixelEngine.Msg msg)"},{"name":"gameWithNoControls","comment":" A game with no controls.\n\nUse it just like `document` from [elm/browser](https://package.elm-lang.org/packages/elm/browser/latest/Browser).\n\n","type":"{ init : flags -> ( model, Platform.Cmd.Cmd msg ), update : msg -> model -> ( model, Platform.Cmd.Cmd msg ), subscriptions : model -> Platform.Sub.Sub msg, width : Basics.Float, view : model -> { title : String.String, options : Maybe.Maybe (PixelEngine.Options.Options msg), body : List.List (PixelEngine.Area msg) } } -> Platform.Program flags (PixelEngine.Model model msg) (PixelEngine.Msg msg)"},{"name":"heightOf","comment":" Returns the height of a list of Areas\n\nThis can be used to return the height of a `tiledArea`.\nFor a `imageArea` this function is trivial.\n\n","type":"List.List (PixelEngine.Area msg) -> Basics.Float"},{"name":"imageArea","comment":" An area containing images that can be arranged freely.\n\nThis is a complete contrast to the way how `tiledArea` is working.\nUsefull applications are GUIs, menus or loading screens.\n\nCheckout [PixelEngine.Graphics.Image](PixelEngine-Graphics-Image) for more information.\n\nThis area has the following options:\n\n  - `height` - The height or the `Area` in pixels.\n  - `background` - The background of the `Area`.\n\n","type":"{ height : Basics.Float, background : PixelEngine.Background } -> List.List ( ( Basics.Float, Basics.Float ), PixelEngine.Image.Image msg ) -> PixelEngine.Area msg"},{"name":"imageBackground","comment":" An image that gets repeated.\n\n```\nImage \"groundTile.png\"\n```\n\n","type":"{ source : String.String, width : Basics.Float, height : Basics.Float } -> PixelEngine.Background"},{"name":"tiledArea","comment":" An area for using tilesets.\n\nIt supports one tileset at a time,\nthat means all sprites must be of the same size and stored as a grid in one single file.\nThis area is useful for displaying the playing field of a game.\n\nCheckout [PixelEngine.Graphics.Tile](PixelEngine-Graphics-Image) for more information.\n\nThis area has the following options:\n\n  - `rows` - The amount of rows of the grid. This value defines the height of the `Area`.\n  - `tileset` - The tileset that will be used for all elements in the `Area`.\n  - `background` - The background of the `Area`.\n\n","type":"{ rows : Basics.Int, tileset : PixelEngine.Tile.Tileset, background : PixelEngine.Background } -> List.List ( ( Basics.Int, Basics.Int ), PixelEngine.Tile.Tile msg ) -> PixelEngine.Area msg"},{"name":"toHtml","comment":" Displays content of the game.\n","type":"{ width : Basics.Float, options : Maybe.Maybe (PixelEngine.Options.Options msg) } -> List.List (PixelEngine.Area msg) -> Html.Html msg"},{"name":"withMobileSupport","comment":" Adds mobile support to the options.\nIt needs the window size.\n\n<PixelEngine> provides a fully wired program that takes care of everything.\n\n","type":"{ windowSize : { width : Basics.Float, height : Basics.Float }, controls : PixelEngine.Input -> Maybe.Maybe msg } -> PixelEngine.Options.Options msg -> PixelEngine.Options.Options msg"}],"binops":[]},{"name":"PixelEngine.Image","comment":" This module contains functions for creating images.\nThese Images can then be used for the `imageArea` function from the <PixelEngine>\n\n\n## Image\n\n@docs Image, fromSrc, movable, jumping, fromTile, fromText, fromTextWithSpacing, multipleImages, clickable, monochrome, withAttributes\n\n","unions":[],"aliases":[{"name":"Image","comment":" A `Image` is actually a very general type: As we will see later,\neven tiles are essentially images.\nThe following functions are intended to be modular.\n","args":["msg"],"type":"PixelEngine.Graphics.Data.Area.ContentElement msg"}],"values":[{"name":"clickable","comment":" Makes an `Image` clickable\n\nUse this to create the `onClick` event from [Html.Events](https://package.elm-lang.org/packages/elm/html/latest/Html-Events#onClick).\n\n","type":"msg -> PixelEngine.Image.Image msg -> PixelEngine.Image.Image msg"},{"name":"fromSrc","comment":" The basic image constructor.\nThe string contains the url to the image\n\n    fromSrc \"aStone.png\"\n\n","type":"String.String -> PixelEngine.Image.Image msg"},{"name":"fromText","comment":" Created an Image from a text-string and the Tileset of the font.\n\nIt only supports Ascii characters.\n\nThis package comes with a [collection of Fonts](https://github.com/Orasund/pixelengine/wiki/Collection-of-Fonts)\nthat are free to use.\n\n","type":"String.String -> PixelEngine.Tile.Tileset -> PixelEngine.Image.Image msg"},{"name":"fromTextWithSpacing","comment":" Created an Image from a text-string and the Tileset of the font.\n\nIt only supports Ascii characters.\n\nThe first argument is the spaceing between letters. Use negative values to place\nthe letters nearer to echother.\n\nThis package comes with a [collection of Fonts](https://github.com/Orasund/pixelengine/wiki/Collection-of-Fonts)\nthat are free to use.\n\n","type":"Basics.Float -> String.String -> PixelEngine.Tile.Tileset -> PixelEngine.Image.Image msg"},{"name":"fromTile","comment":" `Tiles` are essentially also images,\ntherefore this constructor transforms a `Tile` and a `Tileset` into an `Image`.\n\n    fromTile (tile ( 0, 0 ))\n        (tileset\n            { source = \"tiles.png\"\n            , width = 80\n            , height = 80\n            }\n        )\n        == image \"tiles.png\"\n\n**Note:**\n`fromTile` displays only the `width` and `height` of the image, that where given.\nThis means setting `width` and `height` to `0` would not display the image at all.\n\n    fromTile (tile ( 0, 0 ) |> movable \"uniqueId\")\n        == fromTile (tile ( 0, 0 ))\n        |> movable \"uniqueId\"\n\n**Note:**\nIf you want to animate an `Image` use this function instead.\n\n","type":"PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tileset -> PixelEngine.Image.Image msg"},{"name":"jumping","comment":" Pauses a the transition of a `movable` image.\n\n**Only use in combination with `movable`:**\n\n    image \"teleportingEnemy.png\" |> movable \"name\" |> jumping\n\nUse this function if a tile has the `movable`-property, but you would like to\nremove it without causing any unwanted side effects.\n\n","type":"PixelEngine.Image.Image msg -> PixelEngine.Image.Image msg"},{"name":"monochrome","comment":" Adds a background color.\n\n\\*\\* This makes the the Image non-transparent \\*\\*\n\nThis can be used to simulate monochrome sprites or to implement team colors.\n\n","type":"Color.Color -> PixelEngine.Image.Image msg -> PixelEngine.Image.Image msg"},{"name":"movable","comment":" Creates a image transition between positions.\nThis is useful for images that will change their position during the game.\n\n    image \"enemy.png\" |> movable \"name\"\n\n**Note:**\nThe string should be unique, if not the transition might fail every now and then.\n\n**Note:**\nThe string will be a id Attribute in a html node, so be careful not to use names that might be already taken.\n\n","type":"String.String -> PixelEngine.Image.Image msg -> PixelEngine.Image.Image msg"},{"name":"multipleImages","comment":" It is possible to compose an `Image` from a set of other images.\nThe two `Floats` are realtive coordinates.\n\n    ((100,100),image \"img.png\")\n    =\n    ((20,50), multipleimages [((80,50),image \"img.png\")])\n\nSub-images loose the ability to be movable:\n\n    multipleimages [((x,y),image \"img.png\" |> movable \"id\")]\n    =\n    multipleimages [((x,y),image \"img.png\")]\n\nInstead use the following:\n\n    image \"img.png\" |> movable \"id\"\n    =\n    multipleimages [((0,0),image \"img.png\")] |> movable \"id\"\n\n","type":"List.List ( ( Basics.Float, Basics.Float ), PixelEngine.Image.Image msg ) -> PixelEngine.Image.Image msg"},{"name":"withAttributes","comment":" Adds custom attributes.\n\nUse the [Html.Attributes](https://package.elm-lang.org/packages/elm/html/latest/Html-Attributes).\n\n","type":"List.List (Html.Attribute msg) -> PixelEngine.Image.Image msg -> PixelEngine.Image.Image msg"}],"binops":[]},{"name":"PixelEngine.Options","comment":" Options tweak different aspects of your program.\n\n#Transitions\nAdding a transitions between screens.\n\nThe information for the transition will be written in the `Option` class from\n[PixelEngine.Graphics](PixelEngine-Graphics).\n\nTo get started, copy the following example:\n\n    options\n        |> Transition.withTransitionFrom\n            ListOfArea\n            (Transition.customTransition\n                \"death_transition\"\n                [ ( 0, \"opacity:1;filter:grayscale(0%) blur(0px);\" )\n                , ( 1, \"opacity:1;filter:grayscale(70%) blur(0px);\" )\n                , ( 3, \"opacity:0;filter:grayscale(70%) blur(5px);\" )\n            ])\n\n\n## Main Function\n\n@docs withTransitionFrom\n\n\n## Area\n\n@docs Transition, transition\n\n\n## Options\n\n@docs Options, default, withAnimationFPS, withMovementSpeed, withScale\n\n","unions":[],"aliases":[{"name":"Options","comment":" Options for the render function\n","args":["msg"],"type":"PixelEngine.Graphics.Data.Options.Options msg"},{"name":"Transition","comment":" A transition between screens\n","args":[],"type":"PixelEngine.Graphics.Data.Transition.Transition"}],"values":[{"name":"default","comment":" Defines the width of the game.\n","type":"PixelEngine.Options.Options msg"},{"name":"transition","comment":" The default constructor for a `Transition`.\n\nFor the future I have planed to make transitions modular, similar to a `Msg` or a `Sub`.\n\n    Transition.transition\n        \"death_transition\"\n        [ ( 0, \"opacity:1;filter:grayscale(0%) blur(0px);\" )\n        , ( 1, \"opacity:1;filter:grayscale(70%) blur(0px);\" )\n        , ( 3, \"opacity:0;filter:grayscale(70%) blur(5px);\" )\n        ]\n\nThe first value is the duration of the effect, the second is the CSS-command at that point in time.\nSo the example will compile to something like this:\n\n    dealth_transition:\n    0% {opacity:1;filter:grayscale(0%) blur(0px);}\n    25% {opacity:1;filter:grayscale(70%) blur(0px);}\n    100% {opacity:0;filter:grayscale(70%) blur(5px);}\n\n**Note:**\nA screen will be automatically hidden after a transition,\nso the example would also work without the opacity-parameter.\n\n","type":"String.String -> { start : String.String, keyFrames : List.List (Maybe.Maybe String.String), end : String.String } -> PixelEngine.Options.Transition"},{"name":"withAnimationFPS","comment":" Sets the Frames per Seconds for Animations.\n\nValue must be positv or else the function will be ignored.\n\n**Default value:** `1`\n\n","type":"Basics.Float -> PixelEngine.Options.Options msg -> PixelEngine.Options.Options msg"},{"name":"withMovementSpeed","comment":" The speed of movement in seconds.\n\n**Default value:** `0.2`\n\n","type":"Basics.Float -> PixelEngine.Options.Options msg -> PixelEngine.Options.Options msg"},{"name":"withScale","comment":" Scales up everything.\n\nUse only power of `2` as scale to ensure crisp pixels.\n\n**Default value:** `1`\n\n","type":"Basics.Int -> PixelEngine.Options.Options msg -> PixelEngine.Options.Options msg"},{"name":"withTransitionFrom","comment":" adds the `Transition` to the `Options`.\n\nThe first argument is the List or Areas taken **before** the transition is applied.\n(e.g. the last state)\n\n","type":"List.List (PixelEngine.Graphics.Data.Area.Area msg) -> PixelEngine.Options.Transition -> PixelEngine.Options.Options msg -> PixelEngine.Options.Options msg"}],"binops":[]},{"name":"PixelEngine.Tile","comment":" This module contains functions for creating tiles.\nTiles are used for the `tiledArea` function from the main module.\n\n\n## Tile\n\n@docs Tile, fromPosition, fromText, movable, jumping, animated, clickable, monochrome, withAttributes\n\n\n## Tileset\n\n@docs Tileset, tileset\n\n","unions":[],"aliases":[{"name":"Tile","comment":" A `Tile` defines a sprite in a `Tileset`.\nThe following functions are intended to be modular.\n\nA example for a `tile` could be:\n\n    tile ( 1, 2 ) |> animated 1 |> movable \"uniqueName\"\n\n","args":["msg"],"type":"PixelEngine.Graphics.Data.Tile.Tile msg"},{"name":"Tileset","comment":" A Tileset contains the actuall image that a `Tile` can reference.\n","args":[],"type":"PixelEngine.Graphics.Data.Tile.Tileset"}],"values":[{"name":"animated","comment":" Adds animations to a `Tile`.\nThe sprites of the animation must be arranged horizontally in the `Tileset`.\n\nThe first argument give the amount of steps of the animation (one less then the number of sprites.)\n\nThe following code specifies a `Tile` with 3+1 frames\n\n    tile ( 0, 0 ) |> animated 3\n\n**Note:**\nSetting the steps to `0` describes a tile with no animation.\n\n    tile ( 0, 0 ) |> animated 0 == tile ( 0, 0 )\n\n![animation](https://orasund.github.io/pixelengine/docs/img2.png \"animation\")\n\n**Note:**\nNegaive steps are not supported, in this case no animation will be played.\n\n","type":"Basics.Int -> PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"},{"name":"clickable","comment":" Makes an `Tile` clickable\n\nUse this to create the `onClick` event from [Html.Events](https://package.elm-lang.org/packages/elm/html/latest/Html-Events#onClick).\n\n","type":"msg -> PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"},{"name":"fromPosition","comment":" The basic `Tile` constructor.\n\nThe first argument is the position of the sprite in the `tileset`.\n\nAs an example\n\n    tile ( 3, 2 )\n\nis the 3 row in the second column of the `Tileset`.\n\n![a tileset](https://orasund.github.io/pixelengine/docs/img3.png \"a tileset\")\n\n","type":"( Basics.Int, Basics.Int ) -> PixelEngine.Tile.Tile msg"},{"name":"fromText","comment":" Created a List of Tiles from a String and a Offset.\n\nIt only supports ASCII characters.\n\nThe Offset `(Int,Int` should point to the sprite repesenting the space-character.\n\nThis package comes with a [collection of Fonts](https://github.com/Orasund/pixelengine/wiki/Collection-of-Fonts)\nthat are free to use.\n\n","type":"( Basics.Int, Basics.Int ) -> String.String -> List.List (PixelEngine.Tile.Tile msg)"},{"name":"jumping","comment":" Pauses the transition of a `movable` tile.\n\n**Only use in combination with `movable`:**\n\n    tile ( 0, 0 ) |> movable \"name\" |> jumping\n\nUse this function if a `Tile` has the `movable`-property and you would like to\nremove it temporarily without causing any unwanted side effects.\n\n","type":"PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"},{"name":"monochrome","comment":" Adds a background color.\n\n\\*\\* This makes the the Tile non-transparent \\*\\*\n\nThis can be used to simulate monochrome sprites or to implement team colors.\n\n","type":"Color.Color -> PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"},{"name":"movable","comment":" Makes a `Tile` transition between positions.\nThis is useful for sprites that will change their position during the game.\n\n    tile ( 0, 0 ) |> movable \"name\"\n\n**Note:**\nOnce a `Tile` has this property, it can **NOT** be removed during the game.\n\n**Note:**\nThe string should be unique,. If not then the transition might fail every now and then.\n\n**Note:**\nThe string will be a id Attribute in a html node, so be careful not to use names that might be already taken.\n\n","type":"String.String -> PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"},{"name":"tileset","comment":" The `Tileset` constructor has the following parameters:\n\n  - `source` - The adress to the file\n  - `spriteWidth` - The size of a single sprite in the `Tileset` (in pixels)\n  - `spriteHeight` - The height of a single sprite (also in pixels)\n\nFor the following defines the `Tileset` used in the examples of this module.\n\n    { width: 16\n    , height 16\n    , source: \"https://orasund.github.io/pixelengine/tileset.png\"\n    }\n\n","type":"{ source : String.String, spriteWidth : Basics.Int, spriteHeight : Basics.Int } -> PixelEngine.Tile.Tileset"},{"name":"withAttributes","comment":" Adds custom attributes.\n\nuse the [Html.Attributes](https://package.elm-lang.org/packages/elm/html/latest/Html-Attributes).\n\n","type":"List.List (Html.Attribute msg) -> PixelEngine.Tile.Tile msg -> PixelEngine.Tile.Tile msg"}],"binops":[]}]