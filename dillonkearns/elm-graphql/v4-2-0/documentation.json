[{"name":"Graphql.Codec","comment":" This module is used when you define custom scalars codecs for your schema.\nSee an example and steps for how to set this up in your codebase here:\n<https://github.com/dillonkearns/elm-graphql/blob/master/examples/src/Example07CustomCodecs.elm>\n\n@docs Codec\n\n","unions":[],"aliases":[{"name":"Codec","comment":" A simple definition of a decoder/encoder pair.\n","args":["elmValue"],"type":"{ encoder : elmValue -> Json.Encode.Value, decoder : Json.Decode.Decoder elmValue }"}],"values":[],"binops":[]},{"name":"Graphql.Document","comment":" You'll usually want to use `Graphql.Http` to perform your queries directly.\nThis package provides low-level functions for generating GraphQL documents that\nare helpful for debugging and demo purposes.\n\n@docs serializeQuery, serializeMutation, serializeSubscription, serializeQueryForUrl, decoder\n\n","unions":[],"aliases":[],"values":[{"name":"decoder","comment":" Decoder a response from the server. This low-level function shouldn't be needed\nin the majority of cases. Instead, the high-level functions in `Graphql.Http`\nshould be used.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo typeLock -> Json.Decode.Decoder decodesTo"},{"name":"serializeMutation","comment":" Serialize a mutation selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootMutation -> String.String"},{"name":"serializeQuery","comment":" Serialize a query selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> String.String"},{"name":"serializeQueryForUrl","comment":" Serialize a query selection set into a string with minimal whitespace. For\nuse with a GET request as a query param.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> String.String"},{"name":"serializeSubscription","comment":" Serialize a subscription selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootSubscription -> String.String"}],"binops":[]},{"name":"Graphql.Http","comment":" Send requests to your GraphQL endpoint. See [this live code demo](https://rebrand.ly/graphqelm)\nor the [`examples/`](https://github.com/dillonkearns/elm-graphql/tree/master/examples)\nfolder for some end-to-end examples.\nThe builder syntax is inspired by Luke Westby's\n[elm-http-builder package](http://package.elm-lang.org/packages/lukewestby/elm-http-builder/latest).\n\n\n## Data Types\n\n@docs Request, HttpError, Error, RawError\n\n\n## Begin `Request` Pipeline\n\n@docs queryRequest, mutationRequest, queryRequestWithHttpGet\n@docs QueryRequestMethod\n\n\n## Configure `Request` Options\n\n@docs withHeader, withTimeout, withCredentials, withQueryParams\n\n\n## Perform `Request`\n\n@docs send, sendWithTracker, toTask\n\n\n## Map `Error`s\n\n@docs mapError, discardParsedErrorData, withSimpleHttpError\n\n\n## Error Handling Strategies\n\nThere are 3 possible strategies to handle GraphQL errors.\n\n1.  **`parseableErrorAsSuccess`** If there is a GraphQL error (and the data was\n    complete enough for the decoder to run successfully), pretend that there was\n    no error at all.\n2.  **Not Implemented** If there is a GraphQL error pretend it was a network error.\n    There is currently no implementation for this strategy, if you think this\n    would come in handy, please open a Github issue to describe your use case!\n3.  **Default** This gives you full control. You get an accurate and exact\n    picture of what happened (got a GraphQL error & could parse the body, got a\n    GraphQL error and couldn't parse the body, got an http error, or got\n    everything was successful). And you can handle each case explicitly.\n\n@docs parseableErrorAsSuccess\n\n","unions":[{"name":"HttpError","comment":" An Http Error. A Request can fail in a few ways:\n\n  - `BadUrl` means you did not provide a valid URL.\n  - `Timeout` means it took too long to get a response.\n  - `NetworkError` means the user turned off their wifi, went in a cave, etc.\n  - `BadStatus` means you got a response back, but the status code indicates failure. The second argument in the payload is the response body.\n  - `BadPayload` means you got a response back with a nice status code, but the body of the response was something unexpected. The String in this case is a debugging message that explains what went wrong with your JSON decoder or whatever.\n\n","args":[],"cases":[["BadUrl",["String.String"]],["Timeout",[]],["NetworkError",[]],["BadStatus",["Http.Metadata","String.String"]],["BadPayload",["Json.Decode.Error"]]]},{"name":"QueryRequestMethod","comment":" Union type to pass in to `queryRequestWithHttpGet`. Only applies to queries.\nMutations don't accept this configuration option and will always use POST.\n","args":[],"cases":[["AlwaysGet",[]],["GetIfShortEnough",[]]]},{"name":"RawError","comment":" Represents the two types of errors you can get, an Http error or a GraphQL error.\nSee the `Graphql.Http.GraphqlError` module docs for more details.\n","args":["parsedData","httpError"],"cases":[["GraphqlError",["Graphql.Http.GraphqlError.PossiblyParsedData parsedData","List.List Graphql.Http.GraphqlError.GraphqlError"]],["HttpError",["httpError"]]]},{"name":"Request","comment":" An internal request as it's built up. Once it's built up, send the\nrequest with `Graphql.Http.send`.\n","args":["decodesTo"],"cases":[]}],"aliases":[{"name":"Error","comment":" An alias for the default kind of Error. See the `RawError` for the full\ntype.\n","args":["parsedData"],"type":"Graphql.Http.RawError parsedData Graphql.Http.HttpError"}],"values":[{"name":"discardParsedErrorData","comment":" Useful when you don't want to deal with the recovered data if there is `ParsedData`.\nJust a shorthand for `mapError` that will turn any `ParsedData` into `()`.\n\nThis is helpful if you want to simplify your types, or if you are combining multiple\nresults together and you need the error types to line up (but you don't care about\nrecovering parsed data when there are GraphQL errors in the response).\n\nIn the examples below, notice the error type is now `(Graphql.Http.Error ())`.\n\nYou can use this when you call `Graphql.Http.send` like so:\n\n    import Graphql.Http\n\n    type Msg\n        = GotResponse (Result (Graphql.Http.Error ()) Response)\n\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"http://elm-graphql.herokuapp.com\"\n            |> Graphql.Http.send\n                (Graphql.Http.discardParsedErrorData\n                    >> RemoteData.fromResult\n                    >> GotResponse\n                )\n\nOr if you are using the RemoteData package:\n\n    import Graphql.Http\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse (RemoteData (Graphql.Http.Error ()) Response)\n\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"http://elm-graphql.herokuapp.com\"\n            |> Graphql.Http.send\n                (Graphql.Http.discardParsedErrorData\n                    >> RemoteData.fromResult\n                    >> GotResponse\n                )\n\n","type":"Result.Result (Graphql.Http.Error decodesTo) decodesTo -> Result.Result (Graphql.Http.Error ()) decodesTo"},{"name":"mapError","comment":" Map the error data if it is `ParsedData`.\n","type":"(a -> b) -> Graphql.Http.Error a -> Graphql.Http.Error b"},{"name":"mutationRequest","comment":" Initialize a basic request from a Mutation. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphql.Http.send`.\n","type":"String.String -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootMutation -> Graphql.Http.Request decodesTo"},{"name":"parseableErrorAsSuccess","comment":" WARNING: When using this function you lose information. Make sure this is\nthe approach you want before using this.\n\nTreat responses with GraphQL errors as successful responses if the data can\nbe parsed. If you want to use the successfully decoded data without ignoring the\nGraphQL error you can do a pattern match on the `Graphql.Http.Error` type\n(it contains `PossiblyParsedData` which is either unparsed with a raw\n`Json.Decode.Value` or else it contains successfully decoded data).\n\n","type":"Result.Result (Graphql.Http.Error decodesTo) decodesTo -> Result.Result (Graphql.Http.Error ()) decodesTo"},{"name":"queryRequest","comment":" Initialize a basic request from a Query. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphql.Http.send`.\n","type":"String.String -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> Graphql.Http.Request decodesTo"},{"name":"queryRequestWithHttpGet","comment":" Exactly like `queryRequest`, but with an option to use the HTTP GET request\nmethod. You will probably want to use `GetIfShortEnough`, which uses GET if the\nfull URL ends up being under 2000 characters, or POST otherwise, since [some browsers\ndon't support URLs over a certain length](https://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string?noredirect=1&lq=1).\n`GetIfShortEnough` will typically do what you need. If you must use GET no matter\nwhat when hitting your endpoint, you can use `AlwaysGet`.\n\n`queryRequest` always uses POST since some GraphQL API's don't support GET\nrequests (for example, the Github API assumes that you are doing an introspection\nquery if you make a GET request). But for semantic reasons, GET requests\nare sometimes useful for sending GraphQL Query requests. That is, a GraphQL Query\ndoes not perform side-effects on the server like a Mutation does, so a GET\nindicates this and allows some servers to cache requests. See\n[this github thread from the Apollo project](https://github.com/apollographql/apollo-client/issues/813)\nfor more details.\n\n","type":"String.String -> Graphql.Http.QueryRequestMethod -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> Graphql.Http.Request decodesTo"},{"name":"send","comment":" Send the `Graphql.Request`\nYou can use it on its own, or with a library like\n[RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/latest/).\n\n    import Graphql.Http\n    import Graphql.OptionalArgument exposing (OptionalArgument(..))\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse RemoteData (Graphql.Http.Error Response) Response\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://elm-graphql.herokuapp.com/\"\n            |> Graphql.Http.withHeader \"authorization\" \"Bearer abcdefgh12345678\"\n            -- If you're not using remote data, it's just\n            -- |> Graphql.Http.send GotResponse\n            -- With remote data, it's as below\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\nIf any errors are present, you will get a `GraphqlError` that includes the details.\nGraphQL allows for partial data to be returned in the case of errors so you can\ninspect the data returned in the `GraphqlError` if you would like to try to recover\nany data that made it through in the response.\n\n","type":"(Result.Result (Graphql.Http.Error decodesTo) decodesTo -> msg) -> Graphql.Http.Request decodesTo -> Platform.Cmd.Cmd msg"},{"name":"sendWithTracker","comment":" Exactly like `Graphql.Http.request` except it allows you to use the `String`\npassed in as the tracker to [`track`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#track)\nand [`cancel`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#cancel)\nrequests using the core Elm `Http` package (see\n[the `Http.request` docs](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#request))\n","type":"String.String -> (Result.Result (Graphql.Http.Error decodesTo) decodesTo -> msg) -> Graphql.Http.Request decodesTo -> Platform.Cmd.Cmd msg"},{"name":"toTask","comment":" Convert a Request to a Task. See `Graphql.Http.send` for an example of\nhow to build up a Request.\n","type":"Graphql.Http.Request decodesTo -> Task.Task (Graphql.Http.Error decodesTo) decodesTo"},{"name":"withCredentials","comment":" Set with credentials to true. See [the `XMLHttpRequest/withCredentials` docs](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials)\nto understand exactly what happens.\n\nUnder the hood, this will use either [`Http.riskyRequest`](https://package.elm-lang.org/packages/elm/http/latest/Http#riskyRequest)\nor [`Http.riskyTask`](https://package.elm-lang.org/packages/elm/http/latest/Http#riskyTask).\n\n","type":"Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withHeader","comment":" Add a header.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphql.Http.withHeader \"authorization\" \"Bearer <my token>\"\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\n","type":"String.String -> String.String -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withQueryParams","comment":" Add query params. The values will be Uri encoded.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphql.Http.withQueryParams [ ( \"version\", \"1.2.3\" ) ]\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\n","type":"List.List ( String.String, String.String ) -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withSimpleHttpError","comment":" Useful when you want to combine together an Http response with a Graphql\nrequest response.\n\n    -- this is just the type that our query decodes to\n    type alias Response =\n        { hello : String }\n\n    type Msg\n        = GotResponse (RemoteData (Graphql.Http.RawError Response Http.Error) Response)\n\n    request =\n        query\n            |> Graphql.Http.queryRequest \"https://some-graphql-api.com\"\n            |> Graphql.Http.send\n                (Graphql.Http.withSimpleHttpError\n                    >> RemoteData.fromResult\n                    >> GotResponse\n                )\n\n    combinedResponses =\n        RemoteData.map2 Tuple.pair\n            model.graphqlResponse\n            (model.plainHttpResponse |> RemoteData.mapError Graphql.Http.HttpError)\n\n","type":"Result.Result (Graphql.Http.Error parsedData) decodesTo -> Result.Result (Graphql.Http.RawError parsedData Http.Error) decodesTo"},{"name":"withTimeout","comment":" Add a timeout.\n","type":"Basics.Float -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"}],"binops":[]},{"name":"Graphql.Http.GraphqlError","comment":"\n\n@docs GraphqlError, decoder, Location, PossiblyParsedData\n\n","unions":[{"name":"PossiblyParsedData","comment":" Represents the `data` field in cases where there is an error present, see\n[the error section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Data).\nIf the decoder succeeds you will end up with `ParsedData`. If it fails, you\nwill get an `UnparsedData` with a `Json.Decode.Value` containing the raw, undecoded\n`data` field. You're likely to end up with `UnparsedData` since\n[GraphQL will return `null` if there is an error on a non-nullable field](http://facebook.github.io/graphql/October2016/#sec-Errors-and-Non-Nullability)\n, which will cause the decode pipeline to fail and give you `UnparsedData`.\n","args":["parsed"],"cases":[["ParsedData",["parsed"]],["UnparsedData",["Json.Decode.Value"]]]}],"aliases":[{"name":"GraphqlError","comment":" Represents an error from the GraphQL endpoint. Also see `Graphql.Http`.\n\nThe code generated by `dillonkearns/elm-graphql`\nguarantees that your requests are valid according to the server's schema, so\nthe two cases where you will get a GraphqlError are 1) when there is an implicit\nconstraint that the schema doesn't specify, or 2) when your generated code is\nout of date with the schema.\n\nSee the\n[Errors section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Errors).\nfor more details about GraphQL errors.\n\n","args":[],"type":"{ message : String.String, locations : Maybe.Maybe (List.List Graphql.Http.GraphqlError.Location), details : Dict.Dict String.String Json.Decode.Value }"},{"name":"Location","comment":" The location in the GraphQL query document where the error occured\n","args":[],"type":"{ line : Basics.Int, column : Basics.Int }"}],"values":[{"name":"decoder","comment":" For internal use only.\n","type":"Json.Decode.Decoder (List.List Graphql.Http.GraphqlError.GraphqlError)"}],"binops":[]},{"name":"Graphql.Internal.Builder.Argument","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `@dillonkearns/elm-graphql` CLI.\n\n@docs Argument, optional, required\n\n","unions":[{"name":"Argument","comment":" Argument type.\n","args":[],"cases":[["Argument",["String.String","Graphql.Internal.Encode.Value"]]]}],"aliases":[],"values":[{"name":"optional","comment":" Used for passing optional arguments in generated code.\n","type":"String.String -> Graphql.OptionalArgument.OptionalArgument a -> (a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe Graphql.Internal.Builder.Argument.Argument"},{"name":"required","comment":" Used for passing required arguments in generated code.\n","type":"String.String -> a -> (a -> Graphql.Internal.Encode.Value) -> Graphql.Internal.Builder.Argument.Argument"}],"binops":[]},{"name":"Graphql.Internal.Builder.Object","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `@dillonkearns/elm-graphql` CLI.\n\n@docs scalarDecoder, exhuastiveFragmentSelection, buildFragment, selectionForField, selectionForCompositeField\n\n","unions":[],"aliases":[],"values":[{"name":"buildFragment","comment":" Used to create FragmentSelectionSets for type-specific fragmentsin auto-generated code.\n","type":"String.String -> Graphql.SelectionSet.SelectionSet decodesTo selectionLock -> Graphql.SelectionSet.FragmentSelectionSet decodesTo fragmentLock"},{"name":"exhuastiveFragmentSelection","comment":" Used to create the `selection` functions in auto-generated code for exhuastive fragments.\n","type":"List.List (Graphql.SelectionSet.FragmentSelectionSet decodesTo typeLock) -> Graphql.SelectionSet.SelectionSet decodesTo typeLock"},{"name":"scalarDecoder","comment":" Decoder for scalars for use in auto-generated code.\n","type":"Json.Decode.Decoder String.String"},{"name":"selectionForCompositeField","comment":" Refer to an object in auto-generated code.\n","type":"String.String -> List.List Graphql.Internal.Builder.Argument.Argument -> Graphql.SelectionSet.SelectionSet a objectTypeLock -> (Json.Decode.Decoder a -> Json.Decode.Decoder b) -> Graphql.SelectionSet.SelectionSet b lockedTo"},{"name":"selectionForField","comment":" Refer to a field in auto-generated code.\n","type":"String.String -> String.String -> List.List Graphql.Internal.Builder.Argument.Argument -> Json.Decode.Decoder decodesTo -> Graphql.SelectionSet.SelectionSet decodesTo lockedTo"}],"binops":[]},{"name":"Graphql.Internal.Encode","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\n`Graphql.Internal.Encode.Value`s are low-level details used by generated code.\nThey are only used by the code generated by the `@dillonkearns/elm-graphql` CLI tool.\n\n@docs null, bool, enum, int, list, string, object, maybe, maybeObject, optional, float, fromJson\n@docs serialize\n@docs Value\n\n","unions":[{"name":"Value","comment":" Represents an encoded Value\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"bool","comment":" Encode a bool\n","type":"Basics.Bool -> Graphql.Internal.Encode.Value"},{"name":"enum","comment":" Encode an enum. The first argument is the toString function for that enum.\n","type":"(a -> String.String) -> a -> Graphql.Internal.Encode.Value"},{"name":"float","comment":" Encode a float\n","type":"Basics.Float -> Graphql.Internal.Encode.Value"},{"name":"fromJson","comment":" Encode directly from `Json.Encode.Value`. For internal use by\ncustom scalar codecs.\n","type":"Json.Encode.Value -> Graphql.Internal.Encode.Value"},{"name":"int","comment":" Encode an int\n","type":"Basics.Int -> Graphql.Internal.Encode.Value"},{"name":"list","comment":" Encode a list of Values\n","type":"(a -> Graphql.Internal.Encode.Value) -> List.List a -> Graphql.Internal.Encode.Value"},{"name":"maybe","comment":" Encode a Maybe. Uses encoder for `Just`, or `Encode.null` for `Nothing`.\n","type":"(a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe a -> Graphql.Internal.Encode.Value"},{"name":"maybeObject","comment":" Encode a list of key-value pairs into an object\n","type":"List.List ( String.String, Maybe.Maybe Graphql.Internal.Encode.Value ) -> Graphql.Internal.Encode.Value"},{"name":"null","comment":" Encode null\n","type":"Graphql.Internal.Encode.Value"},{"name":"object","comment":" Encode a list of key-value pairs into an object\n","type":"List.List ( String.String, Graphql.Internal.Encode.Value ) -> Graphql.Internal.Encode.Value"},{"name":"optional","comment":" Encode a list of key-value pairs into an object\n","type":"Graphql.OptionalArgument.OptionalArgument a -> (a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe Graphql.Internal.Encode.Value"},{"name":"serialize","comment":" Low-level function for serializing a `Graphql.Internal.Encode.Value`s.\n","type":"Graphql.Internal.Encode.Value -> String.String"},{"name":"string","comment":" Encode a string\n","type":"String.String -> Graphql.Internal.Encode.Value"}],"binops":[]},{"name":"Graphql.Operation","comment":" This module contains types used to annotate top-level queries which can be\nbuilt up using functions in code generated by the `@dillonkearns/elm-graphql` command line tool\nand sent using functions in the `Graphql.Http` module.\n\n@docs RootMutation, RootQuery, RootSubscription\n\n","unions":[{"name":"RootMutation","comment":" Type for top-level mutations which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]},{"name":"RootQuery","comment":" Type for top-level queries which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]},{"name":"RootSubscription","comment":" Type for top-level mutations which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]}],"aliases":[],"values":[],"binops":[]},{"name":"Graphql.OptionalArgument","comment":"\n\n@docs OptionalArgument\n@docs fromMaybe\n@docs map\n\n","unions":[{"name":"OptionalArgument","comment":" This type is used to create values to pass in optional arguments.\n\n      import Api.Enum.Episode as Episode exposing (Episode)\n      import Api.Query as Query\n      import Graphql.Operation exposing (RootQuery)\n      import Graphql.OptionalArgument exposing (OptionalArgument(Null, Present))\n      import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, with)\n\n\n      query : SelectionSet Response RootQuery\n      query =\n          SelectionSet.succeed Response\n              |> with (Query.human { id = \"1004\" } human)\n              |> with (Query.human { id = \"1001\" } human)\n              |> with\n                  (Query.hero\n                      (\\optionals ->\n                          { optionals\n                              | episode = Present Episode.EMPIRE\n                          }\n                      )\n                      hero\n                  )\n\nAn optional argument can be either present, absent, or null, so using a Maybe does not\nfully capture the GraphQL concept of an optional argument. For example, you could have\na mutation that deletes an entry if a null argument is provided, or does nothing if\nthe argument is absent. See\n[The official GraphQL spec section on null](http://facebook.github.io/graphql/October2016/#sec-Null-Value)\nfor details.\n\n","args":["a"],"cases":[["Present",["a"]],["Absent",[]],["Null",[]]]}],"aliases":[],"values":[{"name":"fromMaybe","comment":" Convert a `Maybe` to an OptionalArgument.\n","type":"Maybe.Maybe a -> Graphql.OptionalArgument.OptionalArgument a"},{"name":"map","comment":" Transform an OptionalArgument value with a given function.\n","type":"(a -> b) -> Graphql.OptionalArgument.OptionalArgument a -> Graphql.OptionalArgument.OptionalArgument b"}],"binops":[]},{"name":"Graphql.SelectionSet","comment":" The auto-generated code from the `@dillonkearns/elm-graphql` CLI provides\nfunctions that you can use to build up `SelectionSet`s for the GraphQL Objects,\nInterfaces, and Unions in your GraphQL schema.\n\nNote that in these examples, all of the modules that start with `StarWars.` or `Github.`\nare generated by running the [`@dillonkearns/elm-graphql`](https://npmjs.com/package/@dillonkearns/elm-graphql)\ncommand line tool.\n\nThere are lots more end-to-end examples in the\n[`examples` ](https://github.com/dillonkearns/elm-graphql/tree/master/examples/src)\nfolder.\n\nWith `dillonkearns/elm-graphql`, a `SelectionSet` describes a set of fields to\nretrieve. It contains all the information needed to make the request and decode\nthe response (you don't hand-code the decoders yourself, they are auto-generated\nfor you!).\n\n\n## Building `SelectionSet`s\n\nA `SelectionSet` in `dillonkearns/elm-graphql` represents a set of\nzero or more things which are either sub-`SelectionSet`s or leaf fields.\n\nFor example, `SelectionSet.empty` is the most basic `SelectionSet` you could build.\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Query as Query\n\n    query : SelectionSet () RootQuery\n    query =\n        SelectionSet.empty\n\nYou can execute this query, but the result won't be very interesting!\n\nIn the StarWars API example in the [`examples`](https://github.com/dillonkearns/elm-graphql/tree/master/examples/src)\nfolder, there is a top-level query field called `hello`. So you could also\nbuild a valid query to get `hello`:\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Query as Query\n\n    query : SelectionSet Response RootQuery\n    query =\n        Query.hello\n\nThis is the equivalent of this raw GraphQL query:\n\n    query {\n      hello\n    }\n\nIf we wanted to query for two top-level fields it's just as easy. Let's see how we would grab both the `hello` and `goodbye` fields like this:\n\n    query {\n      hello\n      goodbye\n    }\n\nThe only difference for combining two `SelectionSet`s is that you need to define which\nfunction we want to use to combine the two fields together into one piece of data.\nLet's just define our own function for now, called `welcomeMessage`.\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Query\n\n    welcomeMessage : String -> String -> String\n    welcomeMessage hello today =\n        hello ++ \"\\nToday is \" ++ today\n\n    query : SelectionSet String RootQuery\n    query =\n        SelectionSet.map2 welcomeMessage\n            Query.hello\n            Query.today\n\n    {-\n       If you run this query you'll get something like:\n\n       Hello from GraphQL!\n       Today is Wednesday, December 5\n    -}\n\nGreat, we retrieved two fields! But often you don't want to combine the values\ninto a primitive, you just want to store the values in some data structure\nlike a record. So a very common pattern is to use record constructors as the\nconstructor function for `map2` (or `mapN`). Any function that takes the right number of arguments\n(of the right types, order matters) will work here.\n\nLet's define a type alias for a record called `Phrases`. When we define this\ntype alias, Elm creates a function called `Phrases` that will build up a record\nof that type. So we can use that function with `map2`!\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Query\n\n    type alias Phrases =\n        { helloPhrase : String\n        , goodbyePhrase : String\n        }\n\n    hero : SelectionSet Phrases RootQuery\n    hero =\n        SelectionSet.map2 Phrases\n            Query.hello\n            Query.goodbye\n\nNote that if you changed the order of `Query.hello` and `Query.goodbye`,\nyou would end up with a record with values under the wrong name. Order matters\nwith record constructors!\n\n\n## Modularizing `SelectionSet`s\n\nSince both single fields and collections of fields are `SelectionSet`s in `dillonkearns/elm-graphql`,\nyou can easily pull in sub-`SelectionSet`s to your queries. Just treat it like you would a regular field.\n\nThis is analagous to using a [fragment in plain GraphQL](https://graphql.org/learn/queries/#fragments).\nThis is a handy tool for modularizing your GraphQL queries.\n\nLet's say we want to query Github's GraphQL API like this:\n\n    {\n      repository(owner: \"dillonkearns\", name: \"elm-graphql\") {\n      nameWithOwner\n      ...timestamps\n      stargazers(first: 0) { totalCount }\n      }\n    }\n\n    fragment timestamps on Repository {\n      createdAt\n      updatedAt\n    }\n\n(You can try the above query for yourself by pasting the query into the [Github query explorer](https://developer.github.com/v4/explorer/)).\n\nWe could do the equivalent of the `timestamps` fragment with the `timestampsFragment`\nwe define below.\n\n    import Github.Object\n    import Github.Object.Repository as Repository\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import Iso8601\n    import Time exposing (Posix)\n\n    type alias Repo =\n        { nameWithOwner : String\n        , timestamps : Timestamps\n        }\n\n    type alias Timestamps =\n        { createdAt : Posix\n        , updatedAt : Posix\n        }\n\n    repositorySelection : SelectionSet Repo Github.Object.Repository\n    repositorySelection =\n        SelectionSet.map2 Repo\n            Repository.nameWithOwner\n            timestampsFragment\n\n    timestampsFragment : SelectionSet Timestamps Github.Object.Repository\n    timestampsFragment =\n        SelectionSet.map2 Timestamps\n            (Repository.createdAt |> mapToDateTime)\n            (Repository.updatedAt |> mapToDateTime)\n\n    mapToDateTime : SelectionSet Github.Scalar.DateTime typeLock -> SelectionSet Posix typeLock\n    mapToDateTime =\n        SelectionSet.mapOrFail\n            (\\(Github.Scalar.DateTime value) ->\n                Iso8601.toTime value\n                    |> Result.mapError\n                        (\\_ ->\n                            \"Failed to parse \"\n                                ++ value\n                                ++ \" as Iso8601 DateTime.\"\n                        )\n            )\n\nNote that both individual GraphQL fields (like `Repository.nameWithOwner`), and\ncollections of fields (like our `timestampsFragment`) are just `SelectionSet`s.\nSo whether it's a single field or a pair of fields, we can pull it into our\nquery using the exact same syntax!\n\nModularizing your queries like this is a great idea. Dealing with these\nsub-`SelectionSet`s also allows the Elm compiler to give you more precise\nerror messages. Just be sure to add type annotations to all your `SelectionSet`s!\n\n\n## Mapping & Combining\n\nNote: If you run out of `mapN` functions for building up `SelectionSet`s,\nyou can use the pipeline\nwhich makes it easier to handle large objects, but produces\nlower quality type errors.\n\n@docs map\n\n@docs map2, map3, map4, map5, map6, map7, map8\n\n@docs withDefault\n\n\n## Pipelines\n\nAs an alternative to the `mapN` functions, you can build up\n`SelectionSet`s using the pipeline syntax. If you've used\nthe [`elm-json-decode-pipeline`](https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/)\npackage then this style will feel very familiar. The `map2` example in this page\nwould translate to this using the pipeline notation:\n\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, with)\n    import StarWars.Object\n    import StarWars.Object.Human as Human\n\n    type alias Human =\n        { name : String\n        , id : String\n        }\n\n    hero : SelectionSet Hero StarWars.Object.Human\n    hero =\n        SelectionSet.succeed Human\n            |> with Human.name\n            |> with Human.id\n\nYou can see an end-to-end example using the pipeline syntax in the [`examples`](https://github.com/dillonkearns/elm-graphql/tree/master/examples/src)\nfolder.\n\n@docs with, hardcoded, succeed\n\n@docs empty\n\n\n## Types\n\nThese types are built for you by the code generated by the `@dillonkearns/elm-graphql` command line tool.\n\n@docs SelectionSet, FragmentSelectionSet\n\n\n## Result (`...OrFail`) Transformations\n\n**Warning** When you use these functions, you lose the guarantee that the\nserver response will decode successfully.\n\nThese helpers, though convenient, will cause your entire decoder to fail if\nit ever maps to an `Err` instead of an `Ok` `Result`.\n\nIf you're wondering why there are so many `Maybe`s in your generated code,\ntake a look at the\n[FAQ question \"Why are there so many Maybes in my responses? How do I reduce them?\"](https://github.com/dillonkearns/graphqelm/blob/master/FAQ.md#why-are-there-so-many-maybes-in-my-responses-how-do-i-reduce-them).\n\n@docs mapOrFail, nonNullOrFail, nonNullElementsOrFail\n\n\n## Collections of SelectionSets\n\n@docs list, dict\n\n","unions":[{"name":"FragmentSelectionSet","comment":" This type is used internally only in the generated code.\n","args":["decodesTo","typeLock"],"cases":[["FragmentSelectionSet",["String.String","List.List Graphql.RawField.RawField","Json.Decode.Decoder decodesTo"]]]},{"name":"SelectionSet","comment":" SelectionSet type\n","args":["decodesTo","typeLock"],"cases":[["SelectionSet",["List.List Graphql.RawField.RawField","Json.Decode.Decoder decodesTo"]]]}],"aliases":[],"values":[{"name":"dict","comment":" Combine several `SelectionSet`s into a single `SelectionSet`. The\n`String`s are used as the `Dict` keys and the result of the `SelectionSet`s\nwill be the values in the `Dict`. Note that the `SelectionSet`s must first\nbe coerced into the same type if they are not already. Usually you'll just\nwant to use `map2` and other functions in that section of these docs.\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.OptionalArgument exposing (OptionalArgument(..))\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import Swapi.Enum.Episode as Episode exposing (Episode)\n    import Swapi.Interface.Character as Character\n    import Swapi.Query as Query\n\n    herosDict : SelectionSet (Dict String String) RootQuery\n    herosDict =\n        Episode.list\n            |> List.map\n                (\\episode ->\n                    ( Episode.toString episode\n                    , Query.hero\n                        (\\optionals -> { optionals | episode = Present episode })\n                        Character.name\n                    )\n                )\n            |> SelectionSet.dict\n\n","type":"List.List ( String.String, Graphql.SelectionSet.SelectionSet a typeLock ) -> Graphql.SelectionSet.SelectionSet (Dict.Dict String.String a) typeLock"},{"name":"empty","comment":" Useful for Mutations when you don't want any data back.\n\n    import Graphql.Operation exposing (RootMutation)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Mutation as Mutation\n\n    sendChatMessage : String -> SelectionSet () RootMutation\n    sendChatMessage message =\n        Mutation.sendMessage\n            { message = message }\n            SelectionSet.empty\n\n","type":"Graphql.SelectionSet.SelectionSet () typeLock"},{"name":"hardcoded","comment":" Include a hardcoded value. This is used analagously to `with` to add values\ninto a pipeline.\n\n        import StarWars.Enum.Episode as Episode exposing (Episode)\n        import StarWars.Object\n        import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, with, hardcoded)\n\n        type alias Hero =\n            { name : String\n            , movie : String\n            }\n\n        hero : SelectionSet Hero StarWars.Interface.Character\n        hero =\n            SelectionSet.succeed Hero\n                |> with Character.name\n                |> hardcoded \"Star Wars\"\n\n","type":"a -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"list","comment":" Combine a `List` of `SelectionSet`s into a single `SelectionSet`.\nNote that the `SelectionSet`s must first be coerced into the same type if they\nare not already. Usually you'll just want to use `map2` and other functions in\nthat section of these docs.\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.OptionalArgument exposing (OptionalArgument(..))\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import Swapi.Enum.Episode as Episode exposing (Episode)\n    import Swapi.Interface.Character as Character\n    import Swapi.Query as Query\n\n    heros : SelectionSet (List String) RootQuery\n    heros =\n        Episode.list\n            |> List.map\n                (\\episode ->\n                    Query.hero\n                        (\\optionals -> { optionals | episode = Present episode })\n                        Character.name\n                )\n            |> SelectionSet.list\n\n","type":"List.List (Graphql.SelectionSet.SelectionSet a typeLock) -> Graphql.SelectionSet.SelectionSet (List.List a) typeLock"},{"name":"map","comment":" Maps the data coming back from the GraphQL endpoint. In this example,\n`User.name` is a function that the `@dillonkearns/elm-graphql` CLI tool created which tells us\nthat the `name` field on a `User` object is a String according to your GraphQL\nschema.\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet exposing (SelectionSet)\n    import StarWars.Query as Query\n\n    query : SelectionSet String RootQuery\n    query =\n        Query.hello |> SelectionSet.map String.toUpper\n\nYou can also map to values of a different type. For example, if we\nuse a (`String -> Int`) map function, it will change the type of our `SelectionSet`\naccordingly:\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet exposing (SelectionSet)\n    import StarWars.Query as Query\n\n    query : SelectionSet Int RootQuery\n    query =\n        Query.hello |> SelectionSet.map String.length\n\n`SelectionSet.map` is also helpful when using a record to wrap a type:\n\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.SelectionSet exposing (SelectionSet)\n    import StarWars.Query as Query\n\n    type alias Response =\n        { hello : String }\n\n    query : SelectionSet Response RootQuery\n    query =\n        SelectionSet.map Response Query.hello\n\nMapping is also handy when you are dealing with polymorphic GraphQL types\n(Interfaces and Unions).\n\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Object.Droid as Droid\n    import StarWars.Object.Human as Human\n    import StarWars.Union\n    import StarWars.Union.CharacterUnion\n\n    type HumanOrDroidDetails\n        = HumanDetails (Maybe String)\n        | DroidDetails (Maybe String)\n\n    heroUnionSelection : SelectionSet HumanOrDroidDetails StarWars.Union.CharacterUnion\n    heroUnionSelection =\n        StarWars.Union.CharacterUnion.fragments\n            { onHuman = SelectionSet.map HumanDetails Human.homePlanet\n            , onDroid = SelectionSet.map DroidDetails Droid.primaryFunction\n            }\n\n","type":"(a -> b) -> Graphql.SelectionSet.SelectionSet a typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"map2","comment":" Combine two `SelectionSet`s into one, using the given combine function to\nmerge the two data sets together.\n\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Object\n    import StarWars.Object.Human as Human\n    import StarWars.Scalar\n\n    type alias Human =\n        { name : String\n        , id : StarWars.Scalar.Id\n        }\n\n    hero : SelectionSet Hero StarWars.Object.Human\n    hero =\n        SelectionSet.map2 Human\n            Human.name\n            Human.id\n\nCheck out the [`examples`](https://github.com/dillonkearns/elm-graphql/tree/master/examples/src)\nfolder, there are lots of end-to-end examples there!\n\n","type":"(decodesTo1 -> decodesTo2 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map3","comment":" Combine three `SelectionSet`s into one, using the given combine function to\nmerge the two data sets together. This gives more clear error messages than the\npipeline syntax (using `SelectionSet.succeed` to start the pipeline\nand `SelectionSet.with` to continue it).\n\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet)\n    import StarWars.Interface\n    import StarWars.Interface.Character as Character\n    import StarWars.Scalar\n\n    type alias Character =\n        { name : String\n        , id : StarWars.Scalar.Id\n        , friends : List String\n        }\n\n    characterSelection : SelectionSet Character StarWars.Interface.Character\n    characterSelection =\n        SelectionSet.map3 Character\n            Character.name\n            Character.id\n            (Character.friends Character.name)\n\n","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map4","comment":" ","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesTo4 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo4 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map5","comment":" ","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesTo4 -> decodesTo5 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo4 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo5 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map6","comment":" ","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesTo4 -> decodesTo5 -> decodesTo6 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo4 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo5 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo6 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map7","comment":" ","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesTo4 -> decodesTo5 -> decodesTo6 -> decodesTo7 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo4 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo5 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo6 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo7 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"map8","comment":" ","type":"(decodesTo1 -> decodesTo2 -> decodesTo3 -> decodesTo4 -> decodesTo5 -> decodesTo6 -> decodesTo7 -> decodesTo8 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo3 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo4 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo5 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo6 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo7 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo8 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"mapOrFail","comment":" If the map function provided returns an `Ok` `Result`, it will map to that value.\nIf it returns an `Err`, the _entire_ response will fail to decode.\n\n    import Time exposing (Posix)\n    import Github.Object\n    import Github.Object.Repository\n    import Github.Scalar\n    -- NOTE: Iso8601 comes from an external dependency in Elm >= 0.19:\n    -- https://package.elm-lang.org/packages/rtfeldman/elm-iso8601-date-strings/latest/\n    import Iso8601\n    import Graphql.SelectionSet as SelectionSet exposing (with)\n\n    type alias Timestamps =\n    { created : Posix\n    , updated : Posix\n    }\n\n\n    timestampsSelection : SelectionSet Timestamps Github.Object.Repository\n    timestampsSelection =\n        SelectionSet.succeed Timestamps\n            |> with (Repository.createdAt |> mapToDateTime)\n            |> with (Repository.updatedAt |> mapToDateTime)\n\n\n    mapToDateTime : Field Github.Scalar.DateTime typeLock -> Field Posix typeLock\n    mapToDateTime =\n        Field.mapOrFail\n            (\\(Github.Scalar.DateTime value) ->\n                Iso8601.toTime value\n                    |> Result.mapError (\\_ -> \"Failed to parse \"\n                     ++ value ++ \" as Iso8601 DateTime.\")\n\n","type":"(decodesTo -> Result.Result String.String mapsTo) -> Graphql.SelectionSet.SelectionSet decodesTo typeLock -> Graphql.SelectionSet.SelectionSet mapsTo typeLock"},{"name":"nonNullElementsOrFail","comment":" Effectively turns a field that is `[String]` => `[String!]`, or `[User]` =>\n`[User!]` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if any elements in the list for this\nfield comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\nOften GraphQL schemas will contain things like `[String]` (i.e. a nullable list\nof nullable strings) when they really mean `[String!]!` (a non-nullable list of\nnon-nullable strings). You can chain together these nullable helpers if for some\nreason you can't go in and fix this in the schema, for example:\n\n    releases : SelectionSet (List Release) Github.Object.ReleaseConnection\n    releases =\n        Github.Object.ReleaseConnection.nodes release\n            |> Field.nonNullOrFail\n            |> Field.nonNullElementsOrFail\n\nWithout the `Field.nonNull...` transformations here, the type would be\n`SelectionSet (Maybe (List (Maybe Release))) Github.Object.ReleaseConnection`.\n\n","type":"Graphql.SelectionSet.SelectionSet (List.List (Maybe.Maybe decodesTo)) typeLock -> Graphql.SelectionSet.SelectionSet (List.List decodesTo) typeLock"},{"name":"nonNullOrFail","comment":" Effectively turns an attribute that is `String` => `String!`, or `User` =>\n`User!` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if the field comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\n","type":"Graphql.SelectionSet.SelectionSet (Maybe.Maybe decodesTo) typeLock -> Graphql.SelectionSet.SelectionSet decodesTo typeLock"},{"name":"succeed","comment":" Most commonly `succeed` is used to start a pipeline. See the description\nin the Pipeline section above for more.\n\nThere are other ways to use `succeed`. It simply takes the value you pass into it\nand decodes into that value without looking at the GraphQL response (just like\n`Json.Decode.succeed`).\n\nSo instead of hardcoding a field like `hardcoded`, `SelectionSet.succeed` hardcodes\nan entire `SelectionSet`. This can be useful if you want hardcoded data based on\nonly the type when using a polymorphic type (Interface or Union).\n\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, with)\n    import StarWars.Interface\n    import StarWars.Interface.Character as Character\n\n    type alias Character =\n        { typename : HumanOrDroid\n        , name : String\n        }\n\n    type HumanOrDroid\n        = Human\n        | Droid\n\n    hero : SelectionSet Character StarWars.Interface.Character\n    hero =\n        SelectionSet.succeed Character\n            |> with heroType\n            |> with Character.name\n\n    heroType : SelectionSet HumanOrDroid StarWars.Interface.Character\n    heroType =\n        Character.fragments\n            { onHuman = SelectionSet.succeed Human\n            , onDroid = SelectionSet.succeed Droid\n            }\n\n","type":"a -> Graphql.SelectionSet.SelectionSet a typeLock"},{"name":"with","comment":" See the explanation in the Pipeline section. This function is used\nto add `SelectionSet`s onto a pipeline.\n","type":"Graphql.SelectionSet.SelectionSet a typeLock -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"withDefault","comment":" A helper for mapping a SelectionSet to provide a default value.\n","type":"a -> Graphql.SelectionSet.SelectionSet (Maybe.Maybe a) typeLock -> Graphql.SelectionSet.SelectionSet a typeLock"}],"binops":[]}]