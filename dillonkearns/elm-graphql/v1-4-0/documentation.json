[{"name":"Graphql.Document","comment":" You'll usually want to use `Graphql.Http` to perform your queries directly.\nThis package provides low-level functions for generating GraphQL documents that\nare helpful for debugging and demo purposes.\n\n@docs serializeQuery, serializeMutation, serializeSubscription, serializeQueryForUrl, decoder\n\n","unions":[],"aliases":[],"values":[{"name":"decoder","comment":" Decoder a response from the server. This low-level function shouldn't be needed\nin the majority of cases. Instead, the high-level functions in `Graphql.Http`\nshould be used.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo typeLock -> Json.Decode.Decoder decodesTo"},{"name":"serializeMutation","comment":" Serialize a mutation selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootMutation -> String.String"},{"name":"serializeQuery","comment":" Serialize a query selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> String.String"},{"name":"serializeQueryForUrl","comment":" Serialize a query selection set into a string with minimal whitespace. For\nuse with a GET request as a query param.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> String.String"},{"name":"serializeSubscription","comment":" Serialize a subscription selection set into a string for a GraphQL endpoint.\n","type":"Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootSubscription -> String.String"}],"binops":[]},{"name":"Graphql.Field","comment":" `Field`s are automatically generated by the `@dillonkearns/elm-graphql` CLI command.\nYou can use `Graphql.Field.map` to transform a value.\n\n\n## Safe Transformations\n\n@docs map\n\n\n## Result (`...OrFail`) Transformations\n\n**Warning** When you use these functions, you lose the guarantee that the\nserver response will decode successfully.\n\nThese helpers, though convenient, will cause your entire decoder to fail if\nit ever maps to an `Err` instead of an `Ok` `Result`.\n\n@docs mapOrFail, nonNullOrFail, nonNullElementsOrFail\n\n\n## Types\n\n@docs Field\n\n","unions":[{"name":"Field","comment":" ","args":["decodesTo","typeLock"],"cases":[["Field",["Graphql.RawField.RawField","Json.Decode.Decoder decodesTo"]]]}],"aliases":[],"values":[{"name":"map","comment":" Maps the data coming back from the GraphQL endpoint. In this example,\n`User.name` is a function that the `@dillonkearns/elm-graphql` CLI tool created which tells us\nthat the `name` field on a `User` object is a String according to your GraphQL\nschema.\n\n    import Api.Object\n    import Api.Object.User as User\n    import Graphql.Field as Field\n    import Graphql.SelectionSet exposing (SelectionSet, with)\n\n    human : SelectionSet String Api.Object.User\n    human =\n        User.selection identity\n            |> with\n                (User.name\n                    |> Field.map String.toUpper\n                )\n\nYou can also map to values of a different type (`String -> Int`, for example), see\n[`examples/StarWars.elm`](https://github.com/dillonkearns/elm-graphql/blob/master/examples/src/Starwars.elm) for more advanced example.\n\n","type":"(decodesTo -> mapsTo) -> Graphql.Field.Field decodesTo typeLock -> Graphql.Field.Field mapsTo typeLock"},{"name":"mapOrFail","comment":" If the map function provided returns an `Ok` `Result`, it will map to that value.\nIf it returns an `Err`, the _entire_ response will fail to decode.\n\n    import Date exposing (Date)\n    import Github.Object\n    import Github.Object.Repository\n    import Github.Scalar\n    import Graphql.Field as Field exposing (Field)\n\n    createdAt : Field Date Github.Object.Repository\n    createdAt =\n        Github.Object.Repository.createdAt\n            |> Field.mapOrFail\n                (\\(Github.Scalar.DateTime dateTime) ->\n                    Date.fromString dateTime\n                )\n\n","type":"(decodesTo -> Result.Result String.String mapsTo) -> Graphql.Field.Field decodesTo typeLock -> Graphql.Field.Field mapsTo typeLock"},{"name":"nonNullElementsOrFail","comment":" Effectively turns a field that is `[String]` => `[String!]`, or `[User]` =>\n`[User!]` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if any elements in the list for this\nfield comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\nOften GraphQL schemas will contain things like `[String]` (i.e. a nullable list\nof nullable strings) when they really mean `[String!]!` (a non-nullable list of\nnon-nullable strings). You can chain together these nullable helpers if for some\nreason you can't go in and fix this in the schema, for example:\n\n    releases : SelectionSet (List Release) Github.Object.ReleaseConnection\n    releases =\n        Github.Object.ReleaseConnection.selection identity\n            |> with\n                (Github.Object.ReleaseConnection.nodes release\n                    |> Field.nonNullOrFail\n                    |> Field.nonNullElementsOrFail\n                )\n\nWithout the `Field.nonNull...` transformations here, the type would be\n`SelectionSet (Maybe (List (Maybe Release))) Github.Object.ReleaseConnection`.\n\n","type":"Graphql.Field.Field (List.List (Maybe.Maybe decodesTo)) typeLock -> Graphql.Field.Field (List.List decodesTo) typeLock"},{"name":"nonNullOrFail","comment":" Effectively turns an attribute that is `String` => `String!`, or `User` =>\n`User!` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if the field comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\n","type":"Graphql.Field.Field (Maybe.Maybe decodesTo) typeLock -> Graphql.Field.Field decodesTo typeLock"}],"binops":[]},{"name":"Graphql.Http","comment":" Send requests to your GraphQL endpoint. See [this live code demo](https://rebrand.ly/graphqelm)\nor the [`examples/`](https://github.com/dillonkearns/elm-graphql/tree/master/examples)\nfolder for some end-to-end examples.\nThe builder syntax is inspired by Luke Westby's\n[elm-http-builder package](http://package.elm-lang.org/packages/lukewestby/elm-http-builder/latest).\n\n\n## Data Types\n\n@docs Request, Error\n\n\n## Begin `Request` Pipeline\n\n@docs queryRequest, mutationRequest, queryRequestWithHttpGet\n@docs QueryRequestMethod\n\n\n## Configure `Request` Options\n\n@docs withHeader, withTimeout, withCredentials, withQueryParams\n\n\n## Perform `Request`\n\n@docs send, sendWithTracker, toTask\n\n\n## Map `Error`s\n\n@docs mapError, ignoreParsedErrorData, fromHttpError, discardParsedErrorData\n\n\n## Error Handling Strategies\n\nThere are 3 possible strategies to handle GraphQL errors.\n\n1.  **`parseableErrorAsSuccess`** If there is a GraphQL error (and the data was\n    complete enough for the decoder to run successfully), pretend that there was\n    no error at all.\n2.  **Not Implemented** If there is a GraphQL error pretend it was a network error.\n    There is currently no implementation for this strategy, if you think this\n    would come in handy, please open a Github issue to describe your use case!\n3.  **Default** This gives you full control. You get an accurate and exact\n    picture of what happened (got a GraphQL error & could parse the body, got a\n    GraphQL error and couldn't parse the body, got an http error, or got\n    everything was successful). And you can handle each case explicitly.\n\n@docs parseableErrorAsSuccess\n\n","unions":[{"name":"Error","comment":" Represents the two types of errors you can get, an Http error or a GraphQL error.\nSee the `Graphql.Http.GraphqlError` module docs for more details.\n","args":["parsedData"],"cases":[["GraphqlError",["Graphql.Http.GraphqlError.PossiblyParsedData parsedData","List.List Graphql.Http.GraphqlError.GraphqlError"]],["HttpError",["Http.Error"]]]},{"name":"QueryRequestMethod","comment":" Union type to pass in to `queryRequestWithHttpGet`. Only applies to queries.\nMutations don't accept this configuration option and will always use POST.\n","args":[],"cases":[["AlwaysGet",[]],["GetIfShortEnough",[]]]},{"name":"Request","comment":" An internal request as it's built up. Once it's built up, send the\nrequest with `Graphql.Http.send`.\n","args":["decodesTo"],"cases":[]}],"aliases":[],"values":[{"name":"discardParsedErrorData","comment":" Useful when you don't want to deal with the recovered data if there is `ParsedData`.\nJust a shorthand for `mapError` that will turn any `ParsedData` into `()`.\n\nThis is helpful if you want to simplify your types, or if you are combining multiple\nresults together and you need the error types to line up (but you don't care about\nrecovering parsed data when there are GraphQL errors in the response).\n\nIn the examples below, notice the error type is now `(Graphql.Http.Error ())`.\n\nYou can use this when you call `Graphql.Http.send` like so:\n\n    import Graphql.Http\n\n    type Msg\n        = GotResponse (Result (Graphql.Http.Error ()) Response)\n\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"http://elm-graphql.herokuapp.com\"\n            |> Graphql.Http.send\n                (Graphql.Http.discardParsedErrorData\n                    >> RemoteData.fromResult\n                    >> GotResponse\n                )\n\nOr if you are using the RemoteData package:\n\n    import Graphql.Http\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse (RemoteData (Graphql.Http.Error ()) Response)\n\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"http://elm-graphql.herokuapp.com\"\n            |> Graphql.Http.send\n                (Graphql.Http.discardParsedErrorData\n                    >> RemoteData.fromResult\n                    >> GotResponse\n                )\n\n","type":"Result.Result (Graphql.Http.Error decodesTo) decodesTo -> Result.Result (Graphql.Http.Error ()) decodesTo"},{"name":"fromHttpError","comment":" Turn an `Http.Error` into a `Graphql.Http.Error`.\n","type":"Http.Error -> Graphql.Http.Error ()"},{"name":"ignoreParsedErrorData","comment":" Useful when you don't want to deal with the recovered data if there is `ParsedData`.\nJust a shorthand for `mapError` that will turn any `ParsedData` into `()`.\n","type":"Graphql.Http.Error parsedData -> Graphql.Http.Error ()"},{"name":"mapError","comment":" Map the error data if it is `ParsedData`.\n","type":"(a -> b) -> Graphql.Http.Error a -> Graphql.Http.Error b"},{"name":"mutationRequest","comment":" Initialize a basic request from a Mutation. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphql.Http.send`.\n","type":"String.String -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootMutation -> Graphql.Http.Request decodesTo"},{"name":"parseableErrorAsSuccess","comment":" WARNING: When using this function you lose information. Make sure this is\nthe approach you want before using this.\n\nTreat responses with GraphQL errors as successful responses if the data can\nbe parsed. If you want to use the successfully decoded data without ignoring the\nGraphQL error you can do a pattern match on the `Graphql.Http.Error` type\n(it contains `PossiblyParsedData` which is either unparsed with a raw\n`Json.Decode.Value` or else it contains successfully decoded data).\n\n","type":"Result.Result (Graphql.Http.Error decodesTo) decodesTo -> Result.Result (Graphql.Http.Error ()) decodesTo"},{"name":"queryRequest","comment":" Initialize a basic request from a Query. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphql.Http.send`.\n","type":"String.String -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> Graphql.Http.Request decodesTo"},{"name":"queryRequestWithHttpGet","comment":" Exactly like `queryRequest`, but with an option to use the HTTP GET request\nmethod. You will probably want to use `GetIfShortEnough`, which uses GET if the\nfull URL ends up being under 2000 characters, or POST otherwise, since [some browsers\ndon't support URLs over a certain length](https://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string?noredirect=1&lq=1).\n`GetIfShortEnough` will typically do what you need. If you must use GET no matter\nwhat when hitting your endpoint, you can use `AlwaysGet`.\n\n`queryRequest` always uses POST since some GraphQL API's don't support GET\nrequests (for example, the Github API assumes that you are doing an introspection\nquery if you make a GET request). But for semantic reasons, GET requests\nare sometimes useful for sending GraphQL Query requests. That is, a GraphQL Query\ndoes not perform side-effects on the server like a Mutation does, so a GET\nindicates this and allows some servers to cache requests. See\n[this github thread from the Apollo project](https://github.com/apollographql/apollo-client/issues/813)\nfor more details.\n\n","type":"String.String -> Graphql.Http.QueryRequestMethod -> Graphql.SelectionSet.SelectionSet decodesTo Graphql.Operation.RootQuery -> Graphql.Http.Request decodesTo"},{"name":"send","comment":" Send the `Graphql.Request`\nYou can use it on its own, or with a library like\n[RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/latest/).\n\n    import Graphql.Http\n    import Graphql.OptionalArgument exposing (OptionalArgument(..))\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse RemoteData (Graphql.Http.Error Response) Response\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://elm-graphql.herokuapp.com/\"\n            |> Graphql.Http.withHeader \"authorization\" \"Bearer abcdefgh12345678\"\n            -- If you're not using remote data, it's just\n            -- |> Graphql.Http.send GotResponse\n            -- With remote data, it's as below\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\nIf any errors are present, you will get a `GraphqlError` that includes the details.\nGraphQL allows for partial data to be returned in the case of errors so you can\ninspect the data returned in the `GraphqlError` if you would like to try to recover\nany data that made it through in the response.\n\n","type":"(Result.Result (Graphql.Http.Error decodesTo) decodesTo -> msg) -> Graphql.Http.Request decodesTo -> Platform.Cmd.Cmd msg"},{"name":"sendWithTracker","comment":" Exactly like `Graphql.Http.request` except it allows you to use the `String`\npassed in as the tracker to [`track`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#track)\nand [`cancel`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#cancel)\nrequests using the core Elm `Http` package (see\n[the `Http.request` docs](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#request))\n","type":"String.String -> (Result.Result (Graphql.Http.Error decodesTo) decodesTo -> msg) -> Graphql.Http.Request decodesTo -> Platform.Cmd.Cmd msg"},{"name":"toTask","comment":" Convert a Request to a Task. See `Graphql.Http.send` for an example of\nhow to build up a Request.\n","type":"Graphql.Http.Request decodesTo -> Task.Task (Graphql.Http.Error decodesTo) decodesTo"},{"name":"withCredentials","comment":" Set with credentials to true. See [the `XMLHttpRequest/withCredentials` docs](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials)\nto understand exactly what happens.\n\nUnder the hood, this will use either [`Http.riskyRequest`](https://package.elm-lang.org/packages/elm/http/latest/Http#riskyRequest)\nor [`Http.riskyTask`](https://package.elm-lang.org/packages/elm/http/latest/Http#riskyTask).\n\n","type":"Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withHeader","comment":" Add a header.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphql.Http.withHeader \"authorization\" \"Bearer <my token>\"\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\n","type":"String.String -> String.String -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withQueryParams","comment":" Add query params. The values will be Uri encoded.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphql.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphql.Http.withQueryParams [ ( \"version\", \"1.2.3\" ) ]\n            |> Graphql.Http.send (RemoteData.fromResult >> GotResponse)\n\n","type":"List.List ( String.String, String.String ) -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"},{"name":"withTimeout","comment":" Add a timeout.\n","type":"Basics.Float -> Graphql.Http.Request decodesTo -> Graphql.Http.Request decodesTo"}],"binops":[]},{"name":"Graphql.Http.GraphqlError","comment":"\n\n@docs GraphqlError, decoder, Location, PossiblyParsedData\n\n","unions":[{"name":"PossiblyParsedData","comment":" Represents the `data` field in cases where there is an error present, see\n[the error section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Data).\nIf the decoder succeeds you will end up with `ParsedData`. If it fails, you\nwill get an `UnparsedData` with a `Json.Decode.Value` containing the raw, undecoded\n`data` field. You're likely to end up with `UnparsedData` since\n[GraphQL will return `null` if there is an error on a non-nullable field](http://facebook.github.io/graphql/October2016/#sec-Errors-and-Non-Nullability)\n, which will cause the decode pipeline to fail and give you `UnparsedData`.\n","args":["parsed"],"cases":[["ParsedData",["parsed"]],["UnparsedData",["Json.Decode.Value"]]]}],"aliases":[{"name":"GraphqlError","comment":" Represents an error from the GraphQL endpoint. Also see `Graphql.Http`.\n\nThe code generated by `dillonkearns/elm-graphql`\nguarantees that your requests are valid according to the server's schema, so\nthe two cases where you will get a GraphqlError are 1) when there is an implicit\nconstraint that the schema doesn't specify, or 2) when your generated code is\nout of date with the schema.\n\nSee the\n[Errors section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Errors).\nfor more details about GraphQL errors.\n\n","args":[],"type":"{ message : String.String, locations : Maybe.Maybe (List.List Graphql.Http.GraphqlError.Location), details : Dict.Dict String.String Json.Decode.Value }"},{"name":"Location","comment":" The location in the GraphQL query document where the error occured\n","args":[],"type":"{ line : Basics.Int, column : Basics.Int }"}],"values":[{"name":"decoder","comment":" For internal use only.\n","type":"Json.Decode.Decoder (List.List Graphql.Http.GraphqlError.GraphqlError)"}],"binops":[]},{"name":"Graphql.Internal.Builder.Argument","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `@dillonkearns/elm-graphql` CLI.\n\n@docs Argument, optional, required\n\n","unions":[{"name":"Argument","comment":" Argument type.\n","args":[],"cases":[["Argument",["String.String","Graphql.Internal.Encode.Value"]]]}],"aliases":[],"values":[{"name":"optional","comment":" Used for passing optional arguments in generated code.\n","type":"String.String -> Graphql.OptionalArgument.OptionalArgument a -> (a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe Graphql.Internal.Builder.Argument.Argument"},{"name":"required","comment":" Used for passing required arguments in generated code.\n","type":"String.String -> a -> (a -> Graphql.Internal.Encode.Value) -> Graphql.Internal.Builder.Argument.Argument"}],"binops":[]},{"name":"Graphql.Internal.Builder.Object","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `@dillonkearns/elm-graphql` CLI.\n\n@docs fieldDecoder, selection, selectionField, interfaceSelection, unionSelection, scalarDecoder\n\n","unions":[],"aliases":[],"values":[{"name":"fieldDecoder","comment":" Refer to a field in auto-generated code.\n","type":"String.String -> List.List Graphql.Internal.Builder.Argument.Argument -> Json.Decode.Decoder decodesTo -> Graphql.Field.Field decodesTo lockedTo"},{"name":"interfaceSelection","comment":" Used to create the `selection` functions in auto-generated code for interfaces.\n","type":"List.List (Graphql.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a -> b) -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock"},{"name":"scalarDecoder","comment":" Decoder for scalars for use in auto-generated code.\n","type":"Json.Decode.Decoder String.String"},{"name":"selection","comment":" Used to create the `selection` functions in auto-generated code.\n","type":"(a -> constructor) -> Graphql.SelectionSet.SelectionSet (a -> constructor) typeLock"},{"name":"selectionField","comment":" Refer to an object in auto-generated code.\n","type":"String.String -> List.List Graphql.Internal.Builder.Argument.Argument -> Graphql.SelectionSet.SelectionSet a objectTypeLock -> (Json.Decode.Decoder a -> Json.Decode.Decoder b) -> Graphql.Field.Field b lockedTo"},{"name":"unionSelection","comment":" Used to create the `selection` functions in auto-generated code for unions.\n","type":"List.List (Graphql.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a) -> Graphql.SelectionSet.SelectionSet a typeLock"}],"binops":[]},{"name":"Graphql.Internal.Encode","comment":" **WARNING** `Graphql.Interal` modules are used by the `@dillonkearns/elm-graphql` command line\ncode generator tool. They should not be consumed through hand-written code.\n\n`Graphql.Internal.Encode.Value`s are low-level details used by generated code.\nThey are only used by the code generated by the `@dillonkearns/elm-graphql` CLI tool.\n\n@docs null, bool, enum, int, list, string, object, maybe, maybeObject, optional, float\n@docs serialize\n@docs Value\n\n","unions":[{"name":"Value","comment":" Represents an encoded Value\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"bool","comment":" Encode a bool\n","type":"Basics.Bool -> Graphql.Internal.Encode.Value"},{"name":"enum","comment":" Encode an enum. The first argument is the toString function for that enum.\n","type":"(a -> String.String) -> a -> Graphql.Internal.Encode.Value"},{"name":"float","comment":" Encode a float\n","type":"Basics.Float -> Graphql.Internal.Encode.Value"},{"name":"int","comment":" Encode an int\n","type":"Basics.Int -> Graphql.Internal.Encode.Value"},{"name":"list","comment":" Encode a list of Values\n","type":"(a -> Graphql.Internal.Encode.Value) -> List.List a -> Graphql.Internal.Encode.Value"},{"name":"maybe","comment":" Encode a Maybe. Uses encoder for `Just`, or `Encode.null` for `Nothing`.\n","type":"(a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe a -> Graphql.Internal.Encode.Value"},{"name":"maybeObject","comment":" Encode a list of key-value pairs into an object\n","type":"List.List ( String.String, Maybe.Maybe Graphql.Internal.Encode.Value ) -> Graphql.Internal.Encode.Value"},{"name":"null","comment":" Encode null\n","type":"Graphql.Internal.Encode.Value"},{"name":"object","comment":" Encode a list of key-value pairs into an object\n","type":"List.List ( String.String, Graphql.Internal.Encode.Value ) -> Graphql.Internal.Encode.Value"},{"name":"optional","comment":" Encode a list of key-value pairs into an object\n","type":"Graphql.OptionalArgument.OptionalArgument a -> (a -> Graphql.Internal.Encode.Value) -> Maybe.Maybe Graphql.Internal.Encode.Value"},{"name":"serialize","comment":" Low-level function for serializing a `Graphql.Internal.Encode.Value`s.\n","type":"Graphql.Internal.Encode.Value -> String.String"},{"name":"string","comment":" Encode a string\n","type":"String.String -> Graphql.Internal.Encode.Value"}],"binops":[]},{"name":"Graphql.Operation","comment":" This module contains types used to annotate top-level queries which can be\nbuilt up using functions in code generated by the `@dillonkearns/elm-graphql` command line tool\nand sent using functions in the `Graphql.Http` module.\n\n@docs RootMutation, RootQuery, RootSubscription\n\n","unions":[{"name":"RootMutation","comment":" Type for top-level mutations which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]},{"name":"RootQuery","comment":" Type for top-level queries which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]},{"name":"RootSubscription","comment":" Type for top-level mutations which can be sent using functions\nfrom `Graphql.Http`.\n","args":[],"cases":[]}],"aliases":[],"values":[],"binops":[]},{"name":"Graphql.OptionalArgument","comment":"\n\n@docs OptionalArgument\n@docs fromMaybe\n@docs map\n\n","unions":[{"name":"OptionalArgument","comment":" This type is used to create values to pass in optional arguments.\n\n      import Api.Enum.Episode as Episode exposing (Episode)\n      import Api.Query as Query\n      import Graphql.Operation exposing (RootQuery)\n      import Graphql.OptionalArgument exposing (OptionalArgument(Null, Present))\n      import Graphql.SelectionSet exposing (SelectionSet, with)\n\n\n      query : SelectionSet Response RootQuery\n      query =\n          Query.selection Response\n              |> with (Query.human { id = \"1004\" } human)\n              |> with (Query.human { id = \"1001\" } human)\n              |> with\n                  (Query.hero\n                      (\\optionals ->\n                          { optionals\n                              | episode = Present Episode.EMPIRE\n                          }\n                      )\n                      hero\n                  )\n\nAn optional argument can be either present, absent, or null, so using a Maybe does not\nfully capture the GraphQL concept of an optional argument. For example, you could have\na mutation that deletes an entry if a null argument is provided, or does nothing if\nthe argument is absent. See\n[The official GraphQL spec section on null](http://facebook.github.io/graphql/October2016/#sec-Null-Value)\nfor details.\n\n","args":["a"],"cases":[["Present",["a"]],["Absent",[]],["Null",[]]]}],"aliases":[],"values":[{"name":"fromMaybe","comment":" Convert a `Maybe` to an OptionalArgument.\n","type":"Maybe.Maybe a -> Graphql.OptionalArgument.OptionalArgument a"},{"name":"map","comment":" Transform an OptionalArgument value with a given function.\n","type":"(a -> b) -> Graphql.OptionalArgument.OptionalArgument a -> Graphql.OptionalArgument.OptionalArgument b"}],"binops":[]},{"name":"Graphql.SelectionSet","comment":" The auto-generated code from the `@dillonkearns/elm-graphql` CLI will provide `selection`\nfunctions for Objects, Interfaces, and Unions in your GraphQL schema.\nThese functions build up a `Graphql.SelectionSet` which describes a set\nof fields to retrieve. The `SelectionSet` is built up in a pipeline similar to how\n[`Json.Decode.Pipeline`](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest)\nbuilds up decoders.\n\nFor example, if you had a top-level query `human(id: ID!)` which returns an object\nof type `Human`, you could build the following GraphQL query document:\n\n    query {\n      human(id: 1001) {\n        name\n        id\n      }\n    }\n\nIn this example, the `SelectionSet` on `human` is:\n\n    {\n      name\n      id\n    }\n\nYou could build up the above `SelectionSet` with the following `dillonkearns/elm-graphql` code:\n\n    import Api.Object\n    import Api.Object.Human as Human\n    import Graphql.SelectionSet exposing (SelectionSet, with)\n\n    type alias Human =\n        { name : String\n        , id : String\n        }\n\n    hero : SelectionSet Hero Api.Interface.Human\n    hero =\n        Human.selection Human\n            |> with Human.name\n            |> with Human.id\n\nNote that all of the modules under `Api.` in this case are generated by running\nthe `@dillonkearns/elm-graphql` command line tool.\n\nThe query itself is also a `SelectionSet` so it is built up similarly.\nSee [this live code demo](https://rebrand.ly/graphqelm) for an example.\n\n@docs with, hardcoded, empty, map, succeed, fieldSelection\n\n\n## Combining\n\n@docs map2, withFragment\n\n\n## Types\n\nThese types are built for you by the code generated by the `@dillonkearns/elm-graphql` command line tool.\n\n@docs SelectionSet, FragmentSelectionSet\n\n","unions":[{"name":"FragmentSelectionSet","comment":" FragmentSelectionSet type\n","args":["decodesTo","typeLock"],"cases":[["FragmentSelectionSet",["String.String","List.List Graphql.RawField.RawField","Json.Decode.Decoder decodesTo"]]]},{"name":"SelectionSet","comment":" SelectionSet type\n","args":["decodesTo","typeLock"],"cases":[["SelectionSet",["List.List Graphql.RawField.RawField","Json.Decode.Decoder decodesTo"]]]}],"aliases":[],"values":[{"name":"empty","comment":" Useful for Mutations when you don't want any data back.\n\n    import Api.Mutation as Mutation\n    import Graphql.Operation exposing (RootMutation)\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, with)\n\n    sendChatMessage : String -> SelectionSet () RootMutation\n    sendChatMessage message =\n        Mutation.selection identity\n            |> with (Mutation.sendMessage { message = message } SelectionSet.empty)\n\n","type":"Graphql.SelectionSet.SelectionSet () typeLock"},{"name":"fieldSelection","comment":" Create a `SelectionSet` from a single `Field`.\n\n    import Api.Object\n    import Api.Object.Human as Human\n    import Graphql.SelectionSet exposing (SelectionSet)\n\n    humanSelection : SelectionSet String Api.Object.Human\n    humanSelection =\n        SelectionSet.fieldSelection Human.name\n\n","type":"Graphql.Field.Field response typeLock -> Graphql.SelectionSet.SelectionSet response typeLock"},{"name":"hardcoded","comment":" Include a hardcoded value.\n\n        import Api.Enum.Episode as Episode exposing (Episode)\n        import Api.Object\n        import Graphql.SelectionSet exposing (SelectionSet, with, hardcoded)\n\n        type alias Hero =\n            { name : String\n            , movie : String\n            }\n\n        hero : SelectionSet Hero Api.Interface.Character\n        hero =\n            Character.commonSelection Hero\n                |> with Character.name\n                |> hardcoded \"Star Wars\"\n\n","type":"a -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"map","comment":" Apply a function to change the result of decoding the `SelectionSet`.\n","type":"(a -> b) -> Graphql.SelectionSet.SelectionSet a typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"map2","comment":" Combine two `SelectionSet`s into one, using the given combine function to\nmerge the two data sets together.\n","type":"(decodesTo1 -> decodesTo2 -> decodesToCombined) -> Graphql.SelectionSet.SelectionSet decodesTo1 typeLock -> Graphql.SelectionSet.SelectionSet decodesTo2 typeLock -> Graphql.SelectionSet.SelectionSet decodesToCombined typeLock"},{"name":"succeed","comment":" Instead of hardcoding a field like `hardcoded`, `SelectionSet.succeed` hardcodes\nan entire `SelectionSet`. This can be useful if you want hardcoded data based on\nonly the type when using a polymorphic type (Interface or Union).\n\n    type alias Character =\n        { details : Maybe HumanOrDroid\n        , name : String\n        }\n\n    type HumanOrDroid\n        = Human\n        | Droid\n\n    hero : SelectionSet Character Swapi.Interface.Character\n    hero =\n        Character.selection Character\n            [ Character.onDroid (SelectionSet.succeed Droid)\n            , Character.onHuman (SelectionSet.succeed Human)\n            ]\n            |> with Character.name\n\n","type":"a -> Graphql.SelectionSet.SelectionSet a typeLock"},{"name":"with","comment":" Used to pick out fields on an object.\n\n    import Api.Enum.Episode as Episode exposing (Episode)\n    import Api.Object\n    import Api.Scalar\n    import Graphql.SelectionSet exposing (SelectionSet, with)\n\n    type alias Hero =\n        { name : String\n        , id : Api.Scalar.Id\n        , appearsIn : List Episode\n        }\n\n    hero : SelectionSet Hero Api.Interface.Character\n    hero =\n        Character.commonSelection Hero\n            |> with Character.name\n            |> with Character.id\n            |> with Character.appearsIn\n\n","type":"Graphql.Field.Field a typeLock -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"},{"name":"withFragment","comment":" Include a `SelectionSet` within a `SelectionSet`. This is the equivalent of\nincluding a [GraphQL fragment](https://graphql.org/learn/queries/#fragments) in\nplain GraphQL queries. This is a handy tool for modularizing your GraphQL queries.\n\n([You can try the below query for yourself by pasting the query into the Github query explorer](https://developer.github.com/v4/explorer/)).\n\nLet's say we want to query Github's GraphQL API like this:\n\n    {\n      repository(owner: \"dillonkearns\", name: \"elm-graphql\") {\n        nameWithOwner\n        ...timestamps\n        stargazers(first: 0) { totalCount }\n      }\n    }\n\n    fragment timestamps on Repository {\n      createdAt\n      updatedAt\n    }\n\nWe could do the equivalent of the `timestamps` fragment with the `timestampsFragment`\nwe define below.\n\n    import Github.Object\n    import Github.Object.Repository as Repository\n    import Github.Object.StargazerConnection\n    import Graphql.Field as Field exposing (Field)\n    import Graphql.Operation exposing (RootQuery)\n    import Graphql.OptionalArgument exposing (OptionalArgument(..))\n    import Graphql.SelectionSet as SelectionSet exposing (SelectionSet, fieldSelection, with, withFragment)\n    import Iso8601\n    import Time exposing (Posix)\n\n    type alias Repo =\n        { nameWithOwner : String\n        , timestamps : Timestamps\n        , stargazersCount : Int\n        }\n\n    type alias Timestamps =\n        { createdAt : Posix\n        , updatedAt : Posix\n        }\n\n    repositorySelection : SelectionSet Repo Github.Object.Repository\n    repositorySelection =\n        Repository.selection Repo\n            |> with Repository.nameWithOwner\n            |> withFragment timestampsFragment\n            |> with stargazersCount\n\n    timestampsFragment : SelectionSet Timestamps Github.Object.Repository\n    timestampsFragment =\n        Repository.selection Timestamps\n            |> with (Repository.createdAt |> mapToDateTime)\n            |> with (Repository.updatedAt |> mapToDateTime)\n\n    mapToDateTime : Field Github.Scalar.DateTime typeLock -> Field Posix typeLock\n    mapToDateTime =\n        Field.mapOrFail\n            (\\(Github.Scalar.DateTime value) ->\n                Iso8601.toTime value\n                    |> Result.mapError (\\_ -> \"Failed to parse \" ++ value ++ \" as Iso8601 DateTime.\")\n            )\n\n    stargazersCount : Field Int Github.Object.Repository\n    stargazersCount =\n        Repository.stargazers\n            (\\optionals -> { optionals | first = Present 0 })\n            (fieldSelection Github.Object.StargazerConnection.totalCount)\n\nNotice that we are using two different techniques for abstraction here.\nWe use `|> withFragment timestampsFragment` to include a fragment and we use\n`|> with stargazersCount`. What's the difference? For the `timestampsFragment`,\nwe want to pull in some fields at the same level of the `SelectionSet` we are\nbuilding up. But for the `stargazersCount`, we are simply extracting a `Field`\nwhich builds up a nested `SelectionSet` that grabs the `totalCount` within the\n`stargazers` `Field`.\n\n","type":"Graphql.SelectionSet.SelectionSet a typeLock -> Graphql.SelectionSet.SelectionSet (a -> b) typeLock -> Graphql.SelectionSet.SelectionSet b typeLock"}],"binops":[]}]