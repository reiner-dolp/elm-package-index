[
  {
    "name": "Graphqelm.Http",
    "comment": " Send requests to your GraphQL endpoint. See [this live code demo](https://rebrand.ly/graphqelm)\nor the [`examples/`](https://github.com/dillonkearns/graphqelm/tree/master/examples)\nfolder for some end-to-end examples.\nThe builder syntax is inspired by Luke Westby's\n[elm-http-builder package](http://package.elm-lang.org/packages/lukewestby/elm-http-builder/latest).\n\n\n## Data Types\n\n@docs Request, Error\n\n\n## Begin `Request` Pipeline\n\n@docs queryRequest, mutationRequest, queryRequestForceMethod\n@docs ForceRequestMethod\n\n\n## Configure `Request` Options\n\n@docs withHeader, withTimeout, withCredentials, withQueryParams\n\n\n## Perform `Request`\n\n@docs send, toTask\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Error",
        "comment": " Represents the two types of errors you can get, an Http error or a GraphQL error.\nSee the `Graphqelm.Http.GraphqlError` module docs for more details.\n",
        "args": [],
        "cases": [
          [
            "GraphqlError",
            [
              "List Graphqelm.Http.GraphqlError.GraphqlError"
            ]
          ],
          [
            "HttpError",
            [
              "Http.Error"
            ]
          ]
        ]
      },
      {
        "name": "ForceRequestMethod",
        "comment": " Union type to pass in to `queryRequestForceMethod`. Only applies to queries.\nMutations don't accept this configuration option and will always use POST.\n",
        "args": [],
        "cases": [
          [
            "AlwaysGet",
            []
          ],
          [
            "AlwaysPost",
            []
          ]
        ]
      },
      {
        "name": "Request",
        "comment": " An internal request as it's built up. Once it's built up, send the\nrequest with `Graphqelm.Http.send`.\n",
        "args": [
          "decodesTo"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "mutationRequest",
        "comment": " Initialize a basic request from a Mutation. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphqelm.Http.send`.\n",
        "type": "String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootMutation -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "queryRequest",
        "comment": " Initialize a basic request from a Query. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphqelm.Http.send`.\n",
        "type": "String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "queryRequestForceMethod",
        "comment": " Exactly like `queryRequest`, but with an option to either force a request method\nof `AlwaysGet` or `AlwaysPost`. `queryRequest` will use GET for semantic reasons\n(unless it results in a URL of over 2000 characters). That is, a GraphQL Query\ndoes not perform side-effects on the server like a Mutation does, so a GET\nindicates this and allows some servers to cache requests. Use this function\nif for some reason you want to make sure that either GET or POST is always used\n(99% of the time, `queryRequest` will do exactly what you need). See\n[this github thread from the Apollo project](https://github.com/apollographql/apollo-client/issues/813)\nfor more details.\n",
        "type": "String -> Graphqelm.Http.ForceRequestMethod -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "send",
        "comment": " Send the `Graphqelm.Request`\nYou can use it on its own, or with a library like\n[RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/latest/).\n\n    import Graphqelm.Http\n    import Graphqelm.OptionalArgument exposing (OptionalArgument(Null, Present))\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse RemoteData Graphqelm.Http.Error Response\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://graphqelm.herokuapp.com/\"\n            |> Graphqelm.Http.withHeader \"authorization\" \"Bearer abcdefgh12345678\"\n            -- If you're not using remote data, it's just\n            -- |> Graphqelm.Http.send GotResponse\n            -- With remote data, it's as below\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\n",
        "type": "(Result.Result Graphqelm.Http.Error a -> msg) -> Graphqelm.Http.Request a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "toTask",
        "comment": " Convert a Request to a Task. See `Graphqelm.Http.send` for an example of\nhow to build up a Request.\n",
        "type": "Graphqelm.Http.Request decodesTo -> Task.Task Graphqelm.Http.Error decodesTo"
      },
      {
        "name": "withCredentials",
        "comment": " Set with credentials to true.\n",
        "type": "Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withHeader",
        "comment": " Add a header.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphqelm.Http.withHeader \"authorization\" \"Bearer <my token>\"\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\n",
        "type": "String -> String -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withQueryParams",
        "comment": " Add query params. The values will be Uri encoded.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphqelm.Http.withQueryParams [ ( \"version\", \"1.2.3\" ) ]\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\n",
        "type": "List ( String, String ) -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withTimeout",
        "comment": " Add a timeout.\n",
        "type": "Time.Time -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Subscription",
    "comment": " _Warning_ The Subscriptions functionality in this package is in a highly experimental stage\nand may change rapidly or have issues that make it not ready for production code yet.\n\n@docs Model, Msg, Status, init, onStatusChanged, sendMutation, listen, update\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Model",
        "comment": " Model\n",
        "args": [
          "msg",
          "decodesTo"
        ],
        "cases": []
      },
      {
        "name": "Msg",
        "comment": " An opaque type that needs to be passed through to the `Subscription.update` function\nin your program's `update`.\n\n    type Msg\n        = GraphqlSubscriptionMsg (Graphqelm.Subscription.Msg ChatMessage)\n        | SubscriptionDataReceived ChatMessage\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            GraphqlSubscriptionMsg graphqlSubscriptionMsg ->\n                Graphqelm.Subscription.update graphqlSubscriptionMsg model\n\n            SubscriptionDataReceived newData ->\n                ( { model | data = newData :: model.data }, Cmd.none )\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        Graphqelm.Subscription.subscription model.graphqlSubscriptionModel GraphqlSubscriptionMsg socketUrl document\n\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "Status",
        "comment": " The Subscription connection status. Use `onStatusChanged` to register a Msg to listen for this.\n",
        "args": [],
        "cases": [
          [
            "Uninitialized",
            []
          ],
          [
            "Connected",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "init",
        "comment": " Initialize a Subscription. You will need a `Graphqelm.Subscription.Protocol`\ndata structure (the `Protocol` module contains `Protocol`s for some\nGraphQL server implementations).\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol decodesTo -> String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootSubscription -> (decodesTo -> msg) -> ( Graphqelm.Subscription.Model msg decodesTo , Platform.Cmd.Cmd msg )"
      },
      {
        "name": "listen",
        "comment": " Add this to your subscriptions.\n",
        "type": "(Graphqelm.Subscription.Msg decodesTo -> msg) -> { model | graphqlSubscriptionModel : Graphqelm.Subscription.Model msg decodesTo } -> Platform.Sub.Sub msg"
      },
      {
        "name": "onStatusChanged",
        "comment": " Register a Msg to receive when a connection is established.\n\n    init : ( Model, Cmd Msg )\n    init =\n        let\n            ( graphqlSubscriptionModel, graphqlSubscriptionCmd ) =\n                Graphqelm.Subscription.init protocol socketUrl subscriptionDocument SubscriptionDataReceived\n        in\n        ( { data = []\n          , subscriptionStatus = Graphqelm.Subscription.Uninitialized\n          , graphqlSubscriptionModel =\n                graphqlSubscriptionModel\n                    |> Graphqelm.Subscription.onStatusChanged SubscriptionStatusChanged\n          }\n        , graphqlSubscriptionCmd\n        )\n\n",
        "type": "(Graphqelm.Subscription.Status -> msg) -> Graphqelm.Subscription.Model msg decodesTo -> Graphqelm.Subscription.Model msg decodesTo"
      },
      {
        "name": "sendMutation",
        "comment": " Performs the mutation over the websocket. If the connection is uninitialized,\nit will be dropped.\nTODO: should it always be queued? Or should it optionally be queued?\n",
        "type": "Graphqelm.Subscription.Model msg decodesTo -> Graphqelm.SelectionSet.SelectionSet mutationDecodesTo Graphqelm.Operation.RootMutation -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "update",
        "comment": " Needs to be called from your program's `update` function in order to listen\nfor and respond to Subscription communications.\n",
        "type": "Graphqelm.Subscription.Msg decodesTo -> { model | graphqlSubscriptionModel : Graphqelm.Subscription.Model msg decodesTo } -> ( { model | graphqlSubscriptionModel : Graphqelm.Subscription.Model msg decodesTo } , Platform.Cmd.Cmd msg )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Builder.Object",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `graphqelm` CLI.\n@docs fieldDecoder, selection, selectionField, interfaceSelection, unionSelection\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "fieldDecoder",
        "comment": " Refer to a field in auto-generated code.\n",
        "type": "String -> List Graphqelm.Internal.Builder.Argument.Argument -> Json.Decode.Decoder decodesTo -> Graphqelm.Field.Field decodesTo lockedTo"
      },
      {
        "name": "interfaceSelection",
        "comment": " Used to create the `selection` functions in auto-generated code for interfaces.\n",
        "type": "List (Graphqelm.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a -> b) -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock"
      },
      {
        "name": "selection",
        "comment": " Used to create the `selection` functions in auto-generated code.\n",
        "type": "(a -> constructor) -> Graphqelm.SelectionSet.SelectionSet (a -> constructor) typeLock"
      },
      {
        "name": "selectionField",
        "comment": " Refer to an object in auto-generated code.\n",
        "type": "String -> List Graphqelm.Internal.Builder.Argument.Argument -> Graphqelm.SelectionSet.SelectionSet a objectTypeLock -> (Json.Decode.Decoder a -> Json.Decode.Decoder b) -> Graphqelm.Field.Field b lockedTo"
      },
      {
        "name": "unionSelection",
        "comment": " Used to create the `selection` functions in auto-generated code for unions.\n",
        "type": "List (Graphqelm.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a) -> Graphqelm.SelectionSet.SelectionSet a typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Document",
    "comment": " You'll usually want to use `Graphqelm.Http` to perform your queries directly.\nThis package provides low-level functions for generating GraphQL documents that\nare helpful for debugging and demo purposes.\n\n@docs serializeQuery, serializeMutation, serializeSubscription, serializeQueryForUrl\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "serializeMutation",
        "comment": " Serialize a mutation selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootMutation -> String"
      },
      {
        "name": "serializeQuery",
        "comment": " Serialize a query selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> String"
      },
      {
        "name": "serializeQueryForUrl",
        "comment": " Serialize a query selection set into a string with minimal whitespace. For\nuse with a GET request as a query param.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> String"
      },
      {
        "name": "serializeSubscription",
        "comment": " Serialize a subscription selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootSubscription -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.SelectionSet",
    "comment": " The auto-generated code from the `graphqelm` CLI will provide `selection`\nfunctions for Objects, Interfaces, and Unions in your GraphQL schema.\nThese functions build up a `Graphqelm.SelectionSet` which describes a set\nof fields to retrieve. The `SelectionSet` is built up in a pipeline similar to how\n[`Json.Decode.Pipeline`](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest)\nbuilds up decoders.\n\nFor example, if you had a top-level query `human(id: ID!)` which returns an object\nof type `Human`, you could build the following GraphQL query document:\n\n    query {\n      human(id: 1001) {\n        name\n        id\n      }\n    }\n\nIn this example, the `SelectionSet` on `human` is:\n\n    {\n      name\n      id\n    }\n\nYou could build up the above `SelectionSet` with the following `Graphqelm` code:\n\n    import Api.Object\n    import Api.Object.Human as Human\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    type alias Human =\n        { name : String\n        , id : String\n        }\n\n    hero : SelectionSet Hero Api.Interface.Human\n    hero =\n        Human.selection Human\n            |> with Human.name\n            |> with Human.id\n\nNote that all of the modules under `Api.` in this case are generated by running\nthe `graphqelm` command line tool.\n\nThe query itself is also a `SelectionSet` so it is built up similarly.\nSee [this live code demo](https://rebrand.ly/graphqelm) for an example.\n\n@docs with, hardcoded, empty\n\n\n## Types\n\nThese types are built for you by the code generated by the `graphqelm` command line tool.\n\n@docs SelectionSet, FragmentSelectionSet\n\n",
    "aliases": [],
    "types": [
      {
        "name": "FragmentSelectionSet",
        "comment": " FragmentSelectionSet type\n",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "FragmentSelectionSet",
            [
              "String",
              "List Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      },
      {
        "name": "SelectionSet",
        "comment": " SelectionSet type\n",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "SelectionSet",
            [
              "List Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "empty",
        "comment": " Useful for Mutations when you don't want any data back.\n\n    import Api.Mutation as Mutation\n    import Graphqelm.Operation exposing (RootMutation)\n    import Graphqelm.SelectionSet as SelectionSet exposing (SelectionSet, with)\n\n    sendChatMessage : String -> SelectionSet () RootMutation\n    sendChatMessage message =\n        Mutation.selection identity\n            |> with (Mutation.sendMessage { message = message } SelectionSet.empty)\n\n",
        "type": "Graphqelm.SelectionSet.SelectionSet () typeLock"
      },
      {
        "name": "hardcoded",
        "comment": " Include a hardcoded value.\n\n        import Api.Enum.Episode as Episode exposing (Episode)\n        import Api.Object\n        import Graphqelm.SelectionSet exposing (SelectionSet, with, hardcoded)\n\n        type alias Hero =\n            { name : String\n            , movie : String\n            }\n\n        hero : SelectionSet Hero Api.Interface.Character\n        hero =\n            Character.commonSelection Hero\n                |> with Character.name\n                |> hardcoded \"Star Wars\"\n\n",
        "type": "a -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock -> Graphqelm.SelectionSet.SelectionSet b typeLock"
      },
      {
        "name": "with",
        "comment": " Used to pick out fields on an object.\n\n    import Api.Enum.Episode as Episode exposing (Episode)\n    import Api.Object\n    import Api.Scalar\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    type alias Hero =\n        { name : String\n        , id : Api.Scalar.Id\n        , appearsIn : List Episode\n        }\n\n    hero : SelectionSet Hero Api.Interface.Character\n    hero =\n        Character.commonSelection Hero\n            |> with Character.name\n            |> with Character.id\n            |> with Character.appearsIn\n\n",
        "type": "Graphqelm.Field.Field a typeLock -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock -> Graphqelm.SelectionSet.SelectionSet b typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Field",
    "comment": " `Field`s are automatically generated by the `graphqelm` CLI command.\nYou can use `Graphqelm.Field.map` to transform a value.\n@docs map, Field\n",
    "aliases": [],
    "types": [
      {
        "name": "Field",
        "comment": " ",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "Field",
            [
              "Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "map",
        "comment": " Maps the data coming back from the GraphQL endpoint. In this example,\n`User.name` is a function that the `graphqelm` CLI tool created which tells us\nthat the `name` field on a `User` object is a String according to your GraphQL\nschema.\n\n    import Api.Object\n    import Api.Object.User as User\n    import Graphqelm.Field as Field\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    human : SelectionSet String Api.Object.User\n    human =\n        User.selection identity\n            |> with\n                (User.name\n                    |> Field.map String.toUpper\n                )\n\nYou can also map to values of a different type (`String -> Int`, for example), see\n[`examples/StarWars.elm`](https://github.com/dillonkearns/graphqelm/blob/master/examples/src/Starwars.elm)\nfor more advanced example.\n\n",
        "type": "(decodesTo -> mapsTo) -> Graphqelm.Field.Field decodesTo typeLock -> Graphqelm.Field.Field mapsTo typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Builder.Argument",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `graphqelm` CLI.\n@docs Argument, optional, required\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Argument",
        "comment": " Argument type.\n",
        "args": [],
        "cases": [
          [
            "Argument",
            [
              "String",
              "Graphqelm.Internal.Encode.Value"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "optional",
        "comment": " Used for passing optional arguments in generated code.\n",
        "type": "String -> Graphqelm.OptionalArgument.OptionalArgument a -> (a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe Graphqelm.Internal.Builder.Argument.Argument"
      },
      {
        "name": "required",
        "comment": " Used for passing required arguments in generated code.\n",
        "type": "String -> a -> (a -> Graphqelm.Internal.Encode.Value) -> Graphqelm.Internal.Builder.Argument.Argument"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Encode",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\n`Graphqelm.Internal.Encode.Value`s are low-level details used by generated code.\nThey are only used by the code generated by the `graphqelm` CLI tool.\n\n@docs null, bool, enum, int, list, string, object, maybe, maybeObject, optional, float\n@docs serialize\n@docs Value\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Value",
        "comment": " Represents an encoded Value\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "bool",
        "comment": " Encode a bool\n",
        "type": "Bool -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "enum",
        "comment": " Encode an enum. The first argument is the toString function for that enum.\n",
        "type": "(a -> String) -> a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "float",
        "comment": " Encode a float\n",
        "type": "Float -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "int",
        "comment": " Encode an int\n",
        "type": "Int -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "list",
        "comment": " Encode a list of Values\n",
        "type": "(a -> Graphqelm.Internal.Encode.Value) -> List a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "maybe",
        "comment": " Encode a Maybe. Uses encoder for `Just`, or `Encode.null` for `Nothing`.\n",
        "type": "(a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "maybeObject",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "List ( String, Maybe.Maybe Graphqelm.Internal.Encode.Value ) -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "null",
        "comment": " Encode null\n",
        "type": "Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "object",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "List ( String, Graphqelm.Internal.Encode.Value ) -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "optional",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "Graphqelm.OptionalArgument.OptionalArgument a -> (a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "serialize",
        "comment": " Low-level function for serializing a `Graphqelm.Internal.Encode.Value`s.\n",
        "type": "Graphqelm.Internal.Encode.Value -> String"
      },
      {
        "name": "string",
        "comment": " Encode a string\n",
        "type": "String -> Graphqelm.Internal.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Subscription.Protocol",
    "comment": " You will need a Protocol data structure that fills in the low-level details about\nyour server's GraphQL Subscription protocol. Ideally these will be published here,\nor in an external package by community members so that the protocols for each framework\nis easily accessible, less error-prone, and more stable.\n\n@docs Protocol, phoenixAbsinthe, rails, Response\n\n",
    "aliases": [
      {
        "name": "Protocol",
        "comment": " This encapsulates the Subscriptions protocol for a specific framework, like Phoenix/Absinthe.\nThe low-level details of how to initiate a connection and check that it was successful, etc., can be\nvery different between GraphQL server implementations. Here is an example for the Absinthe framework\nfor Elixir/Phoenix:\n\n        frameworkKnowledge : Graphqelm.Subscription.Protocol subscriptionDecodesTo\n        frameworkKnowledge =\n        { initMessage =\n        Encode.list\n            [ Encode.string \"1\"\n            , Encode.string \"1\"\n            , Encode.string \"__absinthe__:control\"\n            , Encode.string \"phx_join\"\n            , Encode.object []\n            ]\n        , heartBeatMessage =\n        Encode.list\n            [ Encode.null\n            , Encode.string \"1\"\n            , Encode.string \"phoenix\"\n            , Encode.string \"heartbeat\"\n            , Encode.object []\n            ]\n        , documentRequest =\n        \\operation ->\n            Encode.list\n                [ Encode.string \"1\"\n                , Encode.string \"1\"\n                , Encode.string \"__absinthe__:control\"\n                , Encode.string \"doc\"\n                , Encode.object [ ( \"query\", operation |> Encode.string ) ]\n                ]\n        , subscriptionDecoder =\n        \\decoder ->\n            subscriptionResponseDecoder\n                (decoder\n                    |> Decode.field \"result\"\n                    |> Decode.index 4\n                )\n        }\n\n",
        "args": [
          "subscriptionDecodesTo"
        ],
        "type": "{ documentRequest : Int -> String -> Json.Encode.Value , heartBeatMessage : Int -> Json.Encode.Value , initMessage : Int -> Json.Encode.Value , subscriptionDecoder : Json.Decode.Decoder subscriptionDecodesTo -> Json.Decode.Decoder (Graphqelm.Subscription.Protocol.Response subscriptionDecodesTo) }"
      }
    ],
    "types": [
      {
        "name": "Response",
        "comment": " Low-level type used for building Protocol. Represents incoming server messages.\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "SubscriptionDataReceived",
            [
              "a"
            ]
          ],
          [
            "HealthStatus",
            []
          ],
          [
            "Ignored",
            [
              "String"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "phoenixAbsinthe",
        "comment": " `Protocol` for the [Absinthe framework](http://absinthe-graphql.org/)\nwith Elixir/Phoenix.\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol subscriptionDecodesTo"
      },
      {
        "name": "rails",
        "comment": " `Protocol` for [graphql-ruby](https://github.com/rmosolgo/graphql-ruby/).\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol subscriptionDecodesTo"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Http.GraphqlError",
    "comment": "\n\n@docs GraphqlError, decoder, Location\n\n",
    "aliases": [
      {
        "name": "GraphqlError",
        "comment": " Represents an error from the GraphQL endpoint. Also see `Graphqelm.Http`.\n\nThe code generated by Graphqelm\nguarantees that your requests are valid according to the server's schema, so\nthe two cases where you will get a GraphqlError are 1) when there is an implicit\nconstraint that the schema doesn't specify, or 2) when your generated code is\nout of date with the schema.\n\nSee the\n[Errors section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Errors).\nfor more details about GraphQL errors.\n\n",
        "args": [],
        "type": "{ message : String , locations : Maybe.Maybe (List Graphqelm.Http.GraphqlError.Location) , details : Dict.Dict String Json.Decode.Value }"
      },
      {
        "name": "Location",
        "comment": " The location in the GraphQL query document where the error occured\n",
        "args": [],
        "type": "{ line : Int, column : Int }"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "decoder",
        "comment": " For internal use only.\n",
        "type": "Json.Decode.Decoder (List Graphqelm.Http.GraphqlError.GraphqlError)"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.OptionalArgument",
    "comment": "\n\n@docs OptionalArgument\n\n",
    "aliases": [],
    "types": [
      {
        "name": "OptionalArgument",
        "comment": " This type is used to create values to pass in optional arguments.\n\n      import Api.Enum.Episode as Episode exposing (Episode)\n      import Api.Query as Query\n      import Graphqelm.Operation exposing (RootQuery)\n      import Graphqelm.OptionalArgument exposing (OptionalArgument(Null, Present))\n      import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n\n      query : SelectionSet Response RootQuery\n      query =\n          Query.selection Response\n              |> with (Query.human { id = \"1004\" } human)\n              |> with (Query.human { id = \"1001\" } human)\n              |> with\n                  (Query.hero\n                      (\\optionals ->\n                          { optionals\n                              | episode = Present Episode.EMPIRE\n                          }\n                      )\n                      hero\n                  )\n\nAn optional argument can be either present, absent, or null, so using a Maybe does not\nfully capture the GraphQL concept of an optional argument. For example, you could have\na mutation that deletes an entry if a null argument is provided, or does nothing if\nthe argument is absent. See\n[The official GraphQL spec section on null](http://facebook.github.io/graphql/October2016/#sec-Null-Value)\nfor details.\n\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "Present",
            [
              "a"
            ]
          ],
          [
            "Absent",
            []
          ],
          [
            "Null",
            []
          ]
        ]
      }
    ],
    "values": [],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Operation",
    "comment": " This module contains types used to annotate top-level queries which can be\nbuilt up using functions in code generated by the `graphqelm` command line tool\nand sent using functions in the `Graphqelm.Http` module.\n\n@docs RootMutation, RootQuery, RootSubscription\n\n",
    "aliases": [],
    "types": [
      {
        "name": "RootMutation",
        "comment": " Type for top-level mutations which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RootQuery",
        "comment": " Type for top-level queries which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RootSubscription",
        "comment": " Type for top-level mutations which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [],
    "generated-with-elm-version": "0.18.0"
  }
]