[{"name":"Json.Decode.Broken","comment":" Decode broken JSON.\n\n\n# Parsing\n\n@docs parse, Value\n\n\n# Parser building blocks\n\nA parser for a JSON _value_ is:\n\n    Parser.oneOf [ object, array, string, number, true, false, null ]\n\nAccording to the [specification][rfc7159], a JSON document is optional\nwhitespace, a JSON value (that `oneOf …` expression above), then more optional\nwhitespace – and that's what the `json` parser does. Hence parsing a compliant\nJSON document is nothing more than:\n\n    Parser.run json \"…\"\n\nUse these building blocks to compose a parser for broken JSON as you need. If\nyou need to parse non-compliant quoted strings, for example, it might be best to\ncopy just the `string` code from this module into your project, and use the\nother parsers in this module – `object`, `array`, and so on – to compose a new\nparser.\n\n@docs json, object, array, string, number, true, false, null\n\n\n# Numbers\n\n@docs Frac, Exp, Sign\n\n[rfc7159]: https://tools.ietf.org/html/rfc7159\n\n","unions":[{"name":"Exp","comment":" Does the number have an exponent?\n\ni.e. an optional suffix starting with `e` or `E` in the number.\n\n","args":[],"cases":[["Exp",["Json.Decode.Broken.Sign","Basics.Int"]],["NoExp",[]]]},{"name":"Frac","comment":" Does the number have a fractional component?\n\ni.e. the optional part after the decimal point.\n\n","args":[],"cases":[["Frac",["Basics.Int"]],["NoFrac",[]]]},{"name":"Sign","comment":" The sign of the exponent.\n","args":[],"cases":[["Plus",[]],["Minus",[]],["NoSign",[]]]},{"name":"Value","comment":" Custom type for JSON values.\n\nMostly this is self-explanatory, but numbers might be interesting because no\neffort is made to convert them to `Float` values. This means you can deal with\noverflows or precision mismatches in broken JSON.\n\n","args":[],"cases":[["Object",["List.List ( String.String, Json.Decode.Broken.Value )"]],["Array",["List.List Json.Decode.Broken.Value"]],["String",["String.String"]],["Number",["Basics.Int","Json.Decode.Broken.Frac","Json.Decode.Broken.Exp"]],["True",[]],["False",[]],["Null",[]]]}],"aliases":[],"values":[{"name":"array","comment":" Parser for a JSON array.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"false","comment":" Parser for a JSON 'false' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"json","comment":" Parser for JSON.\n\nThis is a JSON value surrounded by optional whitespace.\n\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"null","comment":" Parser for a JSON 'null' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"number","comment":" Parser for a JSON number.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"object","comment":" Parser for a JSON object.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"parse","comment":" Parse the given JSON string.\n\nErrors come straight from [elm/parser] and may not be super useful. It may be\nworth changing this parser to use elm/parser's `Parser.Advanced` which allows\nmore control over errors.\n\n[elm/parser]: https://package.elm-lang.org/packages/elm/parser/latest/\n\n","type":"String.String -> Result.Result (List.List Parser.DeadEnd) Json.Decode.Broken.Value"},{"name":"string","comment":" Parser for a quoted JSON string.\n\n`string` and some of its helpers have been adapted from elm/parser's\n`DoubleQuoteString` example.\n\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"true","comment":" Parser for a JSON 'true' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"}],"binops":[]}]