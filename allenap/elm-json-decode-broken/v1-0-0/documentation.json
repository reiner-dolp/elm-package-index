[{"name":"Json.Decode.Broken","comment":" Decode broken JSON.\n\n\n# Parsing\n\n@docs parse, Value\n\n\n# Numbers\n\n@docs Frac, Exp, Sign\n\n","unions":[{"name":"Exp","comment":" Does the number have an exponent?\n\ni.e. an optional suffix starting with `e` or `E` in the number.\n\n","args":[],"cases":[["Exp",["Json.Decode.Broken.Sign","Basics.Int"]],["NoExp",[]]]},{"name":"Frac","comment":" Does the number have a fractional component?\n\ni.e. the optional part after the decimal point.\n\n","args":[],"cases":[["Frac",["Basics.Int"]],["NoFrac",[]]]},{"name":"Sign","comment":" The sign of the exponent.\n","args":[],"cases":[["Plus",[]],["Minus",[]],["NoSign",[]]]},{"name":"Value","comment":" Custom type for JSON values.\n\nMostly this is self-explanatory, but numbers might be interesting because no\neffort is made to convert them to `Float` values. This means you can deal with\noverflows or precision mismatches in broken JSON.\n\n","args":[],"cases":[["Object",["List.List ( String.String, Json.Decode.Broken.Value )"]],["Array",["List.List Json.Decode.Broken.Value"]],["String",["String.String"]],["Number",["Basics.Int","Json.Decode.Broken.Frac","Json.Decode.Broken.Exp"]],["True",[]],["False",[]],["Null",[]]]}],"aliases":[],"values":[{"name":"parse","comment":" Parse the given JSON string.\n\nErrors come straight from [elm/parser] and may not be super useful. It may be\nworth changing this parser to use elm/parser's `Parser.Advanced` which allows\nmore control over errors.\n\n[elm/parser]: https://package.elm-lang.org/packages/elm/parser/latest/\n\n","type":"String.String -> Result.Result (List.List Parser.DeadEnd) Json.Decode.Broken.Value"}],"binops":[]}]