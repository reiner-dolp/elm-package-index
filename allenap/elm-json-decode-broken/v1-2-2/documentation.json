[{"name":"Json.Decode.Broken","comment":" Decode broken JSON.\n\n\n# Parsing\n\n@docs parse, Value\n\n\n# Parser building blocks\n\nA parser for a JSON _value_ is:\n\n    Parser.oneOf [ object, array, string, number, true, false, null ]\n\nAccording to the [specification][rfc7159], a JSON document is optional\nwhitespace, a JSON value (that `oneOf …` expression above), then more optional\nwhitespace – and that's what the `json` parser does. Hence parsing a compliant\nJSON document is nothing more than:\n\n    Parser.run json \"…\"\n\nUse these building blocks to compose a parser for broken JSON as you need. If\nyou need to parse non-compliant quoted strings, for example, it might be best to\ncopy just the `string` code from this module into your project, and use the\nother parsers in this module – `object`, `array`, and so on – to compose a new\nparser.\n\n[rfc7159]: https://tools.ietf.org/html/rfc7159\n\n@docs json, object, array, string, number, true, false, null, ws\n\n\n# Numbers\n\n@docs Frac, Exp, Sign, toFloat\n\n\n# Further processing\n\n`Value` is a bit unwieldy. Instead of trying to provide a mechanism here for\nfurther processing of `Value`, instead there's a single exit: `encode`. This\nwill return you to the familiar world of [elm/json].\n\n[elm/json]: https://package.elm-lang.org/packages/elm/json/latest/\n\n@docs encode\n\n","unions":[{"name":"Exp","comment":" Does the number have an exponent?\n\ni.e. an optional suffix starting with `e` or `E` in the number.\n\n","args":[],"cases":[["Exp",["Json.Decode.Broken.Sign","Basics.Int"]],["NoExp",[]]]},{"name":"Frac","comment":" Does the number have a fractional component?\n\ni.e. the optional part after the decimal point.\n\n","args":[],"cases":[["Frac",["Basics.Int"]],["NoFrac",[]]]},{"name":"Sign","comment":" The sign of the exponent.\n","args":[],"cases":[["Plus",[]],["Minus",[]],["NoSign",[]]]},{"name":"Value","comment":" Custom type for JSON values.\n\nMostly this is self-explanatory, but numbers might be interesting because no\neffort is made to convert them to `Float` values. This means you can deal with\noverflows or precision mismatches in broken JSON.\n\n","args":[],"cases":[["Object",["List.List ( String.String, Json.Decode.Broken.Value )"]],["Array",["List.List Json.Decode.Broken.Value"]],["String",["String.String"]],["Number",["Basics.Int","Json.Decode.Broken.Frac","Json.Decode.Broken.Exp"]],["True",[]],["False",[]],["Null",[]]]}],"aliases":[],"values":[{"name":"array","comment":" Parser for a JSON array.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"encode","comment":" Encode a `Value` into a `Json.Encode.Value`.\n\nThis can then be used with `Json.Decode.decodeValue` to populate data structures\nin a more familiar way.\n\n**Note** that this converts `Number` with fractional parts or exponents to\n`Float`. If that conversion fails, it encodes as `NaN`.\n\n","type":"Json.Decode.Broken.Value -> Json.Encode.Value"},{"name":"false","comment":" Parser for a JSON 'false' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"json","comment":" Parser for JSON.\n\nThis is a JSON value surrounded by optional whitespace.\n\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"null","comment":" Parser for a JSON 'null' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"number","comment":" Parser for a JSON number.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"object","comment":" Parser for a JSON object.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"parse","comment":" Parse the given JSON string.\n\nErrors come straight from [elm/parser] and may not be super useful. It may be\nworth changing this parser to use elm/parser's `Parser.Advanced` which allows\nmore control over errors.\n\n[elm/parser]: https://package.elm-lang.org/packages/elm/parser/latest/\n\n","type":"String.String -> Result.Result (List.List Parser.DeadEnd) Json.Decode.Broken.Value"},{"name":"string","comment":" Parser for a quoted JSON string.\n\n`string` and some of its helpers have been adapted from elm/parser's\n`DoubleQuoteString` example.\n\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"toFloat","comment":" Convert a `Number` to a `Float`.\n","type":"Basics.Int -> Json.Decode.Broken.Frac -> Json.Decode.Broken.Exp -> Basics.Float"},{"name":"true","comment":" Parser for a JSON 'true' literal.\n","type":"Parser.Parser Json.Decode.Broken.Value"},{"name":"ws","comment":" Parser for JSON whitespace.\n\nThis is the whitespace that appears between significant elements of JSON, and\nbefore and after JSON documents, not whitespace within quoted strings.\n\n","type":"Parser.Parser ()"}],"binops":[]}]