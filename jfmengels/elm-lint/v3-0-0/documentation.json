[{"name":"Lint","comment":" A linter for Elm.\n\nSee Lint.Rules for available rules.\nTo define the rules you wish to use:\n\n    rules =\n        [ Lint.Rules.NoDebug.rule\n        , Lint.Rules.NoUnusedVariables\n        ]\n\nTo run the rules on a source code and get a list of errors:\n\n    lint : String -> List String\n    lint source =\n        let\n            errors =\n                List.concatMap (\\rule -> rule source) rules\n        in\n        if List.isEmpty errors then\n            [ \"No errors.\" ]\n\n        else\n            List.map (\\err -> err.rule ++ \": \" ++ err.message) errors\n\n\n# Implementation\n\n@docs lintSource\n\n\n# Rule creation functions\n\n@docs lint, doNothing, visitExpression\n\n\n# Internal\n\n@docs parseSource\n\n","unions":[],"aliases":[],"values":[{"name":"doNothing","comment":" Basic implementation of a visitor function that does nothing, i.e. return an empty list of errors and an untouched\ncontext. This is used to avoid a bit of boilerplate for visitor functions whose node types we are not interested in.\n\n    implementation : LintRuleImplementation Context\n    implementation =\n        { statementFn = doNothing\n        , typeFn = doNothing\n        , expressionFn = expressionFn\n        , moduleEndFn = \\ctx -> ( [], ctx )\n        , initialContext = Context\n        }\n\n","type":"context -> Lint.Types.Direction (Elm.Syntax.Node.Node a) -> ( List.List Lint.Types.LintError, context )"},{"name":"lint","comment":" Lints source code using a given rule implementation, and gives back a list of errors that were found.\n\n    rule : LintRule\n    rule input =\n        lint input implementation\n\n    implementation : LintRuleImplementation Context\n    implementation =\n        { typeFn = doNothing\n        , expressionFn = expressionFn\n        , moduleEndFn = \\ctx -> ( [], ctx )\n        , initialContext = Context\n        }\n\n","type":"Elm.Syntax.File.File -> Lint.Types.LintRuleImplementation context -> List.List Lint.Types.LintError"},{"name":"lintSource","comment":" Lints a file and gives back the errors raised by the given rules.\n\n    errors =\n        lintSource rules source\n\n","type":"List.List ( Lint.Types.Severity, Lint.Types.LintRule ) -> String.String -> Result.Result (List.List String.String) (List.List ( Lint.Types.Severity, Lint.Types.LintError ))"},{"name":"parseSource","comment":" Parse source code into a AST\n","type":"String.String -> Result.Result (List.List String.String) Elm.Syntax.File.File"},{"name":"visitExpression","comment":" Visit an expression using a sub rule implementation. The use of this function is not encouraged, but it can make\npart of the implementation of complex rules much easier. It gives back a list of errors and a context.\n\n    expressionFn : Context -> Direction Expression -> ( List LintError, Context )\n    expressionFn ctx node =\n        case node of\n            Enter (Case expr patterns) ->\n                visitExpression subimplementation expr\n\n            _ ->\n                ( [], ctx )\n\n    subimplementation : LintRuleImplementation Subcontext\n    subimplementation =\n        { statementFn = doNothing\n        , typeFn = doNothing\n        , expressionFn = subexpressionFn\n        , moduleEndFn = \\ctx -> ( [], ctx )\n        , initialContext = Subcontext\n        }\n\n","type":"Lint.Types.LintRuleImplementation context -> Elm.Syntax.Node.Node Elm.Syntax.Expression.Expression -> ( List.List Lint.Types.LintError, context )"}],"binops":[]},{"name":"Lint.Rules.NoDebug","comment":"\n\n@docs rule\n\n\n# Fail\n\n    if Debug.log \"condition\" condition then\n        a\n\n    else\n        b\n\n    if condition then\n        Debug.crash \"Nooo!\"\n\n    else\n        value\n\n\n# Success\n\n    if condition then\n        a\n\n    else\n        b\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Forbid the use of `Debug` before it goes into production.\n\n    rules =\n        [ NoDebug.rule\n        ]\n\n","type":"Elm.Syntax.File.File -> List.List Lint.Types.LintError"}],"binops":[]},{"name":"Lint.Types","comment":" This module contains types that are used for writing rules.\n\n\n# Elementary types\n\n@docs LintError, Direction\n\n\n# Configuration\n\n@docs LintRule, Severity\n\n\n# Writing rules\n\n@docs LintRuleImplementation, LintImplementation\n\n\n# Internal types\n\n@docs Visitor, LintResult\n\n","unions":[{"name":"Direction","comment":" When visiting the AST, nodes are visited twice:\n\n  - on Enter, before the children of the node will be visited\n\n  - on Exit, after the children of the node have been visited\n\n    expressionFn : Context -> Direction Expression -> ( List LintError, Context )\n    expressionFn ctx node =\n    case node of\n    Enter (Variable names) ->\n    ( [], markVariableAsUsed ctx names )\n\n              -- Find variables declared in `let .. in ..` expression\n              Enter (Let declarations body) ->\n                  ( [], registerVariables ctx declarations )\n\n              -- When exiting the `let .. in ..` expression, report the variables that were not used.\n              Exit (Let _ _) ->\n                  ( unusedVariables ctx |> List.map createError, ctx )\n\n","args":["node"],"cases":[["Enter",["node"]],["Exit",["node"]]]},{"name":"Severity","comment":" Severity associated to a rule.\n\n  - Critical: Transgressions reported by the rule will make the linting process fail.\n  - Warning: Transgressions reported by the rule will not make the linting process fail.\n  - Disabled: Rule will not be enforced.\n\n","args":[],"cases":[["Disabled",[]],["Warning",[]],["Critical",[]]]}],"aliases":[{"name":"LintError","comment":" Value that describes an error found by a given rule, that contains the name of the rule that raised the error, and\na description of the error.\n\n    error : LintError\n    error =\n        LintError \"NoDebug\" \"Forbidden use of Debug\"\n\n","args":[],"type":"{ rule : String.String, message : String.String }"},{"name":"LintImplementation","comment":" A LintImplementation is a function that takes a given Context object, as defined by each rule, a node (with a\nDirection) and returns a list of errors and an updated Context.\nEvery rule should implement three LintImplementation functions, one for every Node type (Statement, Type and\nExpression).\nThe Context is there to accumulate information about the source code as the AST is being visited and is shared by all\nthe LintImplementation functions of your rule.\nIt must return a list of errors which will be reported to the user, that are violations of the thing the rule wants to\nenforce.\n\n    rule : LintRule\n    rule input =\n        lint input implementation\n\n    implementation : LintRuleImplementation Context\n    implementation =\n        { statementFn = doNothing\n        , typeFn = doNothing\n        , expressionFn = expressionFn\n        , moduleEndFn = \\ctx -> ( [], ctx )\n        , initialContext = Context\n        }\n\n","args":["nodeType","context"],"type":"context -> Lint.Types.Direction (Elm.Syntax.Node.Node nodeType) -> ( List.List Lint.Types.LintError, context )"},{"name":"LintResult","comment":" Shortcut to the result of a lint rule\n","args":[],"type":"Result.Result (List.List String.String) (List.List Lint.Types.LintError)"},{"name":"LintRule","comment":" Shortcut to a lint rule\n","args":[],"type":"Elm.Syntax.File.File -> List.List Lint.Types.LintError"},{"name":"LintRuleImplementation","comment":" A LintRuleImplementation is the implementation of a rule. It is a record that contains:\n\n  - initialContext: An initial context\n\n  - expressionFn: A LintImplementation for Expression nodes\n\n  - moduleEndFn: A function that takes a context and returns a list of error. Similar to a LintImplementation, but will\n    be called after visiting the whole AST.\n\n    rule : LintRule\n    rule input =\n    lint input implementation\n\n    implementation : LintRuleImplementation Context\n    implementation =\n    { expressionFn = expressionFn\n    , moduleEndFn = (\\\\ctx -> ( [], ctx ))\n    , initialContext = Context\n    }\n\n","args":["context"],"type":"{ expressionFn : Lint.Types.LintImplementation Elm.Syntax.Expression.Expression context, moduleEndFn : context -> ( List.List Lint.Types.LintError, context ), initialContext : context }"},{"name":"Visitor","comment":" Shorthand for a function that takes a rule's implementation, a context and returns ( List LintError, context ).\nA Visitor represents a node and calls the appropriate function for the given node type.\n\nNote: this is internal API, and will be removed in a future version.\n\n","args":["context"],"type":"Lint.Types.LintRuleImplementation context -> context -> ( List.List Lint.Types.LintError, context )"}],"values":[],"binops":[]}]