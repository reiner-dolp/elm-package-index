[{"name":"Quantity.Interval","comment":" Note: most examples assume that you have imported this module as\n\n    import Quantity.Interval as Interval\n\nThe only exceptions are the examples for `sin` and `cos`; see the\n[Trigonometry](#trigonometry) section for details.\n\n@docs Interval\n\n\n# Constructors\n\n@docs singleton, fromEndpoints, from, containingValues, aggregate, hull, intersection\n\n\n# Properties\n\n@docs endpoints, minValue, maxValue, midpoint, width\n\n\n# Queries\n\n@docs contains, intersects, isContainedIn, isSingleton\n\n\n# Interpolation\n\n@docs interpolate\n\n\n# Trigonometry\n\nNote that in the same way that `Angle.sin` and `Angle.cos` from the `elm-units`\npackage take an `Angle` (a `Quantity Float Radians`) value and return a plain\n`Float`, `sin` and `cos` in this package take an angle `Interval` from this\npackage (a `Quantity.Interval.Interval Float Radians`) and return a plain\n`Interval Float` from the `elm-interval` package (an `Interval.Interval Float`).\n\nAs a result, the examples for `sin` and `cos` below use fully qualified module\nnames to avoid ambiguity, so `Interval` refers to the `Interval` module from\n`elm-interval` and not the `Quantity.Interval` module from this package.\n\n@docs sin, cos\n\n","unions":[{"name":"Interval","comment":" Represents a finite, closed interval with a minimum and maximum value, for\nexample the interval from 0 degrees to 360 degrees. An `Interval number units`\nrepresents a range of [`Quantity number units`][1] values.\n\n[1]: https://package.elm-lang.org/packages/ianmackenzie/elm-units/latest/Quantity\n\n","args":["number","units"],"cases":[]}],"aliases":[],"values":[{"name":"aggregate","comment":" Construct an interval containing all of the intervals in the given list. If\nthe list is empty, returns `Nothing`.\n\n    Interval.aggregate\n        [ Interval.singleton (Length.feet 2)\n        , Interval.from\n            (Length.feet 3)\n            (Length.feet 4)\n        ]\n    --> Just (Interval.from (Length.feet 2) (Length.feet 4))\n\n    Interval.aggregate []\n    --> Nothing\n\n","type":"List.List (Quantity.Interval.Interval number units) -> Maybe.Maybe (Quantity.Interval.Interval number units)"},{"name":"containingValues","comment":" Construct an interval containing all values in the given list. If the list\nis empty, returns `Nothing`.\n\n    Interval.containingValues\n        [ Length.meters 2\n        , Length.meters 1\n        , Length.meters 3\n        ]\n    --> Just <|\n    -->     Interval.from\n    -->         (Length.meters 1)\n    -->         (Length.meters 3)\n\n    Interval.containingValues [ Length.meters -3 ]\n    --> Just (Interval.singleton (Length.meters -3))\n\n    Interval.containingValues []\n    --> Nothing\n\n","type":"List.List (Quantity.Quantity number units) -> Maybe.Maybe (Quantity.Interval.Interval number units)"},{"name":"contains","comment":" Check if an interval contains a given value.\n\n    durationInterval =\n        Interval.from\n            (Duration.minutes 30)\n            (Duration.minutes 90)\n\n    durationInterval\n        |> Interval.contains\n            (Duration.hours 1)\n    --> True\n\n\n    durationInterval\n        |> Interval.contains\n            (Duration.hours 2)\n    --> False\n\nThe minimum and maximum values of an interval are considered to be contained in\nthe interval:\n\n    durationInterval\n        |> Interval.contains\n            (Duration.hours 0.5)\n    --> True\n\n","type":"Quantity.Quantity number units -> Quantity.Interval.Interval number units -> Basics.Bool"},{"name":"cos","comment":" For a given range of angle values, find the corresponding range of sine\nvalues. Takes an `Interval` from this module and returns an `Interval` from the\n`elm-interval` package.\n\n    Quantity.Interval.cos <|\n        Quantity.Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 45)\n    --> Interval.from 0.7071 1\n\n    Quantity.Interval.cos <|\n        Quantity.Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 180)\n    --> Interval.from -1 1\n\n","type":"Quantity.Interval.Interval Basics.Float Angle.Radians -> Interval.Interval Basics.Float"},{"name":"endpoints","comment":" Get the endpoints of an interval (its minimum and maximum values) as a\ntuple. The first value will always be less than or equal to the second.\n\n    ( minValue, maxValue ) =\n        Interval.endpoints someInterval\n\nFor any interval,\n\n    Interval.endpoints interval\n\nis equivalent to (but more efficient than)\n\n    ( Interval.minValue interval\n    , Interval.maxValue interval\n    )\n\n","type":"Quantity.Interval.Interval number units -> ( Quantity.Quantity number units, Quantity.Quantity number units )"},{"name":"from","comment":" Construct an interval with the two given endpoints (which can be provided in\neither order).\n\n    Interval.endpoints <|\n        Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 180)\n    --> ( Angle.degrees 0, Angle.degrees 180 )\n\n    Interval.endpoints <|\n        Interval.from\n            (Angle.degrees 180)\n            (Angle.degrees 0)\n    --> ( Angle.degrees 0, Angle.degrees 180 )\n\n","type":"Quantity.Quantity number units -> Quantity.Quantity number units -> Quantity.Interval.Interval number units"},{"name":"fromEndpoints","comment":" Construct an interval from its endpoints (the minimum and maximum values of\nthe interval). For example, the infamous old \"allow 4 to 6 weeks for delivery\":\n\n    deliveryTime =\n        Interval.fromEndpoints\n            ( Duration.weeks 4\n            , Duration.weeks 6\n            )\n\nThe two values should be given in order but will be swapped if necessary to\nensure a valid interval is returned:\n\n    Interval.endpoints\n        ( Interval.fromEndpoints\n            ( Duration.minutes 3\n            , Duration.minutes 2\n            )\n        )\n    --> ( Duration.minutes 2, Duration.minutes 3 )\n\n","type":"( Quantity.Quantity number units, Quantity.Quantity number units ) -> Quantity.Interval.Interval number units"},{"name":"hull","comment":" Construct an interval containing both of the given intervals.\n\n    firstInterval =\n        Interval.from\n            (Duration.hours 1)\n            (Duration.hours 2)\n\n    secondInterval =\n        Interval.from\n            (Duration.hours 3)\n            (Duration.hours 6)\n\n    Interval.hull firstInterval secondInterval\n    --> Interval.from\n    -->     (Duration.hours 1)\n    -->     (Duration.hours 6)\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Interval.Interval number units -> Quantity.Interval.Interval number units"},{"name":"interpolate","comment":" Interpolate between an interval's endpoints; a value of 0.0 corresponds to\nthe minimum value of the interval, a value of 0.5 corresponds to its midpoint\nand a value of 1.0 corresponds to its maximum value. Values less than 0.0 or\ngreater than 1.0 can be used to extrapolate.\n\n    oneTurn =\n        Interval.from (Angle.degrees 0) (Angle.degrees 360)\n\n    Interval.interpolate oneTurn 0\n    --> Angle.degrees 0\n\n    Interval.interpolate oneTurn 0.75\n    --> Angle.degrees 270\n\n    Interval.interpolate oneTurn -0.5\n    --> Angle.degrees -180\n\nNote that the interpolation is in fact from the minimum value to the maximum,\n_not_ \"from the first `Interval.from` argument to the second\":\n\n    Interval.interpolate\n        (Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 180)\n        )\n        0.25\n    --> Angle.degrees 45\n\n    Interval.interpolate\n        (Interval.from\n            (Angle.degrees 180)\n            (Angle.degrees 0)\n        )\n        0.25\n    --> Angle.degrees 45 -- not 135!\n\n","type":"Quantity.Interval.Interval Basics.Float units -> Basics.Float -> Quantity.Quantity Basics.Float units"},{"name":"intersection","comment":" Attempt to construct an interval containing all the values common to both\ngiven intervals. If the intervals do not intersect, returns `Nothing`.\n\n    Interval.intersection\n        (Interval.from (pixels 100) (pixels 300))\n        (Interval.from (pixels 200) (pixels 500))\n    --> Just (Interval.from (pixels 200) (pixels 300))\n\n    Interval.intersection\n        (Interval.from (pixels 100) (pixels 300))\n        (Interval.from (pixels 400) (pixels 700))\n    --> Nothing\n\nIf the two intervals just touch, a singleton interval will be returned:\n\n    Interval.intersection\n        (Interval.from (pixels 100) (pixels 300))\n        (Interval.from (pixels 300) (pixels 500))\n    --> Just (Interval.singleton (pixels 300))\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Interval.Interval number units -> Maybe.Maybe (Quantity.Interval.Interval number units)"},{"name":"intersects","comment":" Check if two intervals touch or overlap (have any values in common).\n\n    distanceInterval =\n        Interval.from\n            (Length.kilometers 5)\n            (Length.kilometers 10)\n\n    distanceInterval\n        |> Interval.intersects\n            (Interval.from\n                (Length.kilometers 8)\n                (Length.kilometers 12)\n            )\n    --> True\n\n    distanceInterval\n        |> Interval.intersects\n            (Interval.from\n                (Length.kilometers 12)\n                (Length.kilometers 15)\n            )\n    --> False\n\nIntervals that just touch each other are considered to intersect (this is\nconsistent with `intersection` which will return a zero-width interval for the\nintersection of two just-touching intervals):\n\n    distanceInterval\n        |> Interval.intersects\n            (Interval.from\n                (Length.kilometers 10)\n                (Length.kilometers 15)\n            )\n    --> True\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Interval.Interval number units -> Basics.Bool"},{"name":"isContainedIn","comment":" Check if the second interval is fully contained in the first.\n\n    angleInterval =\n        Interval.from\n            (Angle.degrees -30)\n            (Angle.degrees 30)\n\n    Interval.from (Angle.degrees -5) (Angle.degrees 15)\n        |> Interval.isContainedIn angleInterval\n    --> True\n\n    Interval.from (Angle.degrees 15) (Angle.degrees 45)\n        |> Interval.isContainedIn angleInterval\n    --> False\n\nBe careful with the argument order! If not using the `|>` operator, the first\nexample would be written as:\n\n    Interval.isContainedIn angleInterval\n        (Interval.from\n            (Angle.degrees -5)\n            (Angle.degrees 15)\n        )\n    --> True\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Interval.Interval number units -> Basics.Bool"},{"name":"isSingleton","comment":" Check if the interval is a singleton (the minimum and maximum values are the\nsame).\n\n    Interval.isSingleton\n        (Interval.from (Length.meters 2) (Length.meters 2))\n    --> True\n\n    Interval.isSingleton\n        (Interval.from (Length.meters 2) (Length.meters 3))\n    --> False\n\n","type":"Quantity.Interval.Interval number units -> Basics.Bool"},{"name":"maxValue","comment":" Get the maximum value of an interval.\n\n    Interval.maxValue <|\n        Interval.from\n            (Length.meters 1)\n            (Length.meters 3)\n    --> Length.meters 3\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Quantity number units"},{"name":"midpoint","comment":" Get the midpoint of an interval.\n\n    Interval.midpoint <|\n        Interval.from\n            (Duration.seconds 1)\n            (Duration.seconds 4)\n    --> Duration.seconds 2.5\n\n","type":"Quantity.Interval.Interval Basics.Float units -> Quantity.Quantity Basics.Float units"},{"name":"minValue","comment":" Get the minimum value of an interval.\n\n    Interval.minValue <|\n        Interval.from\n            (Length.meters 1)\n            (Length.meters 3)\n    --> Length.meters 1\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Quantity number units"},{"name":"sin","comment":" For a given range of angle values, find the corresponding range of sine\nvalues. Takes an `Interval` from this module and returns an `Interval` from the\n`elm-interval` package.\n\n    Quantity.Interval.sin <|\n        Quantity.Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 45)\n    --> Interval.from 0 0.7071\n\n    Quantity.Interval.sin <|\n        Quantity.Interval.from\n            (Angle.degrees 0)\n            (Angle.degrees 180)\n    --> Interval.from 0 1\n\n","type":"Quantity.Interval.Interval Basics.Float Angle.Radians -> Interval.Interval Basics.Float"},{"name":"singleton","comment":" Construct a zero-width interval containing a single value.\n\n    Interval.singleton (Length.meters 3)\n    --> Interval.fromEndpoints\n    -->     ( Length.meters 3\n    -->     , Length.meters 3\n    -->     )\n\n","type":"Quantity.Quantity number units -> Quantity.Interval.Interval number units"},{"name":"width","comment":" Get the width of an interval. This will never be negative.\n\n    Interval.width <|\n        Interval.from\n            (Duration.seconds 1)\n            (Duration.seconds 4)\n    --> Duration.seconds 3\n\n","type":"Quantity.Interval.Interval number units -> Quantity.Quantity number units"}],"binops":[]}]