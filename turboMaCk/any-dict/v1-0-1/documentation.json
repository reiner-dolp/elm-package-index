[{"name":"Dict.Any","comment":" A dictionary mapping unique keys to values.\nSimilar and based on Dict but without restriction on comparable keys.\n\nInsert, remove, and query operations all take O(log n) time.\n\n\n# Converting Types to Comparable\n\nWhen writing a function for conversion from the type you want to use for keys to comparable\nit's very important to make sure every distinct member of type k produces different value in set o of comparables.\n\nTake for instance those two examples:\n\nWe can use Bool as a key for our Dict (No matter how unpractical it might seem)\n\n    boolToInt : Bool -> Int\n    boolToInt bool =\n        case bool of\n            False -> 0\n            True -> 1\n\n    empty boolToInt\n    |> insert True \"foo\"\n    |> get True\n    --> Just \"foo\"\n\nor Maybe String.\n\n    comparableKey : Maybe String -> (Int, String)\n    comparableKey maybe =\n        case maybe of\n            Nothing -> (0, \"\")\n            Just str -> (1, str)\n\n    empty comparableKey\n        |> insert (Just \"foo\") 42\n        |> get (Just \"foo\")\n    --> Just 42\n\nNote that we give Int code to either constructor and in Case of Nothing we default to `\"\"` (empty string).\nThere is still a difference between `Nothing` and `Just \"\"` (`Int` value in the pair is different).\nIn fact, you can \"hardcode\" any value as the second member of the pair\nin case of nothing but empty string seems like a reasonable option for this case.\nGenerally, this is how I would implement `toComparable` function for most of your custom data types.\nHave a look at the longest constructor,\nDefine tuple where the first key is int (number of the constructor)\nand other are types within the constructor and you're good to go.\n\n\n# Dictionaries\n\n@docs AnyDict\n\n\n# Build\n\n@docs empty, singleton, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size\n\n\n# Lists\n\n@docs keys, values, toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Combine\n\n@docs union, intersect, diff, merge\n\n\n# Dict\n\n@docs toDict\n\n","unions":[{"name":"AnyDict","comment":" ","args":["comparable","k","v"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a key-value pair when its key does not appear in the second dictionary.\n","type":"Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"empty","comment":" Create an empty dictionary by suppling function used for comparing keys.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n","type":"(k -> comparable) -> Dict.Any.AnyDict comparable k v"},{"name":"filter","comment":" Keep a key-value pair when it satisfies a predicate.\n","type":"(k -> v -> Basics.Bool) -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"foldl","comment":" Fold over the key-value pairs in a dictionary, in order from lowest key to highest key.\n","type":"(k -> v -> b -> b) -> b -> Dict.Any.AnyDict comparable k v -> b"},{"name":"foldr","comment":" Fold over the key-value pairs in a dictionary, in order from highest key to lowest key.\n","type":"(k -> v -> b -> b) -> b -> Dict.Any.AnyDict comparable k v -> b"},{"name":"fromList","comment":" Convert an association list into a dictionary.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n","type":"(k -> comparable) -> List.List ( k, v ) -> Dict.Any.AnyDict comparable k v"},{"name":"get","comment":" Get the value associated with a key.\nIf the key is not found, return Nothing.\nThis is useful when you are not sure\nif a key will be in the dictionary.\n\n    type Animal = Cat | Mouse | Dog\n\n    animalToInt : Animal -> Int\n    animalToInt animal =\n        case animal of\n            Cat -> 0\n            Mouse -> 1\n            Dog -> 2\n\n    animals : AnyDict Int Animal String\n    animals =\n        [ (Cat, \"Tom\"), (Mouse, \"Jerry\") ]\n            |> fromList animalToInt\n\n    get Cat animals\n    -> Just \"Tom\"\n\n    get Mouse animals\n    --> Just \"Jerry\"\n\n    get Dog animals\n    --> Nothing\n\n","type":"k -> Dict.Any.AnyDict comparable k v -> Maybe.Maybe v"},{"name":"insert","comment":" Insert a key-value pair into a dictionary. Replaces value when there is a collision.\n","type":"k -> v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"intersect","comment":" Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n","type":"Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"isEmpty","comment":" Determine if a dictionary is empty.\n\n    isEmpty (empty identity)\n    --> True\n\n    singleton 1 \"foo\" identity\n        |> isEmpty\n    --> False\n\n","type":"Dict.Any.AnyDict comparable k v -> Basics.Bool"},{"name":"keys","comment":" Get all of the keys in a dictionary, sorted from lowest to highest.\n","type":"Dict.Any.AnyDict comparable k v -> List.List k"},{"name":"map","comment":" Apply a function to all values in a dictionary.\n","type":"(a -> b -> c) -> Dict.Any.AnyDict comparable a b -> Dict.Any.AnyDict comparable a c"},{"name":"member","comment":" Determine if a key is in a dictionary.\n","type":"k -> Dict.Any.AnyDict comparable k v -> Basics.Bool"},{"name":"merge","comment":" The most general way of combining two dictionaries.\nYou provide three accumulators for when a given key appears:\n\n1.  Only in the left dictionary.\n2.  In both dictionaries.\n3.  Only in the right dictionary.\n\nOnly in the left dictionary.\nIn both dictionaries.\nOnly in the right dictionary.\n\n","type":"(k -> a -> result -> result) -> (k -> a -> b -> result -> result) -> (k -> b -> result -> result) -> Dict.Any.AnyDict comparable k a -> Dict.Any.AnyDict comparable k b -> result -> result"},{"name":"partition","comment":" Partition a dictionary according to a predicate.\nThe first dictionary contains all key-value pairs which satisfy the predicate,\nand the second contains the rest.\n","type":"(k -> v -> Basics.Bool) -> Dict.Any.AnyDict comparable k v -> ( Dict.Any.AnyDict comparable k v, Dict.Any.AnyDict comparable k v )"},{"name":"remove","comment":" Remove a key-value pair from a dictionary.\nIf the key is not found, no changes are made.\n","type":"k -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"singleton","comment":" Create a dictionary with one key-value pair.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n","type":"k -> v -> (k -> comparable) -> Dict.Any.AnyDict comparable k v"},{"name":"size","comment":" Determine the number of key-value pairs in the dictionary.\n","type":"Dict.Any.AnyDict comparable k v -> Basics.Int"},{"name":"toDict","comment":" Convert `AnyDict` to plain dictionary with comparable keys.\n","type":"Dict.Any.AnyDict comparable k v -> Dict.Dict comparable v"},{"name":"toList","comment":" Convert a dictionary into an association list of key-value pairs,\nsorted by keys.\n","type":"Dict.Any.AnyDict comparable k v -> List.List ( k, v )"},{"name":"union","comment":" Combine two dictionaries. If there is a collision, preference is given to the first dictionary.\n","type":"Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"update","comment":" Update the value of a dictionary for a specific key with a given function.\n","type":"k -> (Maybe.Maybe v -> Maybe.Maybe v) -> Dict.Any.AnyDict comparable k v -> Dict.Any.AnyDict comparable k v"},{"name":"values","comment":" Get all of the values in a dictionary, in the order of their keys.\n","type":"Dict.Any.AnyDict comparable k v -> List.List v"}],"binops":[]}]