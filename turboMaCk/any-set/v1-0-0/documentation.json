[{"name":"Set.Any","comment":" A set of unique values. Similar to elm/core Set but allows arbitrary data\ngiven a function for converting to `comparable` can be provided.\n\nInsert, remove, and query operations all take O(log n) time.\n\n\n# Converting Types to Comparable\n\nWhen writing a function for conversion from the type you want to use within a set to comparable\nit's very important to make sure every distinct member of the type produces different value in the set of comparables.\n\nTake for instance those two examples:\n\nWe can use store Bool in Set (No matter how unpractical it might seem)\n\n    boolToInt : Bool -> Int\n    boolToInt bool =\n        case bool of\n            False -> 0\n            True -> 1\n\n    empty boolToInt\n    |> insert True\n    |> member True\n    --> True\n\nor Maybe String.\n\n    comparableKey : Maybe String -> (Int, String)\n    comparableKey maybe =\n        case maybe of\n            Nothing -> (0, \"\")\n            Just str -> (1, str)\n\n    empty comparableKey\n        |> insert (Just \"foo\")\n        |> member (Just \"foo\")\n    --> True\n\nNote that we give Int code to either constructor and in case of Nothing we default to `\"\"` (empty string).\nThere is still a difference between `Nothing` and `Just \"\"` (`Int` value in the pair is different).\nIn fact, you can \"hardcode\" any value as the second member of the pair\nin case of Nothing but empty string seems like a reasonable option for this case.\nGenerally, this is how I would implement `toComparable` function for most of your custom data types.\nHave a look at the longest constructor,\nDefine tuple where the first key is int (number of the constructor)\nand other are types within the constructor and you're good to go.\n\n\n# AnySet\n\n@docs AnySet\n\n\n# Build\n\n@docs empty, singleton, insert, remove\n\n\n# Query\n\n@docs isEmpty, member, size\n\n\n# Compine\n\n@docs union, intersect, diff\n\n\n# Lists\n\n@docs toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Set\n\n@docs toSet\n\n","unions":[{"name":"AnySet","comment":" Represents a set of unique values.\n","args":["comparable","t"],"cases":[["AnySet",["Dict.Any.AnyDict comparable t ()"]]]}],"aliases":[],"values":[{"name":"diff","comment":" Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n","type":"Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"},{"name":"empty","comment":" Create an empty set.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n","type":"(a -> comparable) -> Set.Any.AnySet comparable a"},{"name":"filter","comment":" Only keep elements that pass the given test.\n","type":"(a -> Basics.Bool) -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"},{"name":"foldl","comment":" Fold over the values in a set, in order from highest to lowest.\n","type":"(a -> b -> b) -> b -> Set.Any.AnySet comparable a -> b"},{"name":"foldr","comment":" Map a function onto a set, creating a new set with no duplicates.\n","type":"(a -> b -> b) -> b -> Set.Any.AnySet comparable a -> b"},{"name":"fromList","comment":" Convert a list into a set, removing any duplicates.\n","type":"(a -> comparable) -> List.List a -> Set.Any.AnySet comparable a"},{"name":"insert","comment":" Insert a value into a set.\n","type":"a -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"},{"name":"intersect","comment":" Get the intersection of two sets. Keeps values that appear in both sets.\n","type":"Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"},{"name":"isEmpty","comment":" Determine if a set is empty.\n","type":"Set.Any.AnySet comparable a -> Basics.Bool"},{"name":"map","comment":" Fold over the values in a set, in order from lowest to highest.\n","type":"(b -> comparable2) -> (a -> b) -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable2 b"},{"name":"member","comment":" Determine if a value is in a set.\n","type":"a -> Set.Any.AnySet comparable a -> Basics.Bool"},{"name":"partition","comment":" Create two new sets. The first contains all the elements that passed the\ngiven test, and the second contains all the elements that did not.\n","type":"(a -> Basics.Bool) -> Set.Any.AnySet comparable a -> ( Set.Any.AnySet comparable a, Set.Any.AnySet comparable a )"},{"name":"remove","comment":" Remove a value from a set. If the value is not found, no changes are made.\n","type":"a -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"},{"name":"singleton","comment":" Create a set with one value.\n\n** Note that it's important to make sure every key is turned to different comparable.\nOtherwise keys would conflict and overwritede each other.**\n\n","type":"a -> (a -> comparable) -> Set.Any.AnySet comparable a"},{"name":"size","comment":" Determine the number of elements in a set.\n","type":"Set.Any.AnySet comparable a -> Basics.Int"},{"name":"toList","comment":" Convert a set into a list, sorted from lowest to highest.\n","type":"Set.Any.AnySet comparable a -> List.List a"},{"name":"toSet","comment":" Convert AnySet to elm/core Set of comparable\n","type":"Set.Any.AnySet comparable a -> Set.Set comparable"},{"name":"union","comment":" Get the union of two sets. Keep all values.\n","type":"Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a -> Set.Any.AnySet comparable a"}],"binops":[]}]