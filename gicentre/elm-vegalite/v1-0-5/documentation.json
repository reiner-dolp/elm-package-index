[{"name":"VegaLite","comment":" Create Vega-Lite specifications in Elm. A specification can be sent to a\nVega-Lite compiler to generate the graphics. While this a pure Elm library, to\ngenerate the graphical output you probably want to send the JSON generated by\n`toVegaLite` via a port to some JavaScript that invokes the Vega-Lite runtime.\n\n\n# Creating A Vega-Lite Specification\n\n@docs toVegaLite\n@docs VLProperty\n@docs Spec\n@docs LabelledSpec\n@docs combineSpecs\n\n\n# Creating the Data Specification\n\nFunctions and types for declaring the data to the visualized. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/data.html#format).\n\n@docs dataFromUrl\n@docs dataFromColumns\n@docs dataFromRows\n@docs dataFromJson\n@docs dataFromSource\n@docs dataName\n@docs datasets\n@docs dataColumn\n@docs dataRow\n@docs Data\n@docs DataColumn\n@docs DataRow\n\n\n## Geographic Data\n\n@docs geometry\n@docs geoFeatureCollection\n@docs geometryCollection\n@docs geoPoint\n@docs geoPoints\n@docs geoLine\n@docs geoLines\n@docs geoPolygon\n@docs geoPolygons\n\n\n## Formatting Input Data\n\nSee the Vega-Lite\n[format](https://vega.github.io/vega-lite/docs/data.html#format) and\n[JSON](https://vega.github.io/vega-lite/docs/data.html#json) documentation.\n\n@docs csv\n@docs tsv\n@docs dsv\n@docs jsonProperty\n@docs topojsonFeature\n@docs topojsonMesh\n@docs parse\n\n@docs foNum\n@docs foBoo\n@docs foDate\n@docs foUtc\n\n\n# Creating the Transform Specification\n\nTransformation rules are applied to data fields or geospatial coordinates before\nthey are encoded visually.\n\n@docs transform\n\n\n## Map Projections\n\nSee the\n[Vega-Lite map projection documentation](https://vega.github.io/vega-lite/docs/projection.html).\n\n@docs projection\n\n@docs prType\n@docs prClipAngle\n@docs prClipExtent\n@docs prCenter\n@docs prRotate\n@docs prPrecision\n@docs prCoefficient\n@docs prDistance\n@docs prFraction\n@docs prLobes\n@docs prParallel\n@docs prRadius\n@docs prRatio\n@docs prSpacing\n@docs prTilt\n\n@docs albers\n@docs albersUsa\n@docs azimuthalEqualArea\n@docs azimuthalEquidistant\n@docs conicConformal\n@docs conicEqualArea\n@docs conicEquidistant\n@docs equirectangular\n@docs gnomonic\n@docs mercator\n@docs orthographic\n@docs stereographic\n@docs transverseMercator\n@docs customProjection\n@docs noClip\n@docs clipRect\n\n\n## Aggregation\n\nSee the\n[Vega-Lite aggregate documentation](https://vega.github.io/vega-lite/docs/aggregate.html).\n\n@docs aggregate\n@docs opAs\n@docs timeUnitAs\n@docs opArgMax\n@docs opArgMin\n@docs opCI0\n@docs opCI1\n@docs opCount\n@docs opDistinct\n@docs opMax\n@docs opMean\n@docs opMedian\n@docs opMin\n@docs opMissing\n@docs opQ1\n@docs opQ3\n@docs opStderr\n@docs opStdev\n@docs opStdevP\n@docs opSum\n@docs opValid\n@docs opVariance\n@docs opVarianceP\n\n\n## Binning\n\nSee the [Vega-Lite binning documentation](https://vega.github.io/vega-lite/docs/bin.html).\n\n@docs binAs\n@docs biBase\n@docs biDivide\n@docs biExtent\n@docs biMaxBins\n@docs biMinStep\n@docs biNice\n@docs biStep\n@docs biSteps\n\n\n## Stacking\n\nSee the [Vega-Lite stack documentation](https://vega.github.io/vega-lite/docs/stack.html)\n\n@docs stack\n@docs stOffset\n@docs stNormalize\n@docs stCenter\n@docs stZero\n@docs stNone\n@docs stSort\n@docs stAscending\n@docs stDescending\n\n\n## Data Calculation\n\nSee\n[Vega-Lite calculate documentation](https://vega.github.io/vega-lite/docs/calculate.html).\n\n@docs calculateAs\n\n\n## Filtering\n\nSee the\n[Vega-Lite filter documentation](https://vega.github.io/vega-lite/docs/filter.html).\n\n@docs filter\n\n@docs fiEqual\n@docs fiLessThan\n@docs fiLessThanEq\n@docs fiGreaterThan\n@docs fiGreaterThanEq\n@docs fiExpr\n@docs fiCompose\n@docs fiSelection\n@docs fiOneOf\n@docs fiRange\n@docs fiValid\n@docs numRange\n@docs dtRange\n\n\n## Flattening\n\nSee the Vega-Lite [flatten](https://vega.github.io/vega-lite/docs/flatten.html)\nand [fold](https://vega.github.io/vega-lite/docs/fold.html) documentation.\n\n@docs flatten\n@docs flattenAs\n@docs fold\n@docs foldAs\n\n\n## Relational Joining (lookup)\n\nSee the [Vega-Lite lookup documentation](https://vega.github.io/vega-lite/docs/lookup.html).\n\n@docs lookup\n@docs lookupAs\n\n\n## Data Imputation\n\nImpute missing data. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html#transform).\n\n@docs impute\n@docs imFrame\n@docs imKeyVals\n@docs imKeyValSequence\n@docs imMethod\n@docs imGroupBy\n@docs imNewValue\n@docs imValue\n@docs imMean\n@docs imMedian\n@docs imMax\n@docs imMin\n\n\n## Data Sampling\n\nSee the [Vega-Lite sample documentation](https://vega.github.io/vega-lite/docs/sample.html)\n\n@docs sample\n\n\n## Window Transformations\n\nSee the Vega-Lite\n[window transform field](https://vega.github.io/vega-lite/docs/window.html#field-def)\nand [window transform](https://vega.github.io/vega-lite/docs/window.html#window-transform-definition)\ndocumentation.\n\n@docs window\n@docs wiAggregateOp\n@docs wiOp\n@docs wiParam\n@docs wiField\n@docs woRowNumber\n@docs woRank\n@docs woDenseRank\n@docs woPercentRank\n@docs woCumeDist\n@docs woPercentile\n@docs woLag\n@docs woLead\n@docs woFirstValue\n@docs woLastValue\n@docs woNthValue\n@docs wiFrame\n@docs wiIgnorePeers\n@docs wiGroupBy\n@docs wiSort\n@docs wiAscending\n@docs wiDescending\n\n\n# Creating the Mark Specification\n\nFunctions for declaring the type of visual marks used in the visualization.\n\n@docs area\n@docs bar\n@docs boxplot\n@docs errorband\n@docs errorbar\n@docs circle\n@docs geoshape\n@docs line\n@docs point\n@docs rect\n@docs rule\n@docs square\n@docs textMark\n@docs tick\n@docs trail\n\n\n## Mark Properties\n\nSee the Vega-Lite\n[general mark](https://vega.github.io/vega-lite/docs/mark.html#general-mark-properties),\n[area mark](https://vega.github.io/vega-lite/docs/area.html#properties),\n[bar mark](https://vega.github.io/vega-lite/docs/bar.html),\n[hyperlink mark](https://vega.github.io/vega-lite/docs/mark.html#hyperlink),\n[line mark](https://vega.github.io/vega-lite/docs/line.html#properties),\n[point mark](https://vega.github.io/vega-lite/docs/point.html#properties),\n[text mark](https://vega.github.io/vega-lite/docs/text.html) and\n[tick mark](https://vega.github.io/vega-lite/docs/tick.html#config)\nproperty documentation.\n\n@docs maAlign\n@docs maAngle\n@docs maBandSize\n@docs maBaseline\n@docs maBinSpacing\n@docs maBorders\n@docs maClip\n@docs maColor\n@docs maCursor\n@docs maExtent\n@docs maHRef\n@docs maContinuousBandSize\n@docs maDiscreteBandSize\n@docs maDx\n@docs maDy\n@docs maFill\n@docs maFilled\n@docs maFillOpacity\n@docs maFont\n@docs maFontSize\n@docs maFontStyle\n@docs maFontWeight\n@docs maInterpolate\n@docs maOpacity\n@docs maOrient\n@docs maPoint\n@docs maLine\n@docs maRadius\n@docs maRule\n@docs maShape\n@docs maShortTimeLabels\n@docs maSize\n@docs maStroke\n@docs maStrokeCap\n@docs caRound\n@docs caSquare\n@docs caButt\n@docs maStrokeDash\n@docs maStrokeDashOffset\n@docs maStrokeJoin\n@docs joRound\n@docs joBevel\n@docs joMiter\n@docs maStrokeMiterLimit\n@docs maStrokeOpacity\n@docs maStrokeWidth\n@docs maStyle\n@docs maTension\n@docs maText\n@docs maTheta\n@docs maThickness\n@docs maTicks\n@docs maTooltip\n@docs maXOffset\n@docs maYOffset\n@docs maX2Offset\n@docs maY2Offset\n\n\n### Used by Mark Properties\n\n@docs moHorizontal\n@docs moVertical\n@docs miBasis\n@docs miBasisOpen\n@docs miBasisClosed\n@docs miBundle\n@docs miCardinal\n@docs miCardinalOpen\n@docs miCardinalClosed\n@docs miLinear\n@docs miMonotone\n@docs miStepwise\n@docs miStepAfter\n@docs miStepBefore\n\n@docs symCircle\n@docs symCross\n@docs symDiamond\n@docs symSquare\n@docs symTriangleUp\n@docs symTriangleDown\n@docs symPath\n@docs pmNone\n@docs pmTransparent\n@docs pmMarker\n@docs lmMarker\n@docs lmNone\n@docs exRange\n@docs exCi\n@docs exIqr\n@docs exIqrScale\n@docs exStderr\n@docs exStdev\n@docs ttData\n@docs ttEncoding\n\n\n### Cursors\n\nSee the\n[CSS cursor documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Keyword%20values)\n\n@docs cuAuto\n@docs cuDefault\n@docs cuNone\n@docs cuContextMenu\n@docs cuHelp\n@docs cuPointer\n@docs cuProgress\n@docs cuWait\n@docs cuCell\n@docs cuCrosshair\n@docs cuText\n@docs cuVerticalText\n@docs cuAlias\n@docs cuCopy\n@docs cuMove\n@docs cuNoDrop\n@docs cuNotAllowed\n@docs cuAllScroll\n@docs cuColResize\n@docs cuRowResize\n@docs cuNResize\n@docs cuEResize\n@docs cuSResize\n@docs cuWResize\n@docs cuNEResize\n@docs cuNWResize\n@docs cuSEResize\n@docs cuSWResize\n@docs cuEWResize\n@docs cuNSResize\n@docs cuNESWResize\n@docs cuNWSEResize\n@docs cuZoomIn\n@docs cuZoomOut\n@docs cuGrab\n@docs cuGrabbing\n\n\n# Creating the Encoding Specification\n\nTypes and functions for declaring which data fields (data) are mapped to which channels\n(position, color etc.).\n\n@docs encoding\n@docs Measurement\n\n\n## Position channel\n\nRelates to where something appears in the visualization.\nSee the\n[Vega-Lite position documentation](https://vega.github.io/vega-lite/docs/encoding.html#position)\n\n@docs position\n@docs Position\n\n\n### Position Channel Properties\n\n@docs pName\n@docs pRepeat\n@docs pMType\n@docs pBin\n@docs pBinned\n@docs pTimeUnit\n@docs pTitle\n@docs pAggregate\n@docs pScale\n@docs pAxis\n@docs pSort\n@docs pStack\n@docs pWidth\n@docs pHeight\n@docs pImpute\n\n\n## Properties Used by Position Channels\n\n\n## Sorting Properties\n\nSee the\n[Vega-Lite sort documentation](https://vega.github.io/vega-lite/docs/sort.html).\n\n@docs soAscending\n@docs soDescending\n@docs soByField\n@docs soByRepeat\n@docs soCustom\n\n\n## Axis Properties\n\nSee the\n[Vega-Lite axis property documentation](https://vega.github.io/vega-lite/docs/axis.html#axis-properties)\n\n@docs axDomain\n@docs axFormat\n@docs axGrid\n@docs axLabelAngle\n@docs axLabelOverlap\n@docs axLabelPadding\n@docs axLabels\n@docs axMaxExtent\n@docs axMinExtent\n@docs axOffset\n@docs axOrient\n@docs axPosition\n\n@docs axBandPosition\n@docs axDates\n@docs axDomainColor\n@docs axDomainOpacity\n@docs axDomainWidth\n@docs axLabelAlign\n@docs axLabelBaseline\n@docs axLabelBound\n@docs axLabelColor\n@docs axLabelFlush\n@docs axLabelFlushOffset\n@docs axLabelFont\n@docs axLabelFontSize\n@docs axLabelFontWeight\n@docs axLabelLimit\n@docs axLabelOpacity\n@docs axTickColor\n@docs axTickCount\n@docs axTickExtra\n@docs axTickOffset\n@docs axTickOpacity\n@docs axTickRound\n@docs axTicks\n@docs axTickSize\n@docs axTickStep\n@docs axTickWidth\n@docs axTitle\n@docs axTitleAlign\n@docs axTitleAngle\n@docs axTitleBaseline\n@docs axTitleColor\n@docs axTitleFont\n@docs axTitleFontSize\n@docs axTitleFontWeight\n@docs axTitleLimit\n@docs axTitleOpacity\n@docs axTitlePadding\n@docs axTitleX\n@docs axTitleY\n@docs axValues\n@docs axZIndex\n\n\n## Positioning Constants\n\n\n### Text\n\n@docs haLeft\n@docs haCenter\n@docs haRight\n\n@docs vaTop\n@docs vaMiddle\n@docs vaBottom\n\n\n### Overlapping text\n\n@docs osNone\n@docs osGreedy\n@docs osParity\n\n\n### Legends\n\n@docs siTop\n@docs siBottom\n@docs siLeft\n@docs siRight\n\n\n## Mark channels\n\nRelate to the appearance of the visual marks in the visualization such as their\ncolor or size.\n\n@docs size\n@docs color\n@docs fill\n@docs stroke\n@docs opacity\n@docs shape\n\n\n### Mark Channel Properties\n\n@docs mName\n@docs mRepeat\n@docs mMType\n@docs mScale\n@docs mBin\n@docs mBinned\n@docs mImpute\n@docs mTimeUnit\n@docs mTitle\n@docs mAggregate\n@docs mLegend\n@docs mPath\n@docs mNum\n@docs mStr\n@docs mBoo\n\n\n### Mark Legends\n\nSee the\n[Vega-Lite legend property documentation](https://vega.github.io/vega-lite/docs/legend.html#legend-properties).\n\n@docs leGradient\n@docs leSymbol\n@docs leClipHeight\n@docs leColumnPadding\n@docs leColumns\n@docs leCornerRadius\n@docs leDirection\n@docs leFillColor\n@docs leFormat\n@docs leGradientLength\n@docs leGradientThickness\n@docs leGradientStrokeColor\n@docs leGradientStrokeWidth\n@docs leGridAlign\n@docs leLabelAlign\n@docs leLabelBaseline\n@docs leLabelColor\n@docs leLabelFont\n@docs leLabelFontSize\n@docs leLabelLimit\n@docs leLabelOffset\n@docs leLabelOverlap\n@docs leOffset\n@docs leOrient\n@docs lePadding\n@docs leRowPadding\n@docs leStrokeColor\n@docs leStrokeWidth\n@docs leSymbolFillColor\n@docs leSymbolSize\n@docs leSymbolStrokeColor\n@docs leSymbolStrokeWidth\n@docs leSymbolType\n@docs leTickCount\n@docs leTitle\n@docs leTitleAlign\n@docs leTitleBaseline\n@docs leTitleColor\n@docs leTitleFont\n@docs leTitleFontSize\n@docs leTitleFontWeight\n@docs leTitleLimit\n@docs leTitlePadding\n@docs leType\n@docs leValues\n@docs leZIndex\n\n@docs loLeft\n@docs loRight\n@docs loTopLeft\n@docs loTopRight\n@docs loBottomLeft\n@docs loBottomRight\n@docs loNone\n\n@docs leNums\n@docs leStrs\n@docs leDts\n\n\n## Text Channels\n\nRelate to the appearance of the text and tooltip elements of the visualization.\nSee the\n[Vega-Lite text documentation](https://vega.github.io/vega-lite/docs/encoding.html#text)\n\n@docs text\n@docs tooltip\n@docs tooltips\n@docs tName\n@docs tRepeat\n@docs tMType\n@docs tBin\n@docs tBinned\n@docs tAggregate\n@docs tTimeUnit\n@docs tTitle\n@docs tFormat\n@docs FontWeight\n\n\n## Hyperlink Channel\n\nRelates to a clickable URL destination of a mark. Unlike most other channels, the\nhyperlink channel has no direct visual expression other than the option of changing\nthe cursor style when hovering, so an encoding will usually pair hyperlinks with\nother visual channels such as marks or texts. See the\n[Vega-Lite hyperlink documentation](https://vega.github.io/vega-lite/docs/encoding.html#href)\n\n@docs hyperlink\n@docs hName\n@docs hRepeat\n@docs hMType\n@docs hBin\n@docs hBinned\n@docs hAggregate\n@docs hTimeUnit\n@docs hStr\n\n\n## Order channels\n\nChannels that relate to the order of data fields such as for sorting stacking order\nor order of data points in a connected scatterplot. See the\n[Vega-Lite order documentation](https://vega.github.io/vega-lite/docs/encoding.html#order).\n\n@docs order\n@docs oName\n@docs oRepeat\n@docs oMType\n@docs oBin\n@docs oAggregate\n@docs oSort\n@docs oTimeUnit\n\n\n## Facet channels\n\nChannels for faceting single plots into small multiples. Can be used to create\ntrellis plots or other arrangements in rows and columns. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/encoding.html#facet).\nSee also, 'faceted view composition' for a more flexible (but more verbose) way\nof defining faceted views.\n\n@docs row\n@docs column\n\n\n## Level of detail Channel\n\nUsed for grouping data but without changing the visual appearance of a mark. When,\nfor example, a field is encoded by color, all data items with the same value for\nthat field are given the same color. When a detail channel encodes a field, all\ndata items with the same value are placed in the same group. See the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/encoding.html#detail).\n\n@docs detail\n@docs dName\n@docs dMType\n@docs dAggregate\n@docs dBin\n@docs dImpute\n@docs dTimeUnit\n\n\n## Scaling\n\nUsed to specify how the encoding of a data field should be applied. See the\n[Vega-Lite scale documentation](https://vega.github.io/vega-lite/docs/scale.html).\n\n@docs scType\n@docs scDomain\n@docs scRange\n@docs scScheme\n@docs scPadding\n@docs scPaddingInner\n@docs scPaddingOuter\n@docs scRangeStep\n@docs scRound\n@docs scClamp\n@docs scInterpolate\n@docs scNice\n@docs scZero\n@docs scReverse\n@docs scBand\n@docs scBinLinear\n@docs scBinOrdinal\n@docs scLinear\n@docs scLog\n@docs scOrdinal\n@docs scPoint\n@docs scPow\n@docs scQuantile\n@docs scQuantize\n@docs scSequential\n@docs scSqrt\n@docs scThreshold\n@docs scTime\n@docs scUtc\n\n@docs raName\n@docs raNums\n@docs raStrs\n@docs categoricalDomainMap\n@docs domainRangeMap\n@docs doNums\n@docs doStrs\n@docs doDts\n@docs doUnaggregated\n@docs doSelection\n\n@docs niTrue\n@docs niFalse\n@docs niMillisecond\n@docs niSecond\n@docs niMinute\n@docs niHour\n@docs niDay\n@docs niWeek\n@docs niMonth\n@docs niYear\n@docs niTickCount\n@docs niInterval\n\n\n### Color Scaling\n\nFor color interpolation types, see the\n[Vega-Lite continuous scale documentation](https://vega.github.io/vega-lite/docs/scale.html#continuous).\n\n@docs cubeHelix\n@docs cubeHelixLong\n@docs hcl\n@docs hclLong\n@docs hsl\n@docs hslLong\n@docs lab\n@docs rgb\n\n\n# Creating view compositions\n\nViews can be combined to create more complex multiview displays. This may involve\nlayering views on top of each other (superposition) or laying them out in adjacent\nspaces (juxtaposition using `repeat`, `facet`, `hConcat` or `vConcat`). Where different\nviews have potentially conflicting channels (e.g. two position scales in a layered\nvisualization) the rules for resolving them can be defined with `resolve`.\nSee the\n[Vega-Lite composition documentation](https://vega.github.io/vega-lite/docs/composition.html)\n\n@docs layer\n@docs hConcat\n@docs vConcat\n@docs align\n@docs alignRC\n@docs caAll\n@docs caEach\n@docs caNone\n@docs bounds\n@docs boFull\n@docs boFlush\n@docs spacing\n@docs spacingRC\n@docs center\n@docs centerRC\n\n\n## Resolution\n\nControlling the (in)dependence between composed views. See the\n[Vega-Lite resolve documentation](https://vega.github.io/vega-lite/docs/resolve.html).\n\n@docs resolve\n@docs resolution\n@docs reShared\n@docs reIndependent\n@docs reAxis\n@docs reLegend\n@docs reScale\n@docs chX\n@docs chY\n@docs chX2\n@docs chY2\n@docs chColor\n@docs chOpacity\n@docs chShape\n@docs chSize\n\n\n## Faceted views\n\nSmall multiples each of which show subsets of the same dataset. The specification\ndetermines which field should be used to determine subsets along with their spatial\narrangement. See the\n[Vega-Lite facet documentation](https://vega.github.io/vega-lite/docs/facet.html)\n\n@docs repeat\n@docs rowFields\n@docs columnFields\n@docs facet\n@docs columnBy\n@docs rowBy\n\n@docs fName\n@docs fMType\n@docs fAggregate\n@docs fBin\n@docs fHeader\n@docs fTimeUnit\n\n@docs asSpec\n@docs specification\n@docs arColumn\n@docs arRow\n\n\n### Facet Headers\n\nSee\n[Vega-Lite header documentation](https://vega.github.io/vega-lite/docs/header.html)\n\n@docs hdLabelAngle\n@docs hdLabelColor\n@docs hdLabelFont\n@docs hdLabelFontSize\n@docs hdLabelLimit\n@docs hdLabelPadding\n\n@docs hdTitle\n@docs hdTitleAnchor\n@docs hdTitleAngle\n@docs hdTitleBaseline\n@docs hdTitleColor\n@docs hdTitleFont\n@docs hdTitleFontWeight\n@docs hdTitleFontSize\n@docs hdTitleLimit\n@docs hdTitlePadding\n\n@docs hdFormat\n\n\n# Creating Selections for Interaction\n\nSelections allow a visualization to respond to interactions (such as clicking or\ndragging). They transform interactions into data queries. See the Vega-Lite\n[selection](https://vega.github.io/vega-lite/docs/selection.html) and\n[bind](https://vega.github.io/vega-lite/docs/bind.html)\ndocumentation.\n\n@docs selection\n@docs select\n@docs seSingle\n@docs seMulti\n@docs seInterval\n@docs seEmpty\n@docs seBind\n@docs seBindScales\n@docs seEncodings\n@docs seFields\n@docs seNearest\n@docs seOn\n@docs seResolve\n@docs seSelectionMark\n@docs seToggle\n@docs seTranslate\n@docs seZoom\n\n@docs iRange\n@docs iCheckbox\n@docs iRadio\n@docs iSelect\n@docs iText\n@docs iNumber\n@docs iDate\n@docs iTime\n@docs iMonth\n@docs iWeek\n@docs iDateTimeLocal\n@docs iTel\n@docs iColor\n\n@docs inDebounce\n@docs inElement\n@docs inOptions\n@docs inMin\n@docs inMax\n@docs inName\n@docs inStep\n@docs inPlaceholder\n\n@docs smFill\n@docs smFillOpacity\n@docs smStroke\n@docs smStrokeDash\n@docs smStrokeDashOffset\n@docs smStrokeOpacity\n@docs smStrokeWidth\n\n\n## Selection Resolution\n\nDetermines how selections are made across multiple views.\nSee the [Vega-lite resolve selection documentation](https://vega.github.io/vega-lite/docs/selection.html#resolve).\n\n@docs seGlobal\n@docs seUnion\n@docs seIntersection\n\n\n## Making conditional channel encodings\n\nTo make channel encoding conditional on the result of some interaction, use\n[mSelectionCondition](#mSelectionCondition) (and its 't' and 'h' variants). Similarly\n[mDataCondition](#mDataCondition) (and its 't' and 'h' variants) will encode a mark\nconditionally depending on some data properties such as whether a datum is null\nor an outlier.\n\nFor interaction, once a selection has been defined and named, supplying a set of\nencodings allow mark encodings to become dependent on that selection.\n`mSelectionCondition` is followed firstly a (Boolean) selection and then an\nencoding if that selection is true and another encoding to be applied if it is false.\nThe color specification below states \"whenever data marks are selected with an\ninterval mouse drag, encode the cylinder field with an ordinal color scheme,\notherwise make them grey\":\n\n    sel =\n        selection << select \"myBrush\" Interval []\n\n    enc =\n        encoding\n            << position X [ pName \"Horsepower\", pMType Quantitative ]\n            << position Y [ pName \"Miles_per_Gallon\", pMType Quantitative ]\n            << color\n                [ mSelectionCondition (selectionName \"myBrush\")\n                    [ mName \"Cylinders\", mMType Ordinal ]\n                    [ mStr \"grey\" ]\n                ]\n\nIn a similar way, `mDataCondition` will encode a mark depending on whether any\npredicate tests are satisfied. Unlike selections, multiple conditions and associated\nencodings can be specified. Each test condition is evaluated in order and only on\nfailure of the test does encoding proceed to the next test. If no tests are true,\nthe encoding in the final parameter is applied in a similar way to 'case of'\nexpressions:\n\n    enc =\n        encoding\n            << position X [ pName \"value\", pMType Ordinal ]\n            << color\n                [ mDataCondition\n                    [ ( expr \"datum.value < 40\", [ mStr \"blue\" ] )\n                    , ( expr \"datum.value < 50\", [ mStr \"red\" ] )\n                    , ( expr \"datum.value < 60\", [ mStr \"yellow\" ] )\n                    ]\n                    [ mStr \"black\" ]\n                ]\n\nSee the\n[Vega-Lite documentation](https://vega.github.io/vega-lite/docs/condition.html).\n\n@docs mSelectionCondition\n@docs mDataCondition\n@docs tSelectionCondition\n@docs tDataCondition\n@docs hDataCondition\n@docs hSelectionCondition\n\n@docs and\n@docs or\n@docs not\n@docs expr\n@docs selected\n@docs selectionName\n\n\n# Global Configuration\n\nConfiguration options that affect the entire visualization. These are in addition\nto the data and transform options described above. See the\n[Vega-Lite top-level spec documentation](https://vega.github.io/vega-lite/docs/spec.html#top-level-specifications)\n\n@docs name\n@docs title\n@docs description\n@docs height\n@docs width\n@docs padding\n@docs paSize\n@docs paEdges\n@docs autosize\n@docs asContent\n@docs asFit\n@docs asNone\n@docs asPad\n@docs asPadding\n@docs asResize\n@docs background\n\n\n## Style Setting\n\nAllows default properties for most marks and guides to be set. See the\n[Vega-Lite configuration documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n@docs configure\n@docs configuration\n\n@docs coArea\n@docs coAutosize\n@docs coAxis\n@docs coAxisX\n@docs coAxisY\n@docs coAxisLeft\n@docs coAxisRight\n@docs coAxisTop\n@docs coAxisBottom\n@docs coAxisBand\n@docs coBackground\n@docs coBar\n@docs coCircle\n@docs coCountTitle\n@docs coFieldTitle\n@docs coGeoshape\n@docs coLegend\n@docs coLine\n@docs coHeader\n@docs coMark\n@docs coNamedStyle\n@docs coNumberFormat\n@docs coPadding\n@docs coPoint\n@docs coProjection\n@docs coRange\n@docs coRect\n@docs coRemoveInvalid\n@docs coRule\n@docs coScale\n@docs coSelection\n@docs coSquare\n@docs coStack\n@docs coText\n@docs coTick\n@docs coTitle\n@docs coTimeFormat\n@docs coTrail\n@docs coView\n\n\n## Axis Configuration Options\n\nSee the\n[Vega-Lite axis config documentation](https://vega.github.io/vega-lite/docs/axis.html#general-config).\n\n@docs axcoBandPosition\n@docs axcoDomain\n@docs axcoDomainColor\n@docs axcoDomainOpacity\n@docs axcoDomainWidth\n@docs axcoMaxExtent\n@docs axcoMinExtent\n@docs axcoGrid\n@docs axcoGridColor\n@docs axcoGridDash\n@docs axcoGridOpacity\n@docs axcoGridWidth\n@docs axcoLabels\n@docs axcoLabelAlign\n@docs axcoLabelAngle\n@docs axcoLabelBaseline\n@docs axcoLabelBound\n@docs axcoLabelColor\n@docs axcoLabelFlush\n@docs axcoLabelFlushOffset\n@docs axcoLabelFontWeight\n@docs axcoLabelFont\n@docs axcoLabelFontSize\n@docs axcoLabelLimit\n@docs axcoLabelOpacity\n@docs axcoLabelOverlap\n@docs axcoLabelPadding\n@docs axcoShortTimeLabels\n@docs axcoTicks\n@docs axcoTickColor\n@docs axcoTickExtra\n@docs axcoTickOffset\n@docs axcoTickOpacity\n@docs axcoTickRound\n@docs axcoTickSize\n@docs axcoTickStep\n@docs axcoTickWidth\n@docs axcoTitleAlign\n@docs axcoTitleAngle\n@docs axcoTitleBaseline\n@docs axcoTitleColor\n@docs axcoTitleFont\n@docs axcoTitleFontWeight\n@docs axcoTitleFontSize\n@docs axcoTitleLimit\n@docs axcoTitleOpacity\n@docs axcoTitlePadding\n@docs axcoTitleX\n@docs axcoTitleY\n\n\n## Legend Configuration Options\n\nSee the\n[Vega-Lite legend configuration documentation](https://vega.github.io/vega-lite/docs/legend.html#config).\n\n@docs lecoClipHeight\n@docs lecoColumnPadding\n@docs lecoColumns\n@docs lecoCornerRadius\n@docs lecoFillColor\n@docs lecoOrient\n@docs lecoOffset\n@docs lecoStrokeColor\n@docs lecoStrokeDash\n@docs lecoStrokeWidth\n@docs lecoPadding\n@docs lecoRowPadding\n@docs lecoGradientDirection\n@docs lecoGradientLabelBaseline\n@docs lecoGradientLabelLimit\n@docs lecoGradientLabelOffset\n@docs lecoGradientStrokeColor\n@docs lecoGradientStrokeWidth\n@docs lecoGradientHeight\n@docs lecoGradientWidth\n@docs lecoGridAlign\n@docs lecoLabelAlign\n@docs lecoLabelBaseline\n@docs lecoLabelColor\n@docs lecoLabelFont\n@docs lecoLabelFontSize\n@docs lecoLabelLimit\n@docs lecoLabelOffset\n@docs lecoLabelOverlap\n@docs lecoShortTimeLabels\n@docs lecoEntryPadding\n@docs lecoSymbolBaseFillColor\n@docs lecoSymbolBaseStrokeColor\n@docs lecoSymbolDirection\n@docs lecoSymbolFillColor\n@docs lecoSymbolOffset\n@docs lecoSymbolSize\n@docs lecoSymbolStrokeColor\n@docs lecoSymbolStrokeWidth\n@docs lecoSymbolType\n@docs lecoTitleAlign\n@docs lecoTitleBaseline\n@docs lecoTitleColor\n@docs lecoTitleFont\n@docs lecoTitleFontSize\n@docs lecoTitleFontWeight\n@docs lecoTitleLimit\n@docs lecoTitlePadding\n\n\n## Scale Configuration Options\n\nSee the\n[Vega-Lite scale configuration documentation](https://vega.github.io/vega-lite/docs/scale.html#scale-config)\n\n@docs sacoBandPaddingInner\n@docs sacoBandPaddingOuter\n@docs sacoClamp\n@docs sacoMaxBandSize\n@docs sacoMinBandSize\n@docs sacoMaxFontSize\n@docs sacoMinFontSize\n@docs sacoMaxOpacity\n@docs sacoMinOpacity\n@docs sacoMaxSize\n@docs sacoMinSize\n@docs sacoMaxStrokeWidth\n@docs sacoMinStrokeWidth\n@docs sacoPointPadding\n@docs sacoRangeStep\n@docs sacoRound\n@docs sacoTextXRangeStep\n@docs sacoUseUnaggregatedDomain\n\n\n## Scale Range Configuration Options\n\nSee the\n[Vega-Lite scheme configuration documentation](https://vega.github.io/vega/docs/schemes/#scheme-properties).\n\n@docs racoCategory\n@docs racoDiverging\n@docs racoHeatmap\n@docs racoOrdinal\n@docs racoRamp\n@docs racoSymbol\n\n\n## Title Configuration Options\n\nSee the\n[Vega-Lite title configuration documentation](https://vega.github.io/vega-lite/docs/title.html#config)\n\n@docs ticoAnchor\n@docs ticoAngle\n@docs ticoBaseline\n@docs ticoColor\n@docs ticoFont\n@docs ticoFontSize\n@docs ticoFontWeight\n@docs ticoLimit\n@docs ticoOffset\n@docs ticoOrient\n\n\n## View Configuration Options\n\nSee the\n[Vega-Lite view configuration documentation](https://vega.github.io/vega-lite/docs/spec.html#config)\n\n@docs vicoWidth\n@docs vicoHeight\n@docs vicoClip\n@docs vicoFill\n@docs vicoFillOpacity\n@docs vicoStroke\n@docs vicoStrokeOpacity\n@docs vicoStrokeWidth\n@docs vicoStrokeDash\n@docs vicoStrokeDashOffset\n\n@docs anStart\n@docs anMiddle\n@docs anEnd\n\n@docs ftVerbal\n@docs ftFunction\n@docs ftPlain\n\n\n# General Data functions\n\nIn addition to more general data types like integers and string, the following types\ncan carry data used in specifications.\n\n@docs boo\n@docs true\n@docs false\n@docs dt\n@docs num\n@docs str\n@docs boos\n@docs dts\n@docs nums\n@docs strs\n\n\n## Temporal Data\n\nSee the\n[Vega-Lite dateTime documentation](https://vega.github.io/vega-lite/docs/types.html#datetime)\nand the [Vega-Lite time unit documentation](https://vega.github.io/vega-lite/docs/timeunit.html).\n\n@docs dtYear\n@docs dtQuarter\n@docs dtMonth\n@docs dtDate\n@docs dtDay\n@docs dtHour\n@docs dtMinute\n@docs dtSecond\n@docs dtMillisecond\n@docs MonthName\n@docs DayName\n\n@docs date\n@docs day\n@docs hours\n@docs hoursMinutes\n@docs hoursMinutesSeconds\n@docs milliseconds\n@docs minutes\n@docs minutesSeconds\n@docs month\n@docs monthDate\n@docs quarter\n@docs quarterMonth\n@docs seconds\n@docs secondsMilliseconds\n@docs year\n@docs yearQuarter\n@docs yearQuarterMonth\n@docs yearMonth\n@docs yearMonthDate\n@docs yearMonthDateHours\n@docs yearMonthDateHoursMinutes\n@docs yearMonthDateHoursMinutesSeconds\n@docs utc\n\n---\n\n\n# Type Reference\n\nTypes that are not specified directly, provided here for reference with links\nto the functions that generate them.\n\n@docs Anchor\n@docs Arrangement\n@docs Autosize\n@docs AxisProperty\n@docs AxisConfig\n@docs Binding\n@docs BinProperty\n@docs BooleanOp\n@docs Bounds\n@docs CInterpolate\n@docs Channel\n@docs ClipRect\n@docs CompositionAlignment\n@docs ConfigurationProperty\n@docs Cursor\n@docs DataType\n@docs DataValue\n@docs DataValues\n@docs DateTime\n@docs DetailChannel\n@docs FacetChannel\n@docs FacetMapping\n@docs FieldTitleProperty\n@docs Filter\n@docs FilterRange\n@docs Format\n@docs Geometry\n@docs HAlign\n@docs ImMethod\n@docs InputProperty\n@docs HeaderProperty\n@docs HyperlinkChannel\n@docs ImputeProperty\n@docs Legend\n@docs LegendConfig\n@docs LegendOrientation\n@docs LegendProperty\n@docs LegendValues\n@docs LineMarker\n@docs Mark\n@docs MarkChannel\n@docs MarkInterpolation\n@docs MarkOrientation\n@docs MarkProperty\n@docs Operation\n@docs OrderChannel\n@docs OverlapStrategy\n@docs Padding\n@docs PointMarker\n@docs PositionChannel\n@docs Projection\n@docs ProjectionProperty\n@docs RangeConfig\n@docs RepeatFields\n@docs Resolution\n@docs Resolve\n@docs Scale\n@docs ScaleDomain\n@docs ScaleNice\n@docs ScaleProperty\n@docs ScaleConfig\n@docs ScaleRange\n@docs Selection\n@docs SelectionMarkProperty\n@docs SelectionProperty\n@docs SelectionResolution\n@docs Side\n@docs SortField\n@docs SortProperty\n@docs StackOffset\n@docs StackProperty\n@docs StrokeCap\n@docs StrokeJoin\n@docs SummaryExtent\n@docs Symbol\n@docs TextChannel\n@docs TimeUnit\n@docs TitleConfig\n@docs TooltipContent\n@docs VAlign\n@docs ViewConfig\n@docs Window\n@docs WOperation\n@docs WindowProperty\n\n","unions":[{"name":"Anchor","comment":" Generated by [anStart](#anStart), [anMiddle](#anMiddle) and [anEnd](#anEnd).\n","args":[],"cases":[]},{"name":"Arrangement","comment":" Generated by [arColumn](#arColumn) and [arRow](#arRow).\n","args":[],"cases":[]},{"name":"Autosize","comment":" Generated by [asContent](#asContent), [asFit](#asFit), [asNone](#asNone),\n[asPad](#asPad), [asPadding](#asPadding) and [asResize](#asReeize).\n","args":[],"cases":[]},{"name":"AxisConfig","comment":" Generated by functions prefixed with `axco`.\n","args":[],"cases":[]},{"name":"AxisProperty","comment":" Generated by functions prefixed with `ax`, for example [axBandPosition](#axBandPosition).\n","args":[],"cases":[]},{"name":"BinProperty","comment":" Generated by [biBase](#biBase), [biDivide](#biDivide), [biExtent](#biExtent),\n[biMaxBins](#biMaxBins), [biMinStep](#biMinStep), [biNice](#biNice),\n[biStep](#biStep) and [biSteps](#biSteps).\n","args":[],"cases":[]},{"name":"Binding","comment":" Generated by [iRange](#iRange), [iCheckbox](#iCheckbox),\n[iRadio](#iRadio), [iSelect](#iSelect), [iText](#iText), [iNumber](#iNumber),\n[iDate](#iDate), [iTime](#iTime), [iMonth](#iMonth), [iWeek](#iWeek), [iDateTimeLocal](#iDateTimeLocal),\n[iTel](#iTel) and [iColor](#iColor).\n","args":[],"cases":[]},{"name":"BooleanOp","comment":" Generated by [expr](#expr), [selected](#selected),\n[selectionName](#selectionName), [and](#and), [or](#or) and [not](#not).\n","args":[],"cases":[]},{"name":"Bounds","comment":" Generated by [boFull](#boFull) and [boFlush](#boFlush).\n","args":[],"cases":[]},{"name":"CInterpolate","comment":" Generated by [cubeHelix](#cubeHelix), [cubeHelixLong](#cubeHelixLong), [hcl](#hcl),\n[hclLong](#hclLong), [hsl](#hsl), [hslLong](#hslLong), [lab](#lab) and [rgb](#rgb).\n","args":[],"cases":[]},{"name":"Channel","comment":" Generated by [chX](#chX), [chY](#chY), [chX2](#chX2), [chY2](#chY2),\n[chColor](#chColor), [chOpacity](#chOpacity), [chShape](#chShape) and [chSize](#chSize).\n","args":[],"cases":[]},{"name":"ClipRect","comment":" Generated by [noClip](#noClip) and [clipRect](#clipRect).\n","args":[],"cases":[]},{"name":"CompositionAlignment","comment":" Generated by [caNone](#caNone), [caEach](#caEach) and [caAll](#caAll).\n","args":[],"cases":[]},{"name":"ConfigurationProperty","comment":" Generated with [coArea](#coArea), [coAutosize](#coAutosize), [coAxis](#coAxis),\n[coAxisX](#coAxisX), [coAxisY](#coAxisY), [coAxisLeft](#coAxisLeft),\n[coAxisRight](#coAxisRight), [coAxisTop](#coAxisTop),\n[coAxisBottom](#coAxisBottom), [coAxisBand](#coAxisBand), [coBackground](#coBackground),\n[coBar](#coBar), [coCircle](#coCircle), [coCountTitle](#coCountTitle), [coFieldTitle](#coFieldTitle),\n[coGeoshape](#coGeoshape), [coHeader](#coHeader), [coLegend](#coLegend), [coLine](#coLine),\n[coMark](#coMark), [coNamedStyle](#coNamedStyle), [coNumberFormat](#coNumberFormat),\n[coPadding](#coPadding), [coPoint](#coPoint), [coProjection](#coProjection),\n[coRange](#coRange), [coRect](#coRect), [coRemoveInvalid](#coRemoveInvalid),\n[coRule](#coRule), [coScale](#coScale), [coSelection](#coSelection),\n[coSquare](#coSquare), [coStack](#coStack), [coText](#coText), [coTick](#coTick),\n[coTitle](#coTitle), [coTimeFormat](#coTimeFormat), [coTrail](#coTrail) and [coView](#coView).\n","args":[],"cases":[]},{"name":"Cursor","comment":" Generated by functions that start with `cu`.\n","args":[],"cases":[]},{"name":"DataType","comment":" Generated by [foBoo](#foBoo), [foNum](#foNum), [foDate](#FoDate) and [foUtc](#foUtc).\n","args":[],"cases":[]},{"name":"DataValue","comment":" Generated by [boo](#boo), [true](#true), [false](#false), [dt](#dt),\n[num](#num) and [str](#str).\n","args":[],"cases":[]},{"name":"DataValues","comment":" Generated by [boos](#boos), [dts](#dts), [nums](#nums) and [strs](#strs).\n","args":[],"cases":[]},{"name":"DateTime","comment":" Generated by [dtYear](#dtYear), [dtQuarter](#dtQuarter), [dtMonth](#dtMonth),\n[dtDate](#DTDate), [dtDay](#dtDay), [dtHour](#dtHour), [dtMinute](#dtMinute),\n[dtSecond](#dtSecond) and [dtMillisecond](#dtMillisecond).\n","args":[],"cases":[]},{"name":"DayName","comment":" Day of the week.\n","args":[],"cases":[["Mon",[]],["Tue",[]],["Wed",[]],["Thu",[]],["Fri",[]],["Sat",[]],["Sun",[]]]},{"name":"DetailChannel","comment":" Generated by [dName](#dName), [dMType](#dMType), [dAggregate](#dAggregate),\n[dBin](#dBin), [dImpute](#dImpute) and [dTimeUnit](#dTimeUnit).\n","args":[],"cases":[]},{"name":"FacetChannel","comment":" Generated by [fName](#fName), [fMType](#fMType), [fAggregate](#fAggregate),\n[fBin](#fBin), [fHeader](#fHeader) and [fTimeUnit](#fTimeUnit).\n","args":[],"cases":[]},{"name":"FacetMapping","comment":" Generated by [columnBy](#columnBy) and [rowBy](#rowBy).\n","args":[],"cases":[]},{"name":"FieldTitleProperty","comment":" Generated by [ftVerbal](#ftVerbal), [ftFunction](#ftFunction) and [ftPlain](#ftPlain).\n","args":[],"cases":[]},{"name":"Filter","comment":" Generated by [fiEqual](#fiEqual), [fiLessThan](#fiLessThan),\n[fiLessThanEq](#fiLessThanEq), [fiGreaterThan](#fiEqGreaterThan),\n[fiGreaterThanEq](#fiGreaterThanEq), [fiExpr](#fiExpr), [fiCompose](#fiCompose),\n[fiSelection](#fiSelection), [fiOneOf](#fiOneOf), [fiRange](#fiRange) and\n[fiValid](#fiValid).\n","args":[],"cases":[]},{"name":"FilterRange","comment":" Generated by [numRange](#numRange) and [dtRange](#dtRange).\n","args":[],"cases":[]},{"name":"FontWeight","comment":" Weight options for a font.\n","args":[],"cases":[["Bold",[]],["Bolder",[]],["Lighter",[]],["Normal",[]],["W100",[]],["W200",[]],["W300",[]],["W400",[]],["W500",[]],["W600",[]],["W700",[]],["W800",[]],["W900",[]]]},{"name":"Format","comment":" Generated by [csv](#csv), [dsv](#dsv), [tsv](#tsv), [parse](#parse),\n[jsonProperty](#jsonProperty), [topojsonFeature](#topojsonFeature) and\n[topojsonMesh](#topojsonMesh).\n","args":[],"cases":[]},{"name":"Geometry","comment":" Generated by [geoPoint](#geoPoint), [geoPoints](#geoPoints),\n[geoLine](#geoLine), [geoLines](#geoLines), [geoPolygon](#geoPolygon) and\n[geoPolygons](#geoPolygons).\n","args":[],"cases":[]},{"name":"HAlign","comment":" Generated by [haLeft](#haLeft), [haCenter](#haCenter) and [haRight](#haRight).\n","args":[],"cases":[]},{"name":"HeaderProperty","comment":" Generated by [hdFormat](#hdFormat), [hdLabelAngle](#hdLabelAngle),\n[hdLabelColor](#hdLabelColor), [hdLabelFont](#hdLabelFont), [hdLabelFontSize](#hdLabelFontSize),\n[hdLabelLimit](#hdLabelLimit), [hdLabelPadding](#hdLabelPadding), [hdTitle](#hdTitle),\n[hdTitleAnchor](#hdTitleAnchor), [hdTitleAngle](#hdTitleAngle),\n[hdTitleBaseline](#hdTitleBaseline), [hdTitleColor](#hdTitleColor),\n[hdTitleFont](#hdTitleFont),[hdTitleFontWeight](#hdTitleFontWeight),\n[hdTitleFontSize](#hdTitleFontSize), [hdTitleLimit](#hdTitleLimit) and\n[hdTitlePadding](#hdTitlePadding).\n","args":[],"cases":[]},{"name":"HyperlinkChannel","comment":" Generated by [hName](#hName), [hRepeat](#hRepeat), [hMType](#hMType), [hBin](#hBin),\n[hBinned](#hBinned), [hAggregate](#hAggregate), [hTimeUnit](#hTimeUnit),\n[hDataCondition](#hDataCondition), [hSelectionCondition](#hSelectionCondition)\nand [hStr](#hStr).\n","args":[],"cases":[]},{"name":"ImMethod","comment":" The imputation method to use when replacing values.\n","args":[],"cases":[]},{"name":"ImputeProperty","comment":" Generated by [imKeyVals](#imKeyVals), [imKeyValSequence](#imKeyValSequence)\n[imFrame](#imFrame), [imGroupBy](#imGroupBy), [imMethod](#imMethod) and [imValue](#imValue).\n","args":[],"cases":[]},{"name":"InputProperty","comment":" Generated by [inDebounce](#inDebounce), [inElement](#inElement),\n[inOptions](#inOptions), [inMin](#inMin), [inMax](#inMax), [inName](#inName),\n[inStep](#inStep) and [inPlaceholder](#inPlaceholder).\n","args":[],"cases":[]},{"name":"Legend","comment":" Generated by [leGradient](#leGradient) and [leSymbol](#leSymbol).\n","args":[],"cases":[]},{"name":"LegendConfig","comment":" Generated by functions prefixed with `leco`.\n","args":[],"cases":[]},{"name":"LegendOrientation","comment":" Generated by [loLeft](#loLeft), [loTopLeft](#loTopLeft), [loTopRight](#loTopRight),\n[loRight](#loRight), [loBottomRight](#loBottomRight), [loBottomLeft](#loBottomLeft)\nand [loNone](#loNone).\n","args":[],"cases":[]},{"name":"LegendProperty","comment":" Generated by functions prefied with `le`. For example [leCornerRadius](#leCornerRadius).\n","args":[],"cases":[]},{"name":"LegendValues","comment":" Generated by [leNums](#leNums), [leStrs](#leStrs) and [leDts](#leDts).\n","args":[],"cases":[]},{"name":"LineMarker","comment":" Appearance of a line marker that is overlaid on to an area mark.\nAlso generated by [lmLine](#lmLine).\n","args":[],"cases":[]},{"name":"Mark","comment":" Generated by\n[area](#area), [bar](#bar), [boxplot](#boxplot), [circle](#circle), [errorband](#errorband),\n[errorbar](#errorbar), [geoshape](#geoshape), [line](#line), [point](#point), [rect](#rect),\n[rule](#rule),[square](#square), [textMark](#textMark), [tick](#tick) and [trail](#trail).\n","args":[],"cases":[]},{"name":"MarkChannel","comment":" Generated by [mName](#mName), [mRepeat](#mRepeat), [mMType](#mMType), [mScale](#mScale),\n[mBin](#mBin), [mBinned](#mBinned), [mImpute](#mImpute)[mTimeUnit](#mTimeUnit),\n[mTitle](#mTitle), [mAggregate](#mAggregate), [mLegend](#mLegend),\n[mSelectionCondition](#mSelectionCondition), [mDataCondition](#mDataCondition),\n[mPath](#mPath), [mNum](#mNum), [mStr](#mStr) and [mBoo](#mBoo).\n","args":[],"cases":[]},{"name":"MarkInterpolation","comment":" Generated by [miBasis](#miBasis), [miBasisClosed](#miBasisClosed),\n[miBasisOpen](#miBasisOpen), [miBundle](#miBundle), [miCardinal](#miCardinal),\n[miCardinalClosed](#miCardinalClosed), [miCardinalOpen](#miCardinalOpen),\n[miLinear](#miLinear), [miLinearClosed](#miLinearClosed), [miMonotone](#miMonotone),\n[miStepwise](#miStepwise), [miStepAfter](#miStepAfter) and [miStepBefore](#miStepBefore).\n","args":[],"cases":[]},{"name":"MarkOrientation","comment":" Generated by [moHorizontal](#moHorizontal) and [moVertical](#moVertical).\n","args":[],"cases":[]},{"name":"MarkProperty","comment":" Generated by [maAlign](#maAlign), [maAngle](#maAngle), [maBandSize](#maBandSize),\n[maBaseline](#maBaseline), [maBinSpacing](#maBinSpacing), [maBorders](#maBorders),\n[maClip](#maClip), [maColor](#maColor), [maCursor](#maCursor), [maHRef](#maHRef),\n[maContinuousBandSize](#maContinuousBandSize), [maDiscreteBandSize](#maDiscreteBandSize),\n[maDx](#maDx), [maDy](#maDy), [maExtent](#maExtent), [maFill](#maFill), [maFilled](#maFilled),\n[maFillOpacity](#maFillOpacity), [maFont](#maFont), [maFontSize](#maFontSize),\n[maFontStyle](#maFontStyle), [maFontWeight](#maFontWeight), [maInterpolate](#maInterpolate),\n[maLine](#maLine), [maOpacity](#maOpacity), [maOrient](#maOrient), [maPoint](#maPoint),\n[maRadius](#maRadius), [maRule](#maRule), [maShape](#maShape), [maShortTimeLabels](#maShortTimeLabels),\n[maSize](#maSize), [maStroke](#maStroke), [maStrokeCap](#maStrokeCap), [maStrokeDash](#maStrokeDash),\n[maStrokeDashOffset](#maStrokeDashOffset), [maStrokeJoin](#maStrokeJoin),\n[maStrokeMiterLimit](#maStrokeMiterLimit), [maStrokeOpacity](#maStrokeOpacity),\n[maStrokeWidth](#maStrokeWidth), [maStyle](#maStyle), [maTension](#maTension),\n[maText](#maText), [maTheta](#maTheta), [maThickness](#maThickness), [maTicks](#maTicks),\n[maTooltip](#maTooltip), [maXOffset](#maXOffset), [maYOffset](#maYOffset),\n[maX2Offset](#maX2Offset) and [maY2Offset](#maY2Offset).\n","args":[],"cases":[]},{"name":"Measurement","comment":" Type of measurement to be associated with some channel.\n","args":[],"cases":[["Nominal",[]],["Ordinal",[]],["Quantitative",[]],["Temporal",[]],["GeoFeature",[]]]},{"name":"MonthName","comment":" Idntifies a month of the year.\n","args":[],"cases":[["Jan",[]],["Feb",[]],["Mar",[]],["Apr",[]],["May",[]],["Jun",[]],["Jul",[]],["Aug",[]],["Sep",[]],["Oct",[]],["Nov",[]],["Dec",[]]]},{"name":"Operation","comment":" Generated by [opArgMax](#opArgMax), [opArgMin](#opArgMin), [opCI0](#opCI0),\n[opCI1](#opCI1), [opCount](#opCount), [opDistinct](#opDistinct), [opMax](#opMax),\n[opMean](#opMean), [opMedian](#opMedian), [opMin](#opMin), [opMissing](#opMissing),\n[opQ1](#opQ1), [opQ3](#opQ3), [opStderr](#opStderr), [opStdev](#opStdev),\n[opStdevP](#opStdevP), [opSum](#opSum), [opValid](#opValid),\n[opVariance](#opVariance) and [opVarianceP](#opVarianceP).\n","args":[],"cases":[]},{"name":"OrderChannel","comment":" Generated by [OName](#oName), [oRepeat](#oRepeat), [oMType](#oMType), [oBin](#oBin),\n[oAggregate](#oAggregate), [oTimeUnit](#oTimeUnit) and [oSort](#oSort).\n","args":[],"cases":[]},{"name":"OverlapStrategy","comment":" Generated by [osNone](#osNone), [osGreedy](#osGreedy) and [osParity](#osParity).\n","args":[],"cases":[["ONone",[]],["OParity",[]],["OGreedy",[]]]},{"name":"Padding","comment":" Generated by [paSize](#paSize) and [paEdges](#paEdges).\n","args":[],"cases":[]},{"name":"PointMarker","comment":" Generated by [pmNone](#pmNone), [pmTransparent](#pmTransparent) and [pmMarker](#pmMarker).\n","args":[],"cases":[]},{"name":"Position","comment":" Type of position channel.\n","args":[],"cases":[["X",[]],["Y",[]],["X2",[]],["Y2",[]],["Longitude",[]],["Latitude",[]],["Longitude2",[]],["Latitude2",[]]]},{"name":"PositionChannel","comment":" Generated by [pName](#pName), [pRepeat](#pRepeat), [pMType](#pMType), [pBin](#PBin),\n[pBinned](#pBinned), [pTimeUnit](#pTimeUnit), [pTitle](#pTitle), [pAggregate](#pAggregate),\n[pScale](#pScale), [pAxis](#pAxis), [pSort](#pSort), [pStack](#pStack),\n[pWidth](#pWidth), [pHeight](#pHeight) and [pImpute](#pImpute).\n","args":[],"cases":[]},{"name":"Projection","comment":" Generated by [albers](#albers), [albersUsa](#albersUsa),\n[azimuthalEqualArea](#azimuthalEqualArea), [azimuthalEquidistant](#azimuthalEquidistant),\n[conicConformal](#conicConformal), [conicEqualArea](#conicEqualArea),\n[conicEquidistant](#conicEquidistant), [equirectangular](#equirectangular),\n[gnomonic](#gnomonic), [mercator](#mercator), [orthographic](#orthographic),\n[stereographic](#stereographic), [transverseMercator](#transverseMercator) and\n[customProjection](#customProjection).\n","args":[],"cases":[]},{"name":"ProjectionProperty","comment":" Generated by [prType](#prType), [prClipAngle](#prClipAngle), [prClipExtent](#prClipExtent),\n[prCenter](#prCenter), [prRotate](#prRotate), [prPrecision](#prPrecision),\n[prCoefficient](#prCoefficient), [prDistance](#prDistance), [prFraction](#prFraction),\n[prLobes](#prLobes), [prParallel](#prParallel), [prRadius](#prRadius), [prRatio](#prRatio),\n[prSpacing](#prSpacing) and [prTilt](#prTilt).\n","args":[],"cases":[]},{"name":"RangeConfig","comment":" Generated by functions prefixed with `raco`.\n","args":[],"cases":[]},{"name":"RepeatFields","comment":" Generated by [rowFields](#rowFields) and [columnFields](#columnFields).\n","args":[],"cases":[]},{"name":"Resolution","comment":" Generated by [reShared](#reShared) and [reIndependent](#reIndependent).\n","args":[],"cases":[]},{"name":"Resolve","comment":" Generated by [reAxis](#reAxis), [reLegend](#reLegend) and [reScale](#reScale).\n","args":[],"cases":[]},{"name":"Scale","comment":" Generated by [scLinear](#scLinear), [scPow](#scPow), [scSqrt](#scSqrt), [scLog](#scLog),\n[scTime](#scTime), [scUtc](#scUtc), [scSequential](#scSequential), [scOrdinal](#scOrdinal),\n[scBand](#scBand), [scPoint](#scPoint), [scBinLinear](#scBinLinear), [scBinOrdinal](#scBinOrdinal),\n[scQuantile](#scQuantile), [scQuantize](#scQuantize) and [scThreshold](#scThreshold).\n","args":[],"cases":[]},{"name":"ScaleConfig","comment":" Generated by functions prefixed by `saco`\n","args":[],"cases":[]},{"name":"ScaleDomain","comment":" Generated by [doNums](#doNums), [doStrs](#doStrs), [doDts](#doDts),\n[doSelection](#doSelection) and [doUnaggregated](#doUnaggregated).\n","args":[],"cases":[]},{"name":"ScaleNice","comment":" Generated by [niTrue](#niTrue), [niFalse](#niFalse), [niMillisecond](#niMillisecond),\n[niSecond](#niSecond), [niMinute](#niMinute), [niHour](#niHour), [niDay](#niDay),\n[niWeek](#niWeek), [niMonth](#niMonth), [niYear](#niYear), [niTickCount](#niTickCount)\nand [niInterval](#niInterval).\n","args":[],"cases":[]},{"name":"ScaleProperty","comment":" Generated by [scType](#scType), [scDomain](#scDomain), [scRange](#scRange),\n[scScheme](#scScheme), [scPadding](#scPadding), [scPaddingInner](#scPaddingInner),\n[scPaddingOuter](#scPaddingOuter), [scRangeStep](#scRangeStep), [scRound](#scRound),\n[scClamp](#scClamp), [scInterpolate](#scInterpolate), [scNice](#scNice), [scZero](#scZero)\nand [scReverse](#scReverse).\n","args":[],"cases":[]},{"name":"ScaleRange","comment":" Generated by [raNums](#raNums), [raStrs](#raStrs) and [raName](#raName).\n","args":[],"cases":[]},{"name":"Selection","comment":" Generated by [seInterval](#seInterval), [seSingle](#seSingle) and [seMulti](#seMulti).\n","args":[],"cases":[]},{"name":"SelectionMarkProperty","comment":" Generated by [smFill](#smFill), [smFillOpacity](#smFillOpacity), [smStroke](#smStroke),\n[smStrokeDash](#smStrokeDash), [smStrokeDashOffset](#smStrokeDashOffset),\n[smStrokeOpacity](#smStrokeOpacity) and [smStrokeWidth](#smStrokeWidth).\n","args":[],"cases":[]},{"name":"SelectionProperty","comment":" Generated by [seBind](#seBind), [seBindScales](#seBindScales),[seEmpty](#seEmpty),\n[seEncodings](#seEncodings), [seFields](#seFields), [seNearest](#seNearest), [seOn](#seOn),\n[seResolve](#seResolve), [seSelectionMark](#seSelectionMark), [seToggle](#seToggle),\n[seTranslate](#seTranslate) and [seZoom](#seZoom).\n","args":[],"cases":[]},{"name":"SelectionResolution","comment":" Generated by [seGlobal](#seGlobal), [seUnion](#seUnion) and\n[seIntersection](#seIntersection).\n","args":[],"cases":[]},{"name":"Side","comment":" Generated by [siLeft](#siLeft), [siRight](#siRight), [siTop](#siTop),\nand [siBottom](#siBottom)\n","args":[],"cases":[]},{"name":"SortField","comment":" Generated by [stAscending](#stAscending), [wiAscending](#wiAscending),\n[stDescending](#stDescending) and [wiDescending](#wiDescending).\n","args":[],"cases":[]},{"name":"SortProperty","comment":" Generated by [soAscending](#soAscending), [soDescending](#soDescending),\n[soByField](#soByField), [soByRepeat](#soByRepeat) and [soCustom](#soCustom).\n","args":[],"cases":[]},{"name":"StackOffset","comment":" Generated by [stZero](#stZero), [stCenter](#stCenter), [stNormalize](#stNormalize)\nand [stNone](#stNone).\n","args":[],"cases":[]},{"name":"StackProperty","comment":" Generated by [stOffset](#stOffset) and [stSort](#stSort).\n","args":[],"cases":[]},{"name":"StrokeCap","comment":" Generated by [caButt](#caButt), [caRound](#caRound) and [caSquare](#caSquare).\n","args":[],"cases":[]},{"name":"StrokeJoin","comment":" Generated by [joMiter](#joMiter), [joRound](#joRound) and [joBevel](#joBevel).\n","args":[],"cases":[]},{"name":"SummaryExtent","comment":" Generated by [exCi](#exCi), [exIqr](#exIqr), [exIqrScale](#exIqrScale), [exRange](#exRange),\n[exStderr](#exStderr) and [exStdev](#exStdev).\n","args":[],"cases":[]},{"name":"Symbol","comment":" Generated by [symCircle](#symCircle), [symSquare](#symSquare), [symCross](#symCross),\n[symDiamond](#symDiamond), [symTriangleUp](#symTriangleUp), [symTriangleDown](#symTriangleDown)\nand [symPath](#symPath).\n","args":[],"cases":[]},{"name":"TextChannel","comment":" Generated by [tName](#tName), [tRepeat](#tRepeat), [tMType](#tMType),\n[tBin](#tBin), [tBinned](#tBinned), [tAggregate](#tAggregate), [tTimeUnit](#tTimeUnit),\n[tTitle](#tTitle), [tSelectionCondition](#tSelectionCondition),\n[tDataCondition](#tDataCondition) and [tFormat](#tFormat).\n","args":[],"cases":[]},{"name":"TimeUnit","comment":" Generated by [date](#date), [day](#day), [hours](#hours), [hoursMinutes](#hoursMinutes),\n[hoursMinutesSeconds](#hoursMinutesSeconds), [milliseconds](#milliseconds),\n[minutes](#minutes), [minutesSeconds](#minutesSeconds), [month](#month), [monthDate](#monthDate),\n[quarter](#quarter), [quarterMonth](#quarterMonth), [seconds](#seconds),\n[secondsMilliseconds](#secondsMilliseconds), [year](#year), [yearQuarter](#yearQuarter),\n[yearQuarterMonth](#yearQuarterMonth), [yearMonth](#yearMonth), [yearMonthDate](#yearMonthDate),\n[yearMonthDateHours](#yearMonthDateHours), [yearMonthDateHoursMinutes](#yearMonthDateHoursMinutes),\n[yearMonthDateHoursMinutesSeconds](#yearMonthDateHoursMinutesSeconds) and [utc](#utc).\n","args":[],"cases":[]},{"name":"TitleConfig","comment":" Generated by functions prefixed by `tico`.\n","args":[],"cases":[]},{"name":"TooltipContent","comment":" Generated by [ttEncoding](#ttEncoding) and [ttData](#ttData).\n","args":[],"cases":[]},{"name":"VAlign","comment":" Generated by [vaTop](#vaTop), [vaMiddle](#vaMiddle) and [vaBottom](#vaBottom).\n","args":[],"cases":[]},{"name":"VLProperty","comment":" Top-level Vega-Lite properties. These are the ones that define the core of the\nvisualization grammar. All `VLProperties` are created by functions in seven broad groups.\n\n**Data properties** relate to the input data to be visualized. Generated by\n[`dataFromColumns`](#dataFromColumns), [`dataFromRows`](#dataFromRows),\n[`dataFromUrl`](#dataFromUrl), [`dataFromSource`](#dataFromSource) and\n[`dataFromJson`](#dataFromJson).\n\n**Transform properties** indicate that some transformation of input data should\nbe applied before encoding them visually. Generated by [`transform`](#transform)\nand [`projection`](#projection) they can include data transformations such as\n[`filter`](#filter), [`binAs`](#binAs) and [`calculateAs`](#calculateAs) and geo\ntransformations of longitude, latitude coordinates used by marks such as those\ngenerated by [`geoshape`](#geoshape), [`point`](#point) and [`line`](#line).\n\n**Mark functions** specify the symbols used to visualize data items. Generated\nby functions such as [`circle`](#circle), [`bar`](#bar) and [`line`](#line).\n\n**Encoding properties** specify which data elements are mapped to which mark\ncharacteristics (known as _channels_). Generated by [`encoding`](#encoding) they\ninclude encodings such as [`position`](#position), [`color`](#color), [`size`](#size),\n[`shape`](#shape), [`text`](#text) and [`hyperlink`](#hyperlink).\n\n**Composition properties** allow visualization views to be combined to form more\ncomplex visualizations. Generated by [`layer`](#layer), [`repeat`](#repeat),\n[`facet`](#facet), [`hConcat`](#hConcat), [`vConcat`](#vConcat), [`spec`](#spec)\nand [`resolve`](#resolve).\n\n**Interaction properties** allow clicking, dragging and other interactions generated\nvia a GUI or data stream to influence the visualization. Generated by\n[`selection`](#selection).\n\n**Supplementary and configuration properties** provide a means to add metadata and\nstyling to one or more visualizations. Generated by [`name`](#name), [`title`](#title),\n[`description`](#description), [`background`](#background), [`width`](#width),\n[`height`](#height), [`padding`](#padding), [`autosize`](#autosize) and\n[`configure`](#configure).\n\n","args":[],"cases":[]},{"name":"ViewConfig","comment":" Generated by functions prefixed with `vico`.\n","args":[],"cases":[]},{"name":"WOperation","comment":" Generated by [woRowNumber](#woRowNumber), [woRank](#woRank), [woDenseRank](#woDenseRank),\n[woPercentRank](#woPercentRank), [woCumeDist](#woCumeDist), [woPercentile](#woPercentile),\n[woLag](#woLag), [woLead](#woLead), [woFirstValue](#woFirstValue), [woLastValue](#woLastValue),\nand [woNthValue](#woNthValue).\n","args":[],"cases":[]},{"name":"Window","comment":" Generated by [wiAggregateOp](#wiAggregateOp), [wiOp](#wiOp), [wiParam](#wiParam)\nand [wiField](#wiField).\n","args":[],"cases":[]},{"name":"WindowProperty","comment":" Generated by [wiFrame](#wiFrame), [wiIgnorePeers](#wiIgnorePeers), [wiGroupBy](#wiGroupBy)\nand [wiSort](#wiSort).\n","args":[],"cases":[]}],"aliases":[{"name":"Data","comment":" Convenience type annotation label for use with data generation functions.\n\n    myRegion : List DataColumn -> Data\n    myRegion =\n        dataFromColumns []\n            << dataColumn \"easting\" (nums [ -3, 4, 4, -3, -3 ])\n            << dataColumn \"northing\" (nums [ 52, 52, 45, 45, 52 ])\n\n","args":[],"type":"( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"DataColumn","comment":" A single column of data. Used when generating inline data with [dataColumn](#dataColumn).\n","args":[],"type":"List.List VegaLite.LabelledSpec"},{"name":"DataRow","comment":" A single row of data. Used when generating inline data with [dataRow](#dataRow).\n","args":[],"type":"VegaLite.Spec"},{"name":"LabelledSpec","comment":" A named Vega-Lite specification, usually generated by an elm-vega\nfunction. You shouldn't need to create `LabelledSpec` tuples directly, but are\nuseful for type annotations.\n","args":[],"type":"( String.String, VegaLite.Spec )"},{"name":"Spec","comment":" Part or all of Vega-Lite specification. Specs are usually nested\nand can range from a single Boolean value up to the entire Vega-Lite specification.\n","args":[],"type":"Json.Encode.Value"}],"values":[{"name":"aggregate","comment":" Aggregation transformations to be used when encoding channels. Useful when for\napplying the same transformation to a number of channels without defining it each\ntime. The first parameter is a list of the named aggregation operations to apply.\nThe second is a list of 'group by' fields.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs opMin \"people\" \"lowerBound\", opAs opMax \"people\" \"upperBound\" ]\n                [ \"age\" ]\n\n","type":"List.List VegaLite.Spec -> List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"albers","comment":" An Albers map projection.\n","type":"VegaLite.Projection"},{"name":"albersUsa","comment":" An Albers USA map projection that combines continental USA with Alaska and Hawaii.\n","type":"VegaLite.Projection"},{"name":"align","comment":" Alignment to apply to grid rows and columns generated by a composition\noperator. This version sets the same alignment for rows and columns.\n","type":"VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"alignRC","comment":" Similar to [align](#align) but with independent alignments for rows (first\nparameter) and columns (second parameter).\n","type":"VegaLite.CompositionAlignment -> VegaLite.CompositionAlignment -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"anEnd","comment":" Anchor some text at its end.\n","type":"VegaLite.Anchor"},{"name":"anMiddle","comment":" Anchor some text in its start.\n","type":"VegaLite.Anchor"},{"name":"anStart","comment":" Anchor some text at its start.\n","type":"VegaLite.Anchor"},{"name":"and","comment":" Apply an 'and' Boolean operation as part of a logical composition.\n\n    and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\")\n\n","type":"VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"},{"name":"arColumn","comment":" Column arrangement in a repeated/faceted view.\n","type":"VegaLite.Arrangement"},{"name":"arRow","comment":" Row arrangement in a repeated/faceted view.\n","type":"VegaLite.Arrangement"},{"name":"area","comment":" An [area mark](https://vega.github.io/vega-lite/docs/area.html) for representing\na series of data elements, such as in a stacked area chart or streamgraph.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"asContent","comment":" Interpret visualization dimensions to be for the data rectangle (external\npadding added to this size).\n","type":"VegaLite.Autosize"},{"name":"asFit","comment":" Interpret visualization dimensions to be for the entire visualization (data\nrectangle is shrunk to accommodate external decorations padding).\n","type":"VegaLite.Autosize"},{"name":"asNone","comment":" No autosizing to be applied.\n","type":"VegaLite.Autosize"},{"name":"asPad","comment":" Automatically expand size of visualization from the given dimensions in order\nto fit in all supplemtary decorations (legends etc.).\n","type":"VegaLite.Autosize"},{"name":"asPadding","comment":" Interpret visualization width to be for the entire visualization (data\nrectangle is shrunk to accommodate external padding).\n","type":"VegaLite.Autosize"},{"name":"asResize","comment":" Recalculate autosizing on every view update.\n","type":"VegaLite.Autosize"},{"name":"asSpec","comment":" Create a specification sufficient to define an element in a composed visualization\nsuch as a superposed layer or juxtaposed facet. Typically a layer will contain a\nfull set of specifications that define a visualization with the exception of the\ndata specification which is usually defined outside of any one\nlayer. For repeated and faceted specs, the entire specification is provided.\n","type":"List.List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"},{"name":"autosize","comment":" Declare the way the view is sized. See the\n[Vega-Lite autosize documentation](https://vega.github.io/vega-lite/docs/size.html#autosize).\n\n    enc = ...\n    toVegaLite\n        [ width 250\n        , height 300\n        , autosize [ asFit, asPadding, asResize ]\n        , dataFromUrl \"data/population.json\" []\n        , bar []\n        , enc []\n        ]\n\n","type":"List.List VegaLite.Autosize -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"axBandPosition","comment":" Position of axis tick relative to a band (0 to 1).\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axDates","comment":" Dates/times to appear along an axis.\n","type":"List.List (List.List VegaLite.DateTime) -> VegaLite.AxisProperty"},{"name":"axDomain","comment":" Whether or not an axis baseline (domain) should be included as part of an axis.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axDomainColor","comment":" Color of axis domain line.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axDomainOpacity","comment":" Opacity of axis domain line.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axDomainWidth","comment":" Width of axis domain line.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axFormat","comment":" [Format](https://vega.github.io/vega-lite/docs/format.html) to apply to\nlabels on an axis.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axGrid","comment":" Whether or not grid lines should be included as part of an axis.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axLabelAlign","comment":" Horizontal alignment of axis tick labels.\n","type":"VegaLite.HAlign -> VegaLite.AxisProperty"},{"name":"axLabelAngle","comment":" Rotation angle in degrees of axis labels.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelBaseline","comment":" Vertical alignment of axis tick labels.\n","type":"VegaLite.VAlign -> VegaLite.AxisProperty"},{"name":"axLabelBound","comment":" How or if labels should be hidden if they exceed the axis range. If\n`Nothing`, no check for label size is made. A number specifies the permitted\noverflow in pixels.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelColor","comment":" Color of axis tick label.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axLabelFlush","comment":" How or if labels at beginning or end of the axis should be aligned. Specifies\nthe distance threshold from an end-point within which labels are flush-adjusted\nor if `Nothing`, no flush-adjustment made.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelFlushOffset","comment":" Number of pixels by which to offset flush-adjusted labels.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelFont","comment":" Font name of an axis label.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axLabelFontSize","comment":" Font size of an axis label.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelFontWeight","comment":" Font weight of an axis label.\n","type":"VegaLite.FontWeight -> VegaLite.AxisProperty"},{"name":"axLabelLimit","comment":" Maximum length in pixels of axis tick labels.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelOpacity","comment":" Opacity of an axis label.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabelOverlap","comment":" Overlap strategy for labels when they are too large to fit within the space\ndevoted to an axis.\n","type":"VegaLite.OverlapStrategy -> VegaLite.AxisProperty"},{"name":"axLabelPadding","comment":" Padding in pixels between an axis and its text labels.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axLabels","comment":" Whether or not axis labels should be displayed.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axMaxExtent","comment":" Maximum extent in pixels that axis ticks and labels should use.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axMinExtent","comment":" Minimum extent in pixels that axis ticks and labels should use.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axOffset","comment":" Offset to displace the axis from the edge of the enclosing group or data rectangle.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axOrient","comment":" Orientation of an axis relative to the plot it is describing.\n","type":"VegaLite.Side -> VegaLite.AxisProperty"},{"name":"axPosition","comment":" Anchor position of the axis in pixels. For x-axis with top or\nbottom orientation, this sets the axis group x coordinate. For y-axis with left\nor right orientation, this sets the axis group y coordinate.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTickColor","comment":" Color of axis ticks.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axTickCount","comment":" Desired number of ticks for axes visualizing quantitative scales.\nThe resulting number may be different so that values are “nice” (multiples of 2, 5, 10).\n","type":"Basics.Int -> VegaLite.AxisProperty"},{"name":"axTickExtra","comment":" Whether or not an extra axis tick should be added for the initial position\nof an axis.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axTickOffset","comment":" Offset in pixels of an axis's ticks, labels and gridlines.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTickOpacity","comment":" Opacity of axis ticks.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTickRound","comment":" Whether or not axis tick positions should be rounded to nearest integer.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axTickSize","comment":" Tick mark size in pixels.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTickStep","comment":" Desired step size for ticks. Will generate corresponding tick count and values.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTickWidth","comment":" Width of axis ticks.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTicks","comment":" Whether or not an axis should include tick marks.\n","type":"Basics.Bool -> VegaLite.AxisProperty"},{"name":"axTitle","comment":" Title to display as part of an axis. An empty string can be used\nto prevent a title being displayed.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axTitleAlign","comment":" Horizontal alignment of an axis title.\n","type":"VegaLite.HAlign -> VegaLite.AxisProperty"},{"name":"axTitleAngle","comment":" Angle in degrees of an axis title.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitleBaseline","comment":" Vertical alignment of axis title.\n","type":"VegaLite.VAlign -> VegaLite.AxisProperty"},{"name":"axTitleColor","comment":" Color of axis title.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axTitleFont","comment":" Font name for an axis title.\n","type":"String.String -> VegaLite.AxisProperty"},{"name":"axTitleFontSize","comment":" Font size for an axis title.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitleFontWeight","comment":" Font weight of an axis title.\n","type":"VegaLite.FontWeight -> VegaLite.AxisProperty"},{"name":"axTitleLimit","comment":" Maximum length in pixels of axis title.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitleOpacity","comment":" Opacity of an axis title.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitlePadding","comment":" Padding in pixels between a title and axis.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitleX","comment":" X position of an axis title relative to the axis group.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axTitleY","comment":" Y position of an axis title relative to the axis group.\n","type":"Basics.Float -> VegaLite.AxisProperty"},{"name":"axValues","comment":" Numeric values to appear along an axis.\n","type":"List.List Basics.Float -> VegaLite.AxisProperty"},{"name":"axZIndex","comment":" Drawing order of the axis relative to the other chart elements. 1 indicates\naxis is drawn in front of chart marks, 0 indicates it is drawn behind them.\n","type":"Basics.Int -> VegaLite.AxisProperty"},{"name":"axcoBandPosition","comment":" Default axis band position.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoDomain","comment":" Whether or not an axis domain should be displayed by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoDomainColor","comment":" Default axis domain color.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoDomainOpacity","comment":" Default axis domain opacity.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoDomainWidth","comment":" Default axis domain width style.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoGrid","comment":" Whether or not an axis grid is displayed by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoGridColor","comment":" Default axis grid color style.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoGridDash","comment":" Default axis line dash style.\n","type":"List.List Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoGridOpacity","comment":" Default axis grid line opacity.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoGridWidth","comment":" Default axis grid line width.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelAlign","comment":" Default axis label horizontal alignment.\n","type":"VegaLite.HAlign -> VegaLite.AxisConfig"},{"name":"axcoLabelAngle","comment":" Default axis label angle.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelBaseline","comment":" Default axis label vertical alignment.\n","type":"VegaLite.VAlign -> VegaLite.AxisConfig"},{"name":"axcoLabelBound","comment":" Default axis label bounding when label exceeds available space. If `Nothing`,\nno check for label size is made. A number specifies the permitted overflow in pixels.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelColor","comment":" Default axis label color.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoLabelFlush","comment":" Default label alignment at beginning or end of the axis. Specifies the distance\nthreshold from an end-point within which labels are flush-adjusted or if `Nothing`,\nno flush-adjustment made.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelFlushOffset","comment":" Defailt number of pixels by which to offset flush-adjusted labels.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelFont","comment":" Default axis label font.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoLabelFontSize","comment":" Default axis label font size.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelFontWeight","comment":" Default axis label font weight.\n","type":"VegaLite.FontWeight -> VegaLite.AxisConfig"},{"name":"axcoLabelLimit","comment":" Default axis label limit (how much a label can extend beyond the\nleft/bottom or right/top of the axis line).\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelOpacity","comment":" Default axis label opacity.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabelOverlap","comment":" Default axis label overlap strategy for cases where labels cannot\nfit within the allotted space.\n","type":"VegaLite.OverlapStrategy -> VegaLite.AxisConfig"},{"name":"axcoLabelPadding","comment":" Default axis label padding (space between labels in pixels).\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoLabels","comment":" Whether or not an axis has labels by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoMaxExtent","comment":" Default maximum extent style.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoMinExtent","comment":" Default minimum extent style.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoShortTimeLabels","comment":" Whether or not an axis should use short time labels by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoTickColor","comment":" Default axis tick mark color.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoTickExtra","comment":" Whether or not by default an extra axis tick should be added for the initial\nposition of axes.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoTickOffset","comment":" Default offset in pixels of axis ticks, labels and gridlines.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTickOpacity","comment":" Default opacity of axis ticks.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTickRound","comment":" Whether or not axis tick labels use rounded values by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoTickSize","comment":" Default axis tick mark size.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTickStep","comment":" Default step size for axis ticks.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTickWidth","comment":" Default axis tick mark width.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTicks","comment":" Whether or not an axis should show ticks by default.\n","type":"Basics.Bool -> VegaLite.AxisConfig"},{"name":"axcoTitleAlign","comment":" Default axis tick label horizontal alignment.\n","type":"VegaLite.HAlign -> VegaLite.AxisConfig"},{"name":"axcoTitleAngle","comment":" Default axis title angle.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitleBaseline","comment":" Default axis title vertical alignment.\n","type":"VegaLite.VAlign -> VegaLite.AxisConfig"},{"name":"axcoTitleColor","comment":" Default axis title color.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoTitleFont","comment":" Default axis title font.\n","type":"String.String -> VegaLite.AxisConfig"},{"name":"axcoTitleFontSize","comment":" Default axis title font size.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitleFontWeight","comment":" Default axis title font weight.\n","type":"VegaLite.FontWeight -> VegaLite.AxisConfig"},{"name":"axcoTitleLimit","comment":" Default axis title maximum size.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitleOpacity","comment":" Default opacity of axis titles.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitlePadding","comment":" Default axis title padding between axis line and text.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitleX","comment":" Default axis x-position relative to the axis group.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"axcoTitleY","comment":" Default axis y-position relative to the axis group.\n","type":"Basics.Float -> VegaLite.AxisConfig"},{"name":"azimuthalEqualArea","comment":" An azimuthal equal area map projection.\n","type":"VegaLite.Projection"},{"name":"azimuthalEquidistant","comment":" An azimuthal equidistant map projection.\n","type":"VegaLite.Projection"},{"name":"background","comment":" Background color of the visualization. Should be specified with a CSS\nstring such as `#ffe` or `rgb(200,20,150)`. If not specified the background will\nbe transparent.\n","type":"String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"bar","comment":" [Bar mark](https://vega.github.io/vega-lite/docs/bar.html) for histograms,\nbar charts etc.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"biBase","comment":" Number base to use for automatic bin determination (default is base 10).\n","type":"Basics.Float -> VegaLite.BinProperty"},{"name":"biDivide","comment":" Scale factors indicating allowable subdivisions for binning. The default value\nis [5, 2], which indicates that for base 10 numbers (the default base), binning\nwill consider dividing bin sizes by 5 and/or 2.\n","type":"List.List Basics.Float -> VegaLite.BinProperty"},{"name":"biExtent","comment":" Desired range of bin values when binning a collection of values.\nThe first and second parameters indicate the minimum and maximum range values.\n","type":"Basics.Float -> Basics.Float -> VegaLite.BinProperty"},{"name":"biMaxBins","comment":" Maximum number of bins when binning a collection of values.\n","type":"Basics.Int -> VegaLite.BinProperty"},{"name":"biMinStep","comment":" Step size between bins when binning a collection of values.\n","type":"Basics.Float -> VegaLite.BinProperty"},{"name":"biNice","comment":" Whether or not binning boundaries use human-friendly values such as multiples\nof ten.\n","type":"Basics.Bool -> VegaLite.BinProperty"},{"name":"biStep","comment":" Step size between bins when binning a collection of values.\n","type":"Basics.Float -> VegaLite.BinProperty"},{"name":"biSteps","comment":" Allowable step sizes between bins when binning a collection of values.\n","type":"List.List Basics.Float -> VegaLite.BinProperty"},{"name":"binAs","comment":" Binning transformation that may be referenced in other transformations or\nencodings. The type of binning can be customised with a list of `BinProperty`\ngenerating functions ([biBase](#biBase), [biDivide](#biDivide) etc.) or an empty\nlist to use the default binning.\n\n    trans =\n        transform\n            << binAs [ biMaxBins 3 ] \"IMDB_Rating\" \"ratingGroup\"\n\nNote that usually, direct binning within an encoding is preferred over this form\nof bin transformation.\n\n","type":"List.List VegaLite.BinProperty -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"boFlush","comment":" Bounds calculation should take only the specified width and height values for\na sub-view. Useful when attempting to place sub-plots without axes or legends into\na uniform grid structure.\n","type":"VegaLite.Bounds"},{"name":"boFull","comment":" Bounds calculation should use the entire plot area (including axes, title,\nand legend).\n","type":"VegaLite.Bounds"},{"name":"boo","comment":" A Boolean data value.\n","type":"Basics.Bool -> VegaLite.DataValue"},{"name":"boos","comment":" A list of Boolean data values.\n","type":"List.List Basics.Bool -> VegaLite.DataValues"},{"name":"bounds","comment":" Bounds calculation method to use for determining the extent of a sub-plot in\na composed view. If set to `Full` the entire calculated bounds including axes,\ntitle and legend are used; if `Flush` only the width and height values for the\nsub-view will be used.\n","type":"VegaLite.Bounds -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"boxplot","comment":" [Boxplot composite mark](https://vega.github.io/vega-lite/docs/boxplot.html)\nfor showing summaries of statistical distributions.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"caAll","comment":" Subviews in a composed view to be aligned into a clean grid structure where\nall rows and columns are of the same size (based on maximum subview size).\n","type":"VegaLite.CompositionAlignment"},{"name":"caButt","comment":" Butt stroke cap.\n","type":"VegaLite.StrokeCap"},{"name":"caEach","comment":" Subviews in a composed view to be aligned into a clean grid structure where\neach row or column may be of variable size.\n","type":"VegaLite.CompositionAlignment"},{"name":"caNone","comment":" Flow layout is to be applied to composed views, in which adjacent subviews\nare placed one after the other.\n","type":"VegaLite.CompositionAlignment"},{"name":"caRound","comment":" Rounded stroke cap.\n","type":"VegaLite.StrokeCap"},{"name":"caSquare","comment":" Square stroke cap.\n","type":"VegaLite.StrokeCap"},{"name":"calculateAs","comment":" Generate a new data field based on calculations from existing fields.\nThe first parameter is an expression representing the calculation and the second\nis the name to give the newly calculated field.\n\n    trans =\n        transform << calculateAs \"datum.sex == 2 ? 'F' : 'M'\" \"gender\"\n\n","type":"String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"categoricalDomainMap","comment":" Create a set of discrete domain to color mappings suitable for customising categorical\nscales. The first item in each tuple should be a domain value and the second the\ncolor value with which it should be associated. It is a convenience function equivalent\nto specifying separate `scDomain` and `scRange` lists and is safer as it guarantees\na one-to-one correspondence between domain and range values.\n\n    color\n        [ mName \"weather\"\n        , mMType Nominal\n        , mScale <|\n            categoricalDomainMap\n                [ ( \"sun\", \"yellow\" )\n                , ( \"rain\", \"blue\" )\n                , ( \"fog\", \"grey\" )\n                ]\n        ]\n\n","type":"List.List ( String.String, String.String ) -> List.List VegaLite.ScaleProperty"},{"name":"center","comment":" Whether or not sub-views specified in a composition operator should be centred\nrelative to their respective rows and columns.\n","type":"Basics.Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"centerRC","comment":" Similar to [center](#center) but with independent centring for rows and columns.\n","type":"Basics.Bool -> Basics.Bool -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"chColor","comment":" Color channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chOpacity","comment":" Opacity channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chShape","comment":" Shape channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chSize","comment":" Size channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chX","comment":" X-channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chX2","comment":" X2-channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chY","comment":" Y-channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"chY2","comment":" Y2-channel to be used in a resolution specification\n","type":"VegaLite.Channel"},{"name":"circle","comment":" [Circle mark](https://vega.github.io/vega-lite/docs/circle.html) for\nsymbolising points.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"clipRect","comment":" Clipping rectangle in pixel units. The four parameters are respectively\n'left', 'top', 'right' and 'bottom' of the rectangular clipping bounds.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ClipRect"},{"name":"coArea","comment":" Configure the default appearance of area marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coAutosize","comment":" Configure the default sizing of visualizations.\n","type":"List.List VegaLite.Autosize -> VegaLite.ConfigurationProperty"},{"name":"coAxis","comment":" Configure the default appearance of axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisBand","comment":" Configure the default appearance of axes with band scaling.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisBottom","comment":" Configure the default appearance of bottom-side axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisLeft","comment":" Configure the default appearance of left-side axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisRight","comment":" Configure the default appearance of right-side axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisTop","comment":" Configure the default appearance of top-side axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisX","comment":" Configure the default appearance of x-axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coAxisY","comment":" Configure the default appearance of y-axes.\n","type":"List.List VegaLite.AxisConfig -> VegaLite.ConfigurationProperty"},{"name":"coBackground","comment":" Configure the default background color of visualizations.\n","type":"String.String -> VegaLite.ConfigurationProperty"},{"name":"coBar","comment":" Configure the default appearance of bar marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coCircle","comment":" Configure the default appearance of circle marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coCountTitle","comment":" Configure the default title style for count fields.\n","type":"String.String -> VegaLite.ConfigurationProperty"},{"name":"coFieldTitle","comment":" Configure the default title generation style for fields.\n","type":"VegaLite.FieldTitleProperty -> VegaLite.ConfigurationProperty"},{"name":"coGeoshape","comment":" Configure the default appearance of geoshape marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coHeader","comment":" Configure the default appearance of facet headers.\n","type":"List.List VegaLite.HeaderProperty -> VegaLite.ConfigurationProperty"},{"name":"coLegend","comment":" Configure the default appearance of legends.\n","type":"List.List VegaLite.LegendConfig -> VegaLite.ConfigurationProperty"},{"name":"coLine","comment":" Configure the default appearance of line marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coMark","comment":" Configure the default mark appearance.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coNamedStyle","comment":" Configure the default appearance of a named style.\n","type":"String.String -> List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coNumberFormat","comment":" Configure the default number formatting for axis and text labels.\n","type":"String.String -> VegaLite.ConfigurationProperty"},{"name":"coPadding","comment":" Configure the default padding in pixels from the edge of the of visualization\nto the data rectangle.\n","type":"VegaLite.Padding -> VegaLite.ConfigurationProperty"},{"name":"coPoint","comment":" Configure the default appearance of point marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coProjection","comment":" Configure the default style of map projections.\n","type":"List.List VegaLite.ProjectionProperty -> VegaLite.ConfigurationProperty"},{"name":"coRange","comment":" Configure the default range properties used when scaling.\n","type":"List.List VegaLite.RangeConfig -> VegaLite.ConfigurationProperty"},{"name":"coRect","comment":" Configure the default appearance of rectangle marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coRemoveInvalid","comment":" Configure the default handling of invalid (`null` and `NaN`) values. If `true`,\ninvalid values are skipped or filtered out when represented as marks.\n","type":"Basics.Bool -> VegaLite.ConfigurationProperty"},{"name":"coRule","comment":" Configure the default appearance of rule marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coScale","comment":" Configure the default scale properties used when scaling.\n","type":"List.List VegaLite.ScaleConfig -> VegaLite.ConfigurationProperty"},{"name":"coSelection","comment":" Configure the default appearance of selection marks.\n","type":"List.List ( VegaLite.Selection, List.List VegaLite.SelectionProperty ) -> VegaLite.ConfigurationProperty"},{"name":"coSquare","comment":" Configure the default appearance of square marks.)\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coStack","comment":" Configure the default stack offset style for stackable marks.\n","type":"VegaLite.StackOffset -> VegaLite.ConfigurationProperty"},{"name":"coText","comment":" Configure the default appearance of text marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coTick","comment":" Configure the default appearance of tick marks.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.ConfigurationProperty"},{"name":"coTimeFormat","comment":" Configure the default time format for axis and legend labels.\n","type":"String.String -> VegaLite.ConfigurationProperty"},{"name":"coTitle","comment":" Configure the default style of visualization titles.\n","type":"List.List VegaLite.TitleConfig -> VegaLite.ConfigurationProperty"},{"name":"coTrail","comment":" Configure the default style of trail marks.\n","type":"List.List VegaLite.MarkProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"coView","comment":" Configure the default single view style.\n","type":"List.List VegaLite.ViewConfig -> VegaLite.ConfigurationProperty"},{"name":"color","comment":" Encode a color channel. The first parameter is a list of mark channel properties\nthat characterise the way a data field is encoded by color.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"column","comment":" Encodes a new facet to be arranged in columns. The first parameter is a list\nof properties that define the faceting channel. This should include at least the\nname of the data field and its measurement type.\n","type":"List.List VegaLite.FacetChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"columnBy","comment":" The mapping between a column and its field definitions in a set of\nfaceted small multiples.\n","type":"List.List VegaLite.FacetChannel -> VegaLite.FacetMapping"},{"name":"columnFields","comment":" Create a list of fields to use in set of repeated small multiples arranged in\ncolumns. The list of fields named here can be referenced in an encoding with\n`pRepeat column`, `mRepeat column` etc.\n","type":"List.List String.String -> VegaLite.RepeatFields"},{"name":"combineSpecs","comment":" Combines a list of labelled specifications that may be passed to JavaScript\nfor rendering. Useful when you wish to create a single page with multiple\nvisualizations.\n\n    combineSpecs\n        [ ( \"vis1\", myFirstVis )\n        , ( \"vis2\", mySecondVis )\n        , ( \"vis3\", myOtherVis )\n        ]\n\n","type":"List.List VegaLite.LabelledSpec -> VegaLite.Spec"},{"name":"configuration","comment":" A configuration option to be applied globally across the visualization.\n","type":"VegaLite.ConfigurationProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"configure","comment":" Create a single global configuration from a list of configuration specifications.\nSee the [Vega-Lite documentation](https://vega.github.io/vega-lite/docs/config.html).\n\n    config =\n        configure\n            << configuration (coAxis [ axcoDomainWidth 1 ])\n            << configuration (coView [ vicoStroke Nothing ])\n            << configuration (coSelection [ ( seSingle, [ seOn \"dblclick\" ] ) ])\n\n","type":"List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"conicConformal","comment":" A conformal conic map projection.\n","type":"VegaLite.Projection"},{"name":"conicEqualArea","comment":" An equal area conic map projection.\n","type":"VegaLite.Projection"},{"name":"conicEquidistant","comment":" An equidistant conic map projection.\n","type":"VegaLite.Projection"},{"name":"csv","comment":" CSV data file format (only necessary if the file extension does not indicate the\ntype).\n","type":"VegaLite.Format"},{"name":"cuAlias","comment":" Alias cursor.\n","type":"VegaLite.Cursor"},{"name":"cuAllScroll","comment":" Scrolling cursor.\n","type":"VegaLite.Cursor"},{"name":"cuAuto","comment":" Automatically determine a cursor type depending on interaction context.\n","type":"VegaLite.Cursor"},{"name":"cuCell","comment":" Cell cursor.\n","type":"VegaLite.Cursor"},{"name":"cuColResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuContextMenu","comment":" Context menu cursor.\n","type":"VegaLite.Cursor"},{"name":"cuCopy","comment":" Copy cursor.\n","type":"VegaLite.Cursor"},{"name":"cuCrosshair","comment":" Crosshair cursor.\n","type":"VegaLite.Cursor"},{"name":"cuDefault","comment":" Default cursor.\n","type":"VegaLite.Cursor"},{"name":"cuEResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuEWResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuGrab","comment":" Grab cursor.\n","type":"VegaLite.Cursor"},{"name":"cuGrabbing","comment":" Grabbing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuHelp","comment":" Help cursor.\n","type":"VegaLite.Cursor"},{"name":"cuMove","comment":" Move cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNEResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNESWResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNSResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNWResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNWSEResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNoDrop","comment":" 'No drop' cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNone","comment":" No cursor.\n","type":"VegaLite.Cursor"},{"name":"cuNotAllowed","comment":" 'Not allowed' cursor.\n","type":"VegaLite.Cursor"},{"name":"cuPointer","comment":" Pointer cursor.\n","type":"VegaLite.Cursor"},{"name":"cuProgress","comment":" Progress cursor.\n","type":"VegaLite.Cursor"},{"name":"cuRowResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuSEResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuSResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuSWResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuText","comment":" Text cursor.\n","type":"VegaLite.Cursor"},{"name":"cuVerticalText","comment":" Vertical text cursor.\n","type":"VegaLite.Cursor"},{"name":"cuWResize","comment":" Resizing cursor.\n","type":"VegaLite.Cursor"},{"name":"cuWait","comment":" Waiting cursor.\n","type":"VegaLite.Cursor"},{"name":"cuZoomIn","comment":" Zooming cursor.\n","type":"VegaLite.Cursor"},{"name":"cuZoomOut","comment":" Zooming cursor.\n","type":"VegaLite.Cursor"},{"name":"cubeHelix","comment":" Cube helix color interpolation for continuous color scales using the given\ngamma value (anchored at 1).\n","type":"Basics.Float -> VegaLite.CInterpolate"},{"name":"cubeHelixLong","comment":" Long-path cube helix color interpolation for continuous color scales using\nthe given gamma value (anchored at 1).\n","type":"Basics.Float -> VegaLite.CInterpolate"},{"name":"customProjection","comment":" Custom projection type. Additional custom projections from d3 can be defined\nvia the [Vega API](https://vega.github.io/vega/docs/projections/#register) and\ncalled from with this function where the parameter is the name of the D3\nprojection to use (e.g. `customProjection \"winkel3\"`).\n","type":"String.String -> VegaLite.Projection"},{"name":"dAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\nlevel of detail (grouping) channel. The type of aggregation is determined by the\ngiven operation parameter.\n","type":"VegaLite.Operation -> VegaLite.DetailChannel"},{"name":"dBin","comment":" Discretize numeric values into bins when encoding with a level of detail\n(grouping) channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.DetailChannel"},{"name":"dImpute","comment":" Set the iputation rules for a detail channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n","type":"List.List VegaLite.ImputeProperty -> VegaLite.DetailChannel"},{"name":"dMType","comment":" Level of measurement when encoding with a level of detail (grouping) channel.\n","type":"VegaLite.Measurement -> VegaLite.DetailChannel"},{"name":"dName","comment":" Field used for encoding with a level of detail (grouping) channel.\n","type":"String.String -> VegaLite.DetailChannel"},{"name":"dTimeUnit","comment":" Form of time unit aggregation of field values when encoding with a level of\ndetail (grouping) channel.\n","type":"VegaLite.TimeUnit -> VegaLite.DetailChannel"},{"name":"dataColumn","comment":" Create a column of data. A column has a name and a list of values.\n","type":"String.String -> VegaLite.DataValues -> List.List VegaLite.DataColumn -> List.List VegaLite.DataColumn"},{"name":"dataFromColumns","comment":" Declare a data source from a list of column values. Each column should contain\nvalues of the same type, but columns each with a different type are permitted.\nIf columns do not contain the same number of items the dataset will be truncated\nto the length of the shortest. A list of field formatting instructions can be\nprovided as the first parameter or an empty list to use the default formatting.\nThe columns are most easily generated with [dataColumn](#dataColumn):\n\n    data =\n        dataFromColumns [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataColumn \"Animal\" (strs [ \"Fish\", \"Dog\", \"Cat\" ])\n            << dataColumn \"Age\" (nums [ 28, 12, 6 ])\n            << dataColumn \"Year\" (strs [ \"2010\", \"2014\", \"2015\" ])\n\nFor more complex inline data tables, such as mixtures of arrays and objects, consider\nusing [dataFromJson](#dataFromJson).\n\n","type":"List.List VegaLite.Format -> List.List VegaLite.DataColumn -> VegaLite.Data"},{"name":"dataFromJson","comment":" Declare a data source from a json specification. The most likely use-case is\ncreating [geojson](http://geojson.org) objects with [`geometry`](#geometry),\n[`geometryCollection`](#geometryCollection) and [`geoFeatureCollection`](#geoFeatureCollection).\nFor more general cases of json creation such as data tables that mix arrays and\nobjects, consider\n[`Json.Encode`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Encode).\n\n    let\n        geojson =\n            geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n    in\n    toVegaLite\n        [ width 200\n        , height 200\n        , dataFromJson geojson []\n        , projection [ prType orthographic ]\n        , geoshape []\n        ]\n\n","type":"VegaLite.Spec -> List.List VegaLite.Format -> VegaLite.Data"},{"name":"dataFromRows","comment":" Declare a data source from a list of row values. Each row should contain a\nlist of tuples in the form (_column name_, _value_). Each column can have a value\nof a different type but you must ensure that values are of the same type as others\nin the same column. A list of field formatting instructions can be provided as\nthe first parameter or an empty list to use the default formatting. Rows are most\neasily generated with [dataRow](#dataRow).\n\n    data =\n        dataFromRows [ parse [ ( \"Year\", foDate \"%Y\" ) ] ]\n            << dataRow [ ( \"Animal\", str \"Fish\" ), ( \"Age\", num 28 ), ( \"Year\", str \"2010\" ) ]\n            << dataRow [ ( \"Animal\", str \"Dog\" ), ( \"Age\", num 12 ), ( \"Year\", str \"2014\" ) ]\n            << dataRow [ ( \"Animal\", str \"Cat\" ), ( \"Age\", num 6 ), ( \"Year\", str \"2015\" ) ]\n\nGenerally, adding data by column is more efficient and less error-prone. For more\ncomplex inline data tables, such as mixtures of arrays and objects, consider using\n[dataFromJson](#dataFromJson).\n\n","type":"List.List VegaLite.Format -> List.List VegaLite.DataRow -> VegaLite.Data"},{"name":"dataFromSource","comment":" Declare data from a named source. The source may be from named `datasets` within\na specification or one created via the [Vega View API](https://vega.github.io/vega/docs/api/view/#data).\nA list of field formatting instructions can be provided as the second parameter\nor an empty list to use the default formatting.\n\n    data = ...\n    json = ...\n    enc = ...\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n","type":"String.String -> List.List VegaLite.Format -> VegaLite.Data"},{"name":"dataFromUrl","comment":" Declare a data source from a url. The URL can be a local path on a web server\nor an external (CORS) URL. A list of field formatting instructions can be provided\nas the second parameter or an empty list to use the default formatting.\n","type":"String.String -> List.List VegaLite.Format -> VegaLite.Data"},{"name":"dataName","comment":" Name to give a data source. Useful when a specification needs to reference a\ndata source, such as one generated via an API call.\n\n    data =\n        dataFromUrl \"myData.json\" [] |> dataName \"myName\"\n\n","type":"String.String -> VegaLite.Data -> VegaLite.Data"},{"name":"dataRow","comment":" Create a row of data. A row comprises a list of (_columnName_, _value_) pairs.\n","type":"List.List ( String.String, VegaLite.DataValue ) -> List.List VegaLite.DataRow -> List.List VegaLite.DataRow"},{"name":"datasets","comment":" Create a dataset comprising a collection of named `Data` items. Each data item\ncan be created with normal data generating functions such as [dataFromRows](#dataFromRows)\nor [dataFromJson](#dataFromJson). These can be later referred to using\n[dataFromSource](#dataFromSource).\n\n    import Json.Encode as JE\n\n    let\n        data =\n            dataFromRows []\n                << dataRow [ ( \"cat\", str \"a\" ), ( \"val\", num 10 ) ]\n                << dataRow [ ( \"cat\", str \"b\" ), ( \"val\", num 18 ) ]\n        json =\n            JE.list JE.object\n                [ [ ( \"cat\", JE.string \"a\" ), ( \"val\", JE.float 120 ) ]\n                , [ ( \"cat\", JE.string \"b\" ), ( \"val\", JE.float 180 ) ]\n                ]\n\n        enc = ...\n\n    in\n    toVegaLite\n        [ datasets [ ( \"myData\", data [] ),  ( \"myJson\", dataFromJson json [] ) ]\n        , dataFromSource \"myData\" []\n        , bar []\n        , enc []\n        ]\n\n","type":"List.List ( String.String, VegaLite.Data ) -> VegaLite.Data"},{"name":"date","comment":" Day of the month (1-31) time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"day","comment":" Day of the week time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"description","comment":" Description to be associated with a visualization.\n","type":"String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"detail","comment":" Encode a 'level of detail' channel. This provides a way of grouping by a field\nbut unlike, say `color`, all groups have the same visual properties. The first\nparameter is a list of the field characteristics to be grouped.\n","type":"List.List VegaLite.DetailChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"doDts","comment":" Date-time values that define a scale domain.\n","type":"List.List (List.List VegaLite.DateTime) -> VegaLite.ScaleDomain"},{"name":"doNums","comment":" Numeric values that define a scale domain.\n","type":"List.List Basics.Float -> VegaLite.ScaleDomain"},{"name":"doSelection","comment":" Scale domain based on a named interactive selection.\n","type":"String.String -> VegaLite.ScaleDomain"},{"name":"doStrs","comment":" String values that define a scale domain.\n","type":"List.List String.String -> VegaLite.ScaleDomain"},{"name":"doUnaggregated","comment":" Specify an unaggregated scale domain (type of data in scale).\n","type":"VegaLite.ScaleDomain"},{"name":"domainRangeMap","comment":" Create a pair of continuous domain to color mappings suitable for customising\nordered scales. The first parameter is a tuple representing the mapping of the lowest\nnumeric value in the domain to its equivalent color; the second tuple the mapping\nof the highest numeric value to color. If the domain contains any values between\nthese lower and upper bounds they are interpolated according to the scale's interpolation\nfunction. Convenience function equivalent to specifying separate `scDomain` and\n`scRange` lists and is safer as it guarantees a one-to-one correspondence between\ndomain and range values.\n\n    color\n        [ mName \"year\"\n        , mMType Ordinal\n        , mScale (domainRangeMap ( 1955, \"#e6959c\" ) ( 2000, \"#911a24\" ))\n        ]\n\n","type":"( Basics.Float, String.String ) -> ( Basics.Float, String.String ) -> List.List VegaLite.ScaleProperty"},{"name":"dsv","comment":" Delimited file format (DSV) with a given separator.\n","type":"Char.Char -> VegaLite.Format"},{"name":"dt","comment":" Date-time data value.\n","type":"List.List VegaLite.DateTime -> VegaLite.DataValue"},{"name":"dtDate","comment":" Day of the month (1 to 31).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtDay","comment":" Day of the week.\n","type":"VegaLite.DayName -> VegaLite.DateTime"},{"name":"dtHour","comment":" Hour of the day (0=midnight, 1=1am, 23=11pm etc.).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtMillisecond","comment":" Millisecond of a second (0-999).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtMinute","comment":" Minute of an hour (0-59).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtMonth","comment":" Month of a year (1 to 12).\n","type":"VegaLite.MonthName -> VegaLite.DateTime"},{"name":"dtQuarter","comment":" Year quarter (1 to 4).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtRange","comment":" Min max date-time range to be used in data filtering. If either\nparameter is an empty list, it is assumed to be unbounded.\n","type":"List.List VegaLite.DateTime -> List.List VegaLite.DateTime -> VegaLite.FilterRange"},{"name":"dtSecond","comment":" Second of a minute (0-59).\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dtYear","comment":" A year.\n","type":"Basics.Int -> VegaLite.DateTime"},{"name":"dts","comment":" List of date-time data values.\n","type":"List.List (List.List VegaLite.DateTime) -> VegaLite.DataValues"},{"name":"encoding","comment":" Create an encoding specification from a list of channel encodings.\n","type":"List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"equirectangular","comment":" An equirectangular (default) map projection that maps longitude to x and\nlatitude to y.\n","type":"VegaLite.Projection"},{"name":"errorband","comment":" [Errorband composite mark](https://vega.github.io/vega-lite/docs/errorband.html)\nfor showing summaries of variation along a signal. By default no border is drawn.\nTo add a border with default properties use [maBorders](#maBorders) with an empty list.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"errorbar","comment":" [Errorbar composite mark](https://vega.github.io/vega-lite/docs/errorbar.html)\nfor showing summaries of variation along a signal. By default no ticks are drawn.\nTo add ticks with default properties use [maTicks](#maTicks) with an empty list.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"exCi","comment":" Band extent between the 95% confidence intervals of a distribution.\n","type":"VegaLite.SummaryExtent"},{"name":"exIqr","comment":" Band extent between the lower and upper quartiles of a distribution.\n","type":"VegaLite.SummaryExtent"},{"name":"exIqrScale","comment":" A scaling of the interquartile range to be used as whiskers in a boxplot.\nFor example a value of 1.5 would extend whiskers to ±1.5x the IQR from the mean.\n","type":"Basics.Float -> VegaLite.SummaryExtent"},{"name":"exRange","comment":" Band extent between the minumum and maximum values in a distribution.\n","type":"VegaLite.SummaryExtent"},{"name":"exStderr","comment":" Band extent as the standard error about the mean of a distribution.\n","type":"VegaLite.SummaryExtent"},{"name":"exStdev","comment":" Band extent as the standard deviation of a distribution.\n","type":"VegaLite.SummaryExtent"},{"name":"expr","comment":" Expression that should evaluate to either true or false. Can use any valid\n[Vega expression](https://vega.github.io/vega/docs/expressions/).\n","type":"String.String -> VegaLite.BooleanOp"},{"name":"fAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\nfacet channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.FacetChannel"},{"name":"fBin","comment":" Discretize numeric values into bins when encoding with a facet channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.FacetChannel"},{"name":"fHeader","comment":" Guide that spans a collection of faceted plots, each of which may have their own axes.\n","type":"List.List VegaLite.HeaderProperty -> VegaLite.FacetChannel"},{"name":"fMType","comment":" Level of measurement when encoding with a facet channel.\n","type":"VegaLite.Measurement -> VegaLite.FacetChannel"},{"name":"fName","comment":" Field used for encoding with a facet channel.\n","type":"String.String -> VegaLite.FacetChannel"},{"name":"fTimeUnit","comment":" Form of time unit aggregation of field values when encoding with a facet channel.\n","type":"VegaLite.TimeUnit -> VegaLite.FacetChannel"},{"name":"facet","comment":" Fields to be used to facet a view in rows or columns creating a set of small\nmultiples. Used when the encoding of the visualization in small multiples is\nidentical, but data for each is grouped by the given fields. When\ncreating a faceted view in this way you also need to define a full specification\nto apply to each of those facets using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n","type":"List.List VegaLite.FacetMapping -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"false","comment":" A false value used for functions that can accept a Boolean literal or a\nreference to something that generates a Boolean value. Convenience function\nequivalent to `boo False`\n","type":"VegaLite.DataValue"},{"name":"fiCompose","comment":" Build up a filtering predicate through logical composition (`and`, `or` etc.).\n","type":"VegaLite.BooleanOp -> VegaLite.Filter"},{"name":"fiEqual","comment":" Filter a data stream so that only data in a given field equal to the given\nvalue are used.\n","type":"String.String -> VegaLite.DataValue -> VegaLite.Filter"},{"name":"fiExpr","comment":" Filter a data stream so that only data that satisfy the given predicate\nexpression are used.\n","type":"String.String -> VegaLite.Filter"},{"name":"fiGreaterThan","comment":" Filter a data stream so that only data in a given field greater than the given\nvalue are used.\n","type":"String.String -> VegaLite.DataValue -> VegaLite.Filter"},{"name":"fiGreaterThanEq","comment":" Filter a data stream so that only data in a given field greater than or equal\nto the given value are used.\n","type":"String.String -> VegaLite.DataValue -> VegaLite.Filter"},{"name":"fiLessThan","comment":" Filter a data stream so that only data in a given field less than the given\nvalue are used.\n","type":"String.String -> VegaLite.DataValue -> VegaLite.Filter"},{"name":"fiLessThanEq","comment":" Filter a data stream so that only data in a given field less than or equal to\nthe given value are used.\n","type":"String.String -> VegaLite.DataValue -> VegaLite.Filter"},{"name":"fiOneOf","comment":" Filter a data stream so that only data in a given field contained in the given\nlist of values are used.\n","type":"String.String -> VegaLite.DataValues -> VegaLite.Filter"},{"name":"fiRange","comment":" Filter a data stream so that only data in a given field that are within the\ngiven range are used.\n","type":"String.String -> VegaLite.FilterRange -> VegaLite.Filter"},{"name":"fiSelection","comment":" Filter a data stream so that only data in a given field that are within the\ngiven interactive selection are used.\n","type":"String.String -> VegaLite.Filter"},{"name":"fiValid","comment":" Filter a data stream so that only valid data (i.e. not null or NaN) in a given\nfield are used.\n","type":"String.String -> VegaLite.Filter"},{"name":"fill","comment":" Encode a fill channel. This acts in a similar way to encoding by `color` but\nonly affects the interior of closed shapes. If both `fill` and `color` encodings\nare specified, `fill` takes precedence.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"filter","comment":" Apply a filter to a channel or field.\n","type":"VegaLite.Filter -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"flatten","comment":" Map array-valued fields to a set of individual data objects, one per array entry.\n","type":"List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"flattenAs","comment":" Similar to [flatten](#flatten) but allows the new output fields to be named\n(second parameter).\n","type":"List.List String.String -> List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"foBoo","comment":" Indicate Boolean data type to be parsed when reading input data.\n","type":"VegaLite.DataType"},{"name":"foDate","comment":" Date format for parsing input data using\n[D3's formatting specifiers](https://vega.github.io/vega-lite/docs/data.html#format)\nor left as an empty string for default formatting.\n","type":"String.String -> VegaLite.DataType"},{"name":"foNum","comment":" Indicate numeric data type to be parsed when reading input data.\n","type":"VegaLite.DataType"},{"name":"foUtc","comment":" Similar to [foDate](#foDate) but for UTC format dates.\n","type":"String.String -> VegaLite.DataType"},{"name":"fold","comment":" Collapse one or more data fields into two properties: a _key_ (containing\nthe original data field name) and a _value_ (containing the data value). Useful\nfor mapping matrix or cross-tabulation data into a standardized format.\n","type":"List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"foldAs","comment":" Similar to [fold](#fold) but allows the new output `key` and `value` fields\nto be given alternative names\n","type":"List.List String.String -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"ftFunction","comment":" Field titles to be displayed as 'SUM(field)', 'YEAR(date)' etc.\n","type":"VegaLite.FieldTitleProperty"},{"name":"ftPlain","comment":" Field titles to be displayed simply by their name without additional text.\n","type":"VegaLite.FieldTitleProperty"},{"name":"ftVerbal","comment":" Field titles to be displayed fully as 'Sum of field', 'Year of date' etc.\n","type":"VegaLite.FieldTitleProperty"},{"name":"geoFeatureCollection","comment":" Geo features to be used in a `geoshape` specification. Each feature object in\nthis collection can be created with [geometry](#geometry).\n\n    geojson =\n        geoFeatureCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( -3, 52 ), ( 4, 52 ), ( -3, 59 ) ] ])\n                [ ( \"myRegionName\", str \"Northern region\" ) ]\n            , geometry (geoPolygon [ [ ( -3, 52 ), ( 4, 52 ), ( 4, 45 ), ( -3, 52 ) ] ])\n                [ ( \"myRegionName\", str \"Southern region\" ) ]\n            ]\n\n","type":"List.List VegaLite.Spec -> VegaLite.Spec"},{"name":"geoLine","comment":" Line geometry for programmatically creating GeoShapes. Equivalent to the\n[GeoJson geometry `line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"List.List ( Basics.Float, Basics.Float ) -> VegaLite.Geometry"},{"name":"geoLines","comment":" Multi-line geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-line` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"List.List (List.List ( Basics.Float, Basics.Float )) -> VegaLite.Geometry"},{"name":"geoPoint","comment":" Point geometry for programmatically creating GeoShapes. Equivalent to\nthe [GeoJson geometry `point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"Basics.Float -> Basics.Float -> VegaLite.Geometry"},{"name":"geoPoints","comment":" Multi-point geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-point` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"List.List ( Basics.Float, Basics.Float ) -> VegaLite.Geometry"},{"name":"geoPolygon","comment":" Polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"List.List (List.List ( Basics.Float, Basics.Float )) -> VegaLite.Geometry"},{"name":"geoPolygons","comment":" Multi-polygon geometry for programmatically creating GeoShapes. Equivalent\nto the [GeoJson geometry `multi-polygon` type](https://tools.ietf.org/html/rfc7946#section-3.1).\n","type":"List.List (List.List (List.List ( Basics.Float, Basics.Float ))) -> VegaLite.Geometry"},{"name":"geometry","comment":" Geometric object to be used in a `geoshape`. The first parameter is\nthe geometric type, the second an optional list of properties to be associated\nwith the object.\n\n      geojson =\n          geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n\n","type":"VegaLite.Geometry -> List.List ( String.String, VegaLite.DataValue ) -> VegaLite.Spec"},{"name":"geometryCollection","comment":" Geometry objects to be used in a `geoshape` specification. Each geometry\nobject can be created with [geometry](#geometry).\n\n    geojson =\n        geometryCollection\n            [ geometry (geoPolygon [ [ ( -3, 59 ), ( 4, 59 ), ( 4, 52 ), ( -3, 59 ) ] ]) []\n            , geometry (geoPoint -3.5 55.5) []\n            ]\n\n","type":"List.List VegaLite.Spec -> VegaLite.Spec"},{"name":"geoshape","comment":" [Geoshape](https://vega.github.io/vega-lite/docs/geoshape.html)\ndetermined by geographically referenced coordinates.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"gnomonic","comment":" A gnomonic map projection.\n","type":"VegaLite.Projection"},{"name":"hAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\nhyperlink channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.HyperlinkChannel"},{"name":"hBin","comment":" Discretize numeric values into bins when encoding with a hyperlink channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.HyperlinkChannel"},{"name":"hBinned","comment":" Indicate that data encoded with a hyperlink channel are already binned.\n","type":"VegaLite.HyperlinkChannel"},{"name":"hConcat","comment":" Specifications to be juxtaposed horizontally in a visualization.\n","type":"List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"hDataCondition","comment":" Make a hyperlink channel conditional on some predicate expression. The first\nparameter provides the expression to evaluate, the second the encoding to apply\nif the expression is true, the third the encoding if the expression is false.\n","type":"VegaLite.BooleanOp -> List.List VegaLite.HyperlinkChannel -> List.List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"},{"name":"hMType","comment":" Level of measurement when encoding with a hyperlink channel.\n","type":"VegaLite.Measurement -> VegaLite.HyperlinkChannel"},{"name":"hName","comment":" Field used for encoding with a hyperlink channel.\n","type":"String.String -> VegaLite.HyperlinkChannel"},{"name":"hRepeat","comment":" Reference in a hyperlink channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields being laid out\nin columns or in rows.\n","type":"VegaLite.Arrangement -> VegaLite.HyperlinkChannel"},{"name":"hSelectionCondition","comment":" Make a hyperlink channel conditional on interactive selection. The first parameter\nprovides the selection to evaluate, the second the encoding to apply if the hyperlink\nhas been selected, the third the encoding if it is not selected.\n","type":"VegaLite.BooleanOp -> List.List VegaLite.HyperlinkChannel -> List.List VegaLite.HyperlinkChannel -> VegaLite.HyperlinkChannel"},{"name":"hStr","comment":" Literal string value when encoding with a hyperlink channel.\n","type":"String.String -> VegaLite.HyperlinkChannel"},{"name":"hTimeUnit","comment":" Time unit aggregation of field values when encoding with a hyperlink channel.\n","type":"VegaLite.TimeUnit -> VegaLite.HyperlinkChannel"},{"name":"haCenter","comment":" Center horizontal text alignment.\n","type":"VegaLite.HAlign"},{"name":"haLeft","comment":" Left horizontal text alignment.\n","type":"VegaLite.HAlign"},{"name":"haRight","comment":" Right horizontal text alignment.\n","type":"VegaLite.HAlign"},{"name":"hcl","comment":" HCL color interpolation for continuous color scales.\n","type":"VegaLite.CInterpolate"},{"name":"hclLong","comment":" HCL color interpolation in polar coordinate space for continuous color scales.\n","type":"VegaLite.CInterpolate"},{"name":"hdFormat","comment":" Header format for a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdLabelAngle","comment":" Header label rotation angle (in degrees) for a faceted view. A 'label' is the\ntitle for each sub-plot in a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdLabelColor","comment":" Header label text color for a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdLabelFont","comment":" Header label font for a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdLabelFontSize","comment":" Header label font size for a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdLabelLimit","comment":" Maximum length of a header label in a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdLabelPadding","comment":" Spacing in pixels between facet labels and the main plot area.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdTitle","comment":" Header title in a faceted view. A 'title' is the overall title describing\nthe collection of faceted plots.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdTitleAnchor","comment":" Anchor position of a header title in a faceted view.\n","type":"VegaLite.Anchor -> VegaLite.HeaderProperty"},{"name":"hdTitleAngle","comment":" Text angle of a header title in a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdTitleBaseline","comment":" Vertical alignment of a header title in a faceted view.\n","type":"VegaLite.VAlign -> VegaLite.HeaderProperty"},{"name":"hdTitleColor","comment":" Text color of a header title in a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdTitleFont","comment":" Title font in a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdTitleFontSize","comment":" Title font size in a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdTitleFontWeight","comment":" Title font weight in a faceted view.\n","type":"String.String -> VegaLite.HeaderProperty"},{"name":"hdTitleLimit","comment":" Maximum length of a header title in a faceted view.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"hdTitlePadding","comment":" Spacing in pixels between the main facet title and labels.\n","type":"Basics.Float -> VegaLite.HeaderProperty"},{"name":"height","comment":" Override the default height of the visualization. If not specified the height\nwill be calculated based on the content of the visualization.\n","type":"Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"hours","comment":" Hour of the day time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"hoursMinutes","comment":" Hours and minutes time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"hoursMinutesSeconds","comment":" Hours, minutes and seconds time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"hsl","comment":" HSL color interpolation for continuous color scales.\n","type":"VegaLite.CInterpolate"},{"name":"hslLong","comment":" HSL color interpolation in polar coordinate space for continuous color scales.\n","type":"VegaLite.CInterpolate"},{"name":"hyperlink","comment":" Encode a hyperlink channel. The first parameter is a list of hyperlink channel\nproperties that characterise the hyperlinking such as the destination URL and cursor\ntype.\n","type":"List.List VegaLite.HyperlinkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"iCheckbox","comment":" Checkbox input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iColor","comment":" Color input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iDate","comment":" Date input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iDateTimeLocal","comment":" Local time input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iMonth","comment":" Month input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iNumber","comment":" Number input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iRadio","comment":" Radio box input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iRange","comment":" Range slider input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iSelect","comment":" Select input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iTel","comment":" Telephone number input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iText","comment":" Text input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iTime","comment":" Time input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"iWeek","comment":" Week input element that can bound to a named field value.\n","type":"String.String -> List.List VegaLite.InputProperty -> VegaLite.Binding"},{"name":"imFrame","comment":" 1d window over which data imputation values are generated. The two\nparameters should either be `Just` a number indicating the offset from the current\ndata object, or `Nothing` to indicate unbounded rows preceding or following the\ncurrent data object.\n","type":"Maybe.Maybe Basics.Int -> Maybe.Maybe Basics.Int -> VegaLite.ImputeProperty"},{"name":"imGroupBy","comment":" Allow imputing of missing values on a per-group basis. For use with the impute\ntransform only and not a channel encoding.\n","type":"List.List String.String -> VegaLite.ImputeProperty"},{"name":"imKeyValSequence","comment":" Key values to be considered for imputation as a sequence of numbers between\na start (first parameter), to less than an end (second parameter) in steps of\nthe third parameter.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ImputeProperty"},{"name":"imKeyVals","comment":" Key values to be considered for imputation.\n","type":"VegaLite.DataValues -> VegaLite.ImputeProperty"},{"name":"imMax","comment":" Use maximum of values when imputing missing data.\n","type":"VegaLite.ImMethod"},{"name":"imMean","comment":" Use mean of values when imputing missing data.\n","type":"VegaLite.ImMethod"},{"name":"imMedian","comment":" Use median of values when imputing missing data.\n","type":"VegaLite.ImMethod"},{"name":"imMethod","comment":" Imputation method to use when replacing values.\n","type":"VegaLite.ImMethod -> VegaLite.ImputeProperty"},{"name":"imMin","comment":" Use maximum of values when imputing missing data.\n","type":"VegaLite.ImMethod"},{"name":"imNewValue","comment":" New value to use when imputing with [imValue](#imValue).\n","type":"VegaLite.DataValue -> VegaLite.ImputeProperty"},{"name":"imValue","comment":" Use field value when imputing missing data.\n","type":"VegaLite.ImMethod"},{"name":"impute","comment":" Impute missing data values. The first parameter is the data field to process;\nthe second the key field to uniquely identify data objects within a group; the\nthird customisable options.\n","type":"String.String -> String.String -> List.List VegaLite.ImputeProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"inDebounce","comment":" Delay to introduce when processing input events in order to avoid unnecessary\nevent broadcasting.\n","type":"Basics.Float -> VegaLite.InputProperty"},{"name":"inElement","comment":" CSS selector indicating the parent element to which an input element should\nbe added. Allows the option of the input element to be outside the visualization\ncontainer.\n","type":"String.String -> VegaLite.InputProperty"},{"name":"inMax","comment":" Maximum slider value for a range input element.\n","type":"Basics.Float -> VegaLite.InputProperty"},{"name":"inMin","comment":" Minimum slider value for a range input element.\n","type":"Basics.Float -> VegaLite.InputProperty"},{"name":"inName","comment":" Custom label for a radio or select input element.\n","type":"String.String -> VegaLite.InputProperty"},{"name":"inOptions","comment":" Options for a radio or select input element.\n","type":"List.List String.String -> VegaLite.InputProperty"},{"name":"inPlaceholder","comment":" Initial placeholding text for input elements such as text fields.\n","type":"String.String -> VegaLite.InputProperty"},{"name":"inStep","comment":" Minimum input element range slider increment.\n","type":"Basics.Float -> VegaLite.InputProperty"},{"name":"joBevel","comment":" Bevelled stroke join.\n","type":"VegaLite.StrokeJoin"},{"name":"joMiter","comment":" Mitred stroke join.\n","type":"VegaLite.StrokeJoin"},{"name":"joRound","comment":" Rounded stroke join.\n","type":"VegaLite.StrokeJoin"},{"name":"jsonProperty","comment":" Property to be extracted from some JSON when it has some surrounding structure.\ne.g., specifying the property `values.features` is equivalent to retrieving\n`json.values.features` from a JSON object with a custom delimiter.\n","type":"String.String -> VegaLite.Format"},{"name":"lab","comment":" Lab color interpolation for continuous color scales.\n","type":"VegaLite.CInterpolate"},{"name":"layer","comment":" Assign a list of specifications to superposed layers in a visualization.\n","type":"List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"leClipHeight","comment":" Limit height of legend entries.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leColumnPadding","comment":" Horizontal padding between symbol legend entries.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leColumns","comment":" Number of columns in which to arrange symbol legend entries.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leCornerRadius","comment":" Legend corner radius.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leDirection","comment":" Direction of a legend.\n","type":"VegaLite.MarkOrientation -> VegaLite.LegendProperty"},{"name":"leDts","comment":" An explicit set of legend date-times.\n","type":"List.List (List.List VegaLite.DateTime) -> VegaLite.LegendValues"},{"name":"leFillColor","comment":" Legend background color.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leFormat","comment":" Formatting pattern for legend labels.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leGradient","comment":" A gradient legend for continuous quantitative data.\n","type":"VegaLite.Legend"},{"name":"leGradientLength","comment":" Length in pixels of the primary axis of a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leGradientStrokeColor","comment":" Color for strokes in a color ramp legend.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leGradientStrokeWidth","comment":" Width for strokes in a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leGradientThickness","comment":" Thickness in pixels of a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leGridAlign","comment":" Alignment to apply to symbol legends rows and columns.\n","type":"VegaLite.CompositionAlignment -> VegaLite.LegendProperty"},{"name":"leLabelAlign","comment":" Horizontal alignment of legend labels.\n","type":"VegaLite.HAlign -> VegaLite.LegendProperty"},{"name":"leLabelBaseline","comment":" Vertical alignment of legend labels.\n","type":"VegaLite.VAlign -> VegaLite.LegendProperty"},{"name":"leLabelColor","comment":" Color for legend labels.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leLabelFont","comment":" Font for legend labels.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leLabelFontSize","comment":" Font size legend labels.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leLabelLimit","comment":" Maximum width for legend labels in pixel units.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leLabelOffset","comment":" Offset for legend labels.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leLabelOverlap","comment":" Strategy for resolving overlapping legend labels.\n","type":"VegaLite.OverlapStrategy -> VegaLite.LegendProperty"},{"name":"leNums","comment":" An explicit set of numeric legend values.\n","type":"List.List Basics.Float -> VegaLite.LegendValues"},{"name":"leOffset","comment":" Offset in pixels of a legend from the edge of its enclosing group or data rectangle.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leOrient","comment":" Position of a legend in a scene.\n","type":"VegaLite.LegendOrientation -> VegaLite.LegendProperty"},{"name":"lePadding","comment":" Padding in pixels between a legend and axis.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leRowPadding","comment":" Vertical spacing in pixel units between a symbol legend entries.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leStrokeColor","comment":" Legend border color.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leStrokeWidth","comment":" Legend border stroke width.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leStrs","comment":" An explicit set of legend strings.\n","type":"List.List String.String -> VegaLite.LegendValues"},{"name":"leSymbol","comment":" A symbol legend for categorical data.\n","type":"VegaLite.Legend"},{"name":"leSymbolFillColor","comment":" Legend symbol fill color.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leSymbolSize","comment":" Legend symbol size.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leSymbolStrokeColor","comment":" Legend symbol outline color.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leSymbolStrokeWidth","comment":" Legend symbol stroke width.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leSymbolType","comment":" Legend symbol type.\n","type":"VegaLite.Symbol -> VegaLite.LegendProperty"},{"name":"leTickCount","comment":" Number of tick marks in a quantitative legend.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leTitle","comment":" Title of a legend.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leTitleAlign","comment":" Horizontal alignment for legend titles.\n","type":"VegaLite.HAlign -> VegaLite.LegendProperty"},{"name":"leTitleBaseline","comment":" Vertical alignment for legend titles.\n","type":"VegaLite.VAlign -> VegaLite.LegendProperty"},{"name":"leTitleColor","comment":" Color for legend title.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leTitleFont","comment":" Font for legend titles.\n","type":"String.String -> VegaLite.LegendProperty"},{"name":"leTitleFontSize","comment":" Font size for legend titles.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leTitleFontWeight","comment":" Font weight for legend titles.\n","type":"VegaLite.FontWeight -> VegaLite.LegendProperty"},{"name":"leTitleLimit","comment":" Maximum size in pixel units for legend titles.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leTitlePadding","comment":" Spacing in pixel units between title and legend.\n","type":"Basics.Float -> VegaLite.LegendProperty"},{"name":"leType","comment":" Type of legend.\n","type":"VegaLite.Legend -> VegaLite.LegendProperty"},{"name":"leValues","comment":" An explicit set of legend values.\n","type":"VegaLite.LegendValues -> VegaLite.LegendProperty"},{"name":"leZIndex","comment":" Drawing order of a legend relative to other chart elements. To\nplace a legend in front of others use a positive integer, or 0 to draw behind.\n","type":"Basics.Int -> VegaLite.LegendProperty"},{"name":"lecoClipHeight","comment":" Default maximum height of legend entries.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoColumnPadding","comment":" Default horizontal padding between symbol legend entries.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoColumns","comment":" Default number of columns in which to arrange symbol legend entries.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoCornerRadius","comment":" Default legend corner radius.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoEntryPadding","comment":" Default spacing between legend items.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoFillColor","comment":" Default background legend color.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoGradientDirection","comment":" Default direction of a color ramp legend.\n","type":"VegaLite.MarkOrientation -> VegaLite.LegendConfig"},{"name":"lecoGradientHeight","comment":" Default height of a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoGradientLabelBaseline","comment":" Default vertical alignment for labels in a color ramp legend.\n","type":"VegaLite.VAlign -> VegaLite.LegendConfig"},{"name":"lecoGradientLabelLimit","comment":" Default maximum allowable length for labels in a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoGradientLabelOffset","comment":" Default vertical offset in pixel units for labels in a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoGradientStrokeColor","comment":" Default color for strokes in a color ramp legend.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoGradientStrokeWidth","comment":" Default width for strokes in a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoGradientWidth","comment":" Default width of a color ramp legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoGridAlign","comment":" Defailt alignment to apply to symbol legends rows and columns.\n","type":"VegaLite.CompositionAlignment -> VegaLite.LegendConfig"},{"name":"lecoLabelAlign","comment":" Default horizontal alignment of legend labels.\n","type":"VegaLite.HAlign -> VegaLite.LegendConfig"},{"name":"lecoLabelBaseline","comment":" Default vertical alignment of legend labels.\n","type":"VegaLite.VAlign -> VegaLite.LegendConfig"},{"name":"lecoLabelColor","comment":" Default color for legend labels.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoLabelFont","comment":" Default font for legend labels.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoLabelFontSize","comment":" Default font size legend labels.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoLabelLimit","comment":" Default maximum width for legend labels in pixel units.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoLabelOffset","comment":" Default offset for legend labels.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoLabelOverlap","comment":" Strategy for resolving overlapping legend labels.\n","type":"VegaLite.OverlapStrategy -> VegaLite.LegendConfig"},{"name":"lecoOffset","comment":" Default offset in pixel units between the legend and the enclosing\ngroup or data rectangle.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoOrient","comment":" Default legend position relative to the main plot content.\n","type":"VegaLite.LegendOrientation -> VegaLite.LegendConfig"},{"name":"lecoPadding","comment":" Default spacing in pixel units between a legend and axis.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoRowPadding","comment":" Default vertical spacing in pixel units between legend symbol entries.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoShortTimeLabels","comment":" Whether or not time labels are abbreviated by default in a legend.\n","type":"Basics.Bool -> VegaLite.LegendConfig"},{"name":"lecoStrokeColor","comment":" Default legend border color.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoStrokeDash","comment":" Default legend border stroke dash style.\n","type":"List.List Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoStrokeWidth","comment":" Default legend border stroke width.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoSymbolBaseFillColor","comment":" Default legend symbol fill color for when no fill scale color in legend encoding.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoSymbolBaseStrokeColor","comment":" Default legend symbol stroke color for when no stroke scale color in legend encoding.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoSymbolDirection","comment":" Default direction of a symbol legend.\n","type":"VegaLite.MarkOrientation -> VegaLite.LegendConfig"},{"name":"lecoSymbolFillColor","comment":" Default legend symbol fill color.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoSymbolOffset","comment":" Default horizontal pixel offset for legend symbols.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoSymbolSize","comment":" Default legend symbol size.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoSymbolStrokeColor","comment":" Default legend symbol outline color.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoSymbolStrokeWidth","comment":" Default legend symbol stroke width.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoSymbolType","comment":" Default legend symbol type.\n","type":"VegaLite.Symbol -> VegaLite.LegendConfig"},{"name":"lecoTitleAlign","comment":" Default horizontal alignment for legend titles.\n","type":"VegaLite.HAlign -> VegaLite.LegendConfig"},{"name":"lecoTitleBaseline","comment":" Default vertical alignment for legend titles.\n","type":"VegaLite.VAlign -> VegaLite.LegendConfig"},{"name":"lecoTitleColor","comment":" Default color legend titles.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoTitleFont","comment":" Default font for legend titles.\n","type":"String.String -> VegaLite.LegendConfig"},{"name":"lecoTitleFontSize","comment":" Default font size for legend titles.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoTitleFontWeight","comment":" Default font weight for legend titles.\n","type":"VegaLite.FontWeight -> VegaLite.LegendConfig"},{"name":"lecoTitleLimit","comment":" Default maximum size in pixel units for legend titles.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"lecoTitlePadding","comment":" Default spacing in pixel units between title and legend.\n","type":"Basics.Float -> VegaLite.LegendConfig"},{"name":"line","comment":" [Line mark](https://vega.github.io/vega-lite/docs/line.html) for symbolising\na sequence of values.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"lmMarker","comment":" Properties of a line marker that is overlaid on an area mark.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.LineMarker"},{"name":"lmNone","comment":" Indicates no line marker on an area mark.\n","type":"VegaLite.LineMarker"},{"name":"loBottomLeft","comment":" Position legend to the bottom-left of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"loBottomRight","comment":" Position legend to the bottom-right of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"loLeft","comment":" Position legend to the left of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"loNone","comment":" Do not perform automatic legend positioning (allows legend to be located explicitly\nvia `x` `y` coordinates).\n","type":"VegaLite.LegendOrientation"},{"name":"loRight","comment":" Position legend to the right of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"loTopLeft","comment":" Position legend to the top-left of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"loTopRight","comment":" Position legend to the top-right of the visualization it describes.\n","type":"VegaLite.LegendOrientation"},{"name":"lookup","comment":" Perform a lookup of named fields between two data sources. This allows you to\nfind values in one data source based on the values in another. The first parameter\nis the field in the primary data source to act as key, the second is the secondary\ndata source which can be specified with a call to `dataFromUrl` or other data\ngenerating function. The third is the name of the field in the secondary\ndata source to match values with the primary key. The fourth parameter is the list\nof fields to be stored when the keys match.\n","type":"String.String -> ( VegaLite.VLProperty, VegaLite.Spec ) -> String.String -> List.List String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"lookupAs","comment":" Similar to [lookup](#lookup) but returns the entire set of field values from\nthe secondary data source when keys match. Accessed with via name provided in the\nfourth parameter.\n","type":"String.String -> VegaLite.Data -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"mAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\nmark property channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.MarkChannel"},{"name":"mBin","comment":" Discretize numeric values into bins when encoding with a mark property channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.MarkChannel"},{"name":"mBinned","comment":" Indicate that data encoding with a mark are already binned.\n","type":"VegaLite.MarkChannel"},{"name":"mBoo","comment":" Boolean value when encoding with a mark property channel.\n","type":"Basics.Bool -> VegaLite.MarkChannel"},{"name":"mDataCondition","comment":" Make a mark channel conditional on one or more predicate expressions. The first\nparameter is a list of tuples each pairing a test condition with the encoding if\nthat condition evaluates to true. The second is the encoding if none of the tests\nare true.\n\n    color\n        [ mDataCondition [ ( expr \"datum.myField === null\", [ mStr \"grey\" ] ) ]\n            [ mStr \"black\" ]\n        ]\n\n","type":"List.List ( VegaLite.BooleanOp, List.List VegaLite.MarkChannel ) -> List.List VegaLite.MarkChannel -> VegaLite.MarkChannel"},{"name":"mImpute","comment":" Iputation rules for a mark channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n","type":"List.List VegaLite.ImputeProperty -> VegaLite.MarkChannel"},{"name":"mLegend","comment":" Properties of a legend that describes a mark's encoding. For no legend, provide\nan empty list as a parameter.\n","type":"List.List VegaLite.LegendProperty -> VegaLite.MarkChannel"},{"name":"mMType","comment":" Level of measurement when encoding with a mark property channel.\n","type":"VegaLite.Measurement -> VegaLite.MarkChannel"},{"name":"mName","comment":" Field used for encoding with a mark property channel.\n","type":"String.String -> VegaLite.MarkChannel"},{"name":"mNum","comment":" Literal numeric value when encoding with a mark property channel.\n","type":"Basics.Float -> VegaLite.MarkChannel"},{"name":"mPath","comment":" SVG path string used when encoding with a mark property channel. Useful\nfor providing custom shapes.\n","type":"String.String -> VegaLite.MarkChannel"},{"name":"mRepeat","comment":" Reference in a mark channel to a field name generated by `repeat`. The\nparameter identifies whether fields are to be laid out in columns or rows.\n","type":"VegaLite.Arrangement -> VegaLite.MarkChannel"},{"name":"mScale","comment":" Scaling applied to a field when encoding with a mark property channel.\nThe scale will transform a field's value into a color, shape, size etc.\n","type":"List.List VegaLite.ScaleProperty -> VegaLite.MarkChannel"},{"name":"mSelectionCondition","comment":" Make a mark channel conditional on interactive selection. The first parameter\nis a selection condition to evaluate; the second the encoding to apply if that selection\nis true; the third parameter is the encoding if the selection is false.\n\n    color\n        [ mSelectionCondition (selectionName \"myBrush\")\n            [ mName \"myField\", mMType Ordinal ]\n            [ mStr \"grey\" ]\n        ]\n\n","type":"VegaLite.BooleanOp -> List.List VegaLite.MarkChannel -> List.List VegaLite.MarkChannel -> VegaLite.MarkChannel"},{"name":"mStr","comment":" Literal string value when encoding with a mark property channel.\n","type":"String.String -> VegaLite.MarkChannel"},{"name":"mTimeUnit","comment":" Time unit aggregation of field values when encoding with a mark property channel.\n","type":"VegaLite.TimeUnit -> VegaLite.MarkChannel"},{"name":"mTitle","comment":" Title of a field when encoding with a mark property channel.\n","type":"String.String -> VegaLite.MarkChannel"},{"name":"maAlign","comment":" Horizontal alignment of a text mark.\n","type":"VegaLite.HAlign -> VegaLite.MarkProperty"},{"name":"maAngle","comment":" Rotation angle in degrees of a text mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maBandSize","comment":" Band size of a bar mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maBaseline","comment":" Vertical alignment of a text mark.\n","type":"VegaLite.VAlign -> VegaLite.MarkProperty"},{"name":"maBinSpacing","comment":" Offset between bars for a binned field using a bar mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maBorders","comment":" Border properties for an errorband mark.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"},{"name":"maClip","comment":" Whether or not a mark should be clipped to the enclosing group's dimensions.\n","type":"Basics.Bool -> VegaLite.MarkProperty"},{"name":"maColor","comment":" Default color of a mark. Note that `maFill` and `maStroke` have higher\nprecedence and will override this if specified.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maContinuousBandSize","comment":" Continuous band size of a bar mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maCursor","comment":" Cursor to be associated with a hyperlink mark.\n","type":"VegaLite.Cursor -> VegaLite.MarkProperty"},{"name":"maDiscreteBandSize","comment":" Discrete band size of a bar mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maDx","comment":" Horizontal offset between a text mark and its anchor.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maDy","comment":" Vertical offset between a text mark and its anchor.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maExtent","comment":" Extent of whiskers used in a boxplot, error bars or error bands.\n","type":"VegaLite.SummaryExtent -> VegaLite.MarkProperty"},{"name":"maFill","comment":" Default fill color of a mark.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maFillOpacity","comment":" Fill opacity of a mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maFilled","comment":" Whether or not a mark's color should be used as the fill color instead of\nstroke color.\n","type":"Basics.Bool -> VegaLite.MarkProperty"},{"name":"maFont","comment":" Font of a text mark. Can be any font name made accessible via\na css file (or a generic font like `serif`, `monospace` etc.).\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maFontSize","comment":" Font size in pixels used by a text mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maFontStyle","comment":" Font style (e.g. `italic`) used by a text mark.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maFontWeight","comment":" Font weight used by a text mark.\n","type":"VegaLite.FontWeight -> VegaLite.MarkProperty"},{"name":"maHRef","comment":" Hyperlink to be associated with a mark making it a clickable hyperlink.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maInterpolate","comment":" Interpolation method used by line and area marks.\n","type":"VegaLite.MarkInterpolation -> VegaLite.MarkProperty"},{"name":"maLine","comment":" Appearance of a line marker joining the vertices of an area mark.\n","type":"VegaLite.LineMarker -> VegaLite.MarkProperty"},{"name":"maOpacity","comment":" Overal opacity of a mark in the range 0 to 1.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maOrient","comment":" Orientation of a non-stacked bar, tick, area or line mark.\n","type":"VegaLite.MarkOrientation -> VegaLite.MarkProperty"},{"name":"maPoint","comment":" Appearance of a point marker joining the vertices of a line or area mark.\n","type":"VegaLite.PointMarker -> VegaLite.MarkProperty"},{"name":"maRadius","comment":" Polar coordinate radial offset of a text mark from its origin.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maRule","comment":" Rule (main line) properties for the errorbar mark.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"},{"name":"maShape","comment":" Shape of a point mark.\n","type":"VegaLite.Symbol -> VegaLite.MarkProperty"},{"name":"maShortTimeLabels","comment":" Whether or not month and weekday names are abbreviated in a text mark.\n","type":"Basics.Bool -> VegaLite.MarkProperty"},{"name":"maSize","comment":" Size of a mark in square units.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maStroke","comment":" Default stroke color of a mark.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maStrokeCap","comment":" Cap style of a mark's stroke.\n","type":"VegaLite.StrokeCap -> VegaLite.MarkProperty"},{"name":"maStrokeDash","comment":" Stroke dash style used by a mark. Determined by an alternating 'on-off'\nsequence of line lengths.\n","type":"List.List Basics.Float -> VegaLite.MarkProperty"},{"name":"maStrokeDashOffset","comment":" Number of pixels before the first line dash is drawn.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maStrokeJoin","comment":" Line segment join style of a mark's stroke.\n","type":"VegaLite.StrokeJoin -> VegaLite.MarkProperty"},{"name":"maStrokeMiterLimit","comment":" Mitre limit at which to bevel a join between line segments of a mark's stroke.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maStrokeOpacity","comment":" Stroke opacity of a mark in the range 0 to 1.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maStrokeWidth","comment":" Stroke width of a mark in pixel units.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maStyle","comment":" Names of custom styles to apply to a mark. Each should refer to a named style\ndefined in a separate style configuration.\n","type":"List.List String.String -> VegaLite.MarkProperty"},{"name":"maTension","comment":" Interpolation tension used when interpolating line and area marks.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maText","comment":" Placeholder text for a text mark for when a text channel is not specified.\n","type":"String.String -> VegaLite.MarkProperty"},{"name":"maTheta","comment":" Polar coordinate angle (clockwise from north in radians) of a text mark from\nthe origin determined by its x and y properties.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maThickness","comment":" Thickness of a tick mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maTicks","comment":" Tick properties for the errorbar mark.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.MarkProperty"},{"name":"maTooltip","comment":" Source of a mark's tooltip content.\n","type":"VegaLite.TooltipContent -> VegaLite.MarkProperty"},{"name":"maX2Offset","comment":" X2 position offset for a mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maXOffset","comment":" X position offset for a mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maY2Offset","comment":" Y2 position offset for a mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"maYOffset","comment":" Y position offset for a mark.\n","type":"Basics.Float -> VegaLite.MarkProperty"},{"name":"mercator","comment":" A Mercator map projection.\n","type":"VegaLite.Projection"},{"name":"miBasis","comment":" Cubic basis spline interpolation between points anchored at first and last points.\n","type":"VegaLite.MarkInterpolation"},{"name":"miBasisClosed","comment":" Closed cubic basis spline interpolation between points forming a polygon.\n","type":"VegaLite.MarkInterpolation"},{"name":"miBasisOpen","comment":" Open cubic basis spline interpolation between points, which may not intersect\nfirst and last points.\n","type":"VegaLite.MarkInterpolation"},{"name":"miBundle","comment":" Bundle curve interpolation between points.\n","type":"VegaLite.MarkInterpolation"},{"name":"miCardinal","comment":" Cubic cardinal spline interpolation between points anchored at first and last\npoints.\n","type":"VegaLite.MarkInterpolation"},{"name":"miCardinalClosed","comment":" Closed cubic cardinal spline interpolation between points forming a polygon.\n","type":"VegaLite.MarkInterpolation"},{"name":"miCardinalOpen","comment":" Open cubic cardinal spline interpolation between points, which may not intersect\nfirst and last points\n","type":"VegaLite.MarkInterpolation"},{"name":"miLinear","comment":" Linear (straight) interpolation between points.\n","type":"VegaLite.MarkInterpolation"},{"name":"miMonotone","comment":" Cubic spline interpolation that preserves monotonicity between points.\n","type":"VegaLite.MarkInterpolation"},{"name":"miStepAfter","comment":" Piecewise (stepped) constant interpolation function after each point in a sequence.\n","type":"VegaLite.MarkInterpolation"},{"name":"miStepBefore","comment":" Piecewise (stepped) constant interpolation function before each point in a sequence.\n","type":"VegaLite.MarkInterpolation"},{"name":"miStepwise","comment":" Piecewise (stepped) constant interpolation function centred on each point in\na sequence.\n","type":"VegaLite.MarkInterpolation"},{"name":"milliseconds","comment":" Milliseconds time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"minutes","comment":" Minute of the hour time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"minutesSeconds","comment":" Minutes and seconds time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"moHorizontal","comment":" Indicate horizontal mark orientation.\n","type":"VegaLite.MarkOrientation"},{"name":"moVertical","comment":" Indicate vertical mark orientation.\n","type":"VegaLite.MarkOrientation"},{"name":"month","comment":" Month of the year (1-12) time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"monthDate","comment":" Month and day of month time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"name","comment":" Name to be associated with a visualization.\n","type":"String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"niDay","comment":" Nice time intervals that try to align with whole or rounded days.\n","type":"VegaLite.ScaleNice"},{"name":"niFalse","comment":" Disable nice scaling.\n","type":"VegaLite.ScaleNice"},{"name":"niHour","comment":" Nice time intervals that try to align with whole or rounded hours.\n","type":"VegaLite.ScaleNice"},{"name":"niInterval","comment":" 'Nice' temporal interval values when scaling.\n","type":"VegaLite.TimeUnit -> Basics.Int -> VegaLite.ScaleNice"},{"name":"niMillisecond","comment":" Nice time intervals that try to align with rounded milliseconds.\n","type":"VegaLite.ScaleNice"},{"name":"niMinute","comment":" Nice time intervals that try to align with whole or rounded minutes.\n","type":"VegaLite.ScaleNice"},{"name":"niMonth","comment":" Nice time intervals that try to align with whole or rounded months.\n","type":"VegaLite.ScaleNice"},{"name":"niSecond","comment":" Nice time intervals that try to align with whole or rounded seconds.\n","type":"VegaLite.ScaleNice"},{"name":"niTickCount","comment":" Desired number of tick marks in a 'nice' scaling.\n","type":"Basics.Int -> VegaLite.ScaleNice"},{"name":"niTrue","comment":" Enable nice scaling.\n","type":"VegaLite.ScaleNice"},{"name":"niWeek","comment":" Nice time intervals that try to align with whole or rounded weeks.\n","type":"VegaLite.ScaleNice"},{"name":"niYear","comment":" Nice time intervals that try to align with whole or rounded years.\n","type":"VegaLite.ScaleNice"},{"name":"noClip","comment":" Inidicate no clipping to be applied.\n","type":"VegaLite.ClipRect"},{"name":"not","comment":" Apply a negation Boolean operation as part of a logical composition. Boolean\noperations can be nested to any level.\n\n    not (and (expr \"datum.IMDB_Rating === null\") (expr \"datum.Rotten_Tomatoes_Rating === null\"))\n\n","type":"VegaLite.BooleanOp -> VegaLite.BooleanOp"},{"name":"num","comment":" A numeric data value.\n","type":"Basics.Float -> VegaLite.DataValue"},{"name":"numRange","comment":" Minimum-maximum number range to be used in data filtering.\n","type":"Basics.Float -> Basics.Float -> VegaLite.FilterRange"},{"name":"nums","comment":" List of numeric data values.\n","type":"List.List Basics.Float -> VegaLite.DataValues"},{"name":"oAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with an\norder channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.OrderChannel"},{"name":"oBin","comment":" Discretize numeric values into bins when encoding with an order channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.OrderChannel"},{"name":"oMType","comment":" Level of measurement when encoding with an order channel.\n","type":"VegaLite.Measurement -> VegaLite.OrderChannel"},{"name":"oName","comment":" Name of the field used for encoding with an order channel.\n","type":"String.String -> VegaLite.OrderChannel"},{"name":"oRepeat","comment":" Reference in a order channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n","type":"VegaLite.Arrangement -> VegaLite.OrderChannel"},{"name":"oSort","comment":" Sort order to be used by an order channel.\n","type":"List.List VegaLite.SortProperty -> VegaLite.OrderChannel"},{"name":"oTimeUnit","comment":" Time unit aggregation of field values when encoding with an order channel.\n","type":"VegaLite.TimeUnit -> VegaLite.OrderChannel"},{"name":"opArgMax","comment":" An input data object containing the maximum field value to be used in an\naggregation operation.\n","type":"VegaLite.Operation"},{"name":"opArgMin","comment":" An input data object containing the minimum field value to be used in an\naggregation operation.\n","type":"VegaLite.Operation"},{"name":"opAs","comment":" Aggregation operation. The first parameter is the operation to use; the second\nthe name of the field in which to apply it and the third the name to be given to\nthis transformation.\n\n    trans =\n        transform\n            << aggregate\n                [ opAs opMin \"people\" \"lowerBound\"\n                , opAs opMax \"people\" \"upperBound\"\n                ]\n                [ \"age\" ]\n\nIf the operation is `Count`, it does not apply to any specific field, so the second\nparameter can be an empty string.\n\n","type":"VegaLite.Operation -> String.String -> String.String -> VegaLite.Spec"},{"name":"opCI0","comment":" Lower 95% confidence interval to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opCI1","comment":" Upper 95% confidence interval to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opCount","comment":" Total count of data objects to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opDistinct","comment":" Count of distinct data objects to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opMax","comment":" Maximum field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opMean","comment":" Mean value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opMedian","comment":" Median field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opMin","comment":" Minimum field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opMissing","comment":" Count of null or undefined field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opQ1","comment":" Lower quartile boundary of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opQ3","comment":" Upper quartile boundary of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opStderr","comment":" Standard error of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opStdev","comment":" Sample standard deviation of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opStdevP","comment":" Population standard deviation of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opSum","comment":" Sum of field values to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opValid","comment":" Count of values that are not `null`, `undefined` or `NaN` to be used in an\naggregation operation.\n","type":"VegaLite.Operation"},{"name":"opVariance","comment":" Sample variance of field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opVarianceP","comment":" Population variance of field value to be used in an aggregation operation.\n","type":"VegaLite.Operation"},{"name":"opacity","comment":" Encode an opacity channel.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"or","comment":" Apply an 'or' Boolean operation as part of a logical composition.\n","type":"VegaLite.BooleanOp -> VegaLite.BooleanOp -> VegaLite.BooleanOp"},{"name":"order","comment":" Encode an order channel with a list of order field definitions.\n","type":"List.List VegaLite.OrderChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"orthographic","comment":" An orthographic map projection.\n","type":"VegaLite.Projection"},{"name":"osGreedy","comment":" Greedy overlap strategy to be applied when there is not space to show all items on an axis.\n","type":"VegaLite.OverlapStrategy"},{"name":"osNone","comment":" No overlap strategy to be applied when there is not space to show all items on an axis.\n","type":"VegaLite.OverlapStrategy"},{"name":"osParity","comment":" Give all items equal weight in overlap strategy to be applied when there is\nnot space to show them all on an axis.\n","type":"VegaLite.OverlapStrategy"},{"name":"pAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\nposition channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.PositionChannel"},{"name":"pAxis","comment":" Axis properties used when encoding with a position channel. For no axis,\nprovide an empty list.\n","type":"List.List VegaLite.AxisProperty -> VegaLite.PositionChannel"},{"name":"pBin","comment":" Discretize numeric values into bins when encoding with a position channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.PositionChannel"},{"name":"pBinned","comment":" Indicate that data encoded with position are already binned.\n","type":"VegaLite.PositionChannel"},{"name":"pHeight","comment":" Set the position to the height of the enclosing data space. Useful for placing\na mark relative to the bottom edge of a view.\n","type":"VegaLite.PositionChannel"},{"name":"pImpute","comment":" Imputation rules for a position channel. See the\n[Vega-Lite impute documentation](https://vega.github.io/vega-lite/docs/impute.html)\n","type":"List.List VegaLite.ImputeProperty -> VegaLite.PositionChannel"},{"name":"pMType","comment":" Level of measurement when encoding with a position channel.\n","type":"VegaLite.Measurement -> VegaLite.PositionChannel"},{"name":"pName","comment":" Name of the field used for encoding with a position channel.\n","type":"String.String -> VegaLite.PositionChannel"},{"name":"pRepeat","comment":" Arrangement of views in a repeated composite view.\n","type":"VegaLite.Arrangement -> VegaLite.PositionChannel"},{"name":"pScale","comment":" Scaling applied to a field when encoding with a position channel.\nThe scale will transform a field's value into a position along one axis.\n","type":"List.List VegaLite.ScaleProperty -> VegaLite.PositionChannel"},{"name":"pSort","comment":" Sort order for field when encoding with a position channel.\n","type":"List.List VegaLite.SortProperty -> VegaLite.PositionChannel"},{"name":"pStack","comment":" Type of stacking offset for field when encoding with a position channel.\n","type":"VegaLite.StackOffset -> VegaLite.PositionChannel"},{"name":"pTimeUnit","comment":" Form of time unit aggregation of field values when encoding with a position channel.\n","type":"VegaLite.TimeUnit -> VegaLite.PositionChannel"},{"name":"pTitle","comment":" Title of a field when encoding with a position channel.\n","type":"String.String -> VegaLite.PositionChannel"},{"name":"pWidth","comment":" Set the position to the width of the enclosing data space. Useful for justifying\na mark to the right hand edge of a view. e.g. to position a mark at the right of\nthe data rectangle:\n\n    enc =\n        encoding\n            << position X [ pWidth ]\n\n","type":"VegaLite.PositionChannel"},{"name":"paEdges","comment":" Padding around a visualization in pixel units. The four parameters\nrefer to _left_, _top_, _right_, and _bottom_ edges respectively.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.Padding"},{"name":"paSize","comment":" Indicate uniform padding around a visualization in pixel units.\n","type":"Basics.Float -> VegaLite.Padding"},{"name":"padding","comment":" Padding around the visualization in pixel units. The way padding is interpreted\nwill depend on the `autosize` properties.\n","type":"VegaLite.Padding -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"parse","comment":" Parsing rules when processing some data text, specified as a list of tuples\nin the form (_fieldname_, _datatype_). If an empty list is provided, type inference\nis based on the data.\n","type":"List.List ( String.String, VegaLite.DataType ) -> VegaLite.Format"},{"name":"pmMarker","comment":" Properties of a point marker that is overlaid on a line or area mark.\n","type":"List.List VegaLite.MarkProperty -> VegaLite.PointMarker"},{"name":"pmNone","comment":" No point marker to be shown on a line or area mark.\n","type":"VegaLite.PointMarker"},{"name":"pmTransparent","comment":" Transparent point marker to be placed on area or line mark. Useful for\ninteractive selections.\n","type":"VegaLite.PointMarker"},{"name":"point","comment":" [Point mark](https://vega.github.io/vega-lite/docs/point.html) for\nsymbolising a data point with a symbol.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"position","comment":" Encode a position channel. The first parameter identifies the channel,\nthe second a list of encoding options.\n","type":"VegaLite.Position -> List.List VegaLite.PositionChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"prCenter","comment":" Projection’s center as longitude and latitude in degrees.\n","type":"Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prClipAngle","comment":" Projection’s clipping circle radius to the specified angle in degrees.\nA value of `Nothing` will switch to antimeridian cutting rather than small-circle\nclipping.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prClipExtent","comment":" Projection’s viewport clip extent to the specified bounds in pixels.\n","type":"VegaLite.ClipRect -> VegaLite.ProjectionProperty"},{"name":"prCoefficient","comment":" 'Hammer' map projection coefficient.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prDistance","comment":" 'Satellite' map projection distance.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prFraction","comment":" `Bottomley` map projection fraction.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prLobes","comment":" Number of lobes in lobed map projections such as the 'Berghaus star'.\n","type":"Basics.Int -> VegaLite.ProjectionProperty"},{"name":"prParallel","comment":" Parallel for map projections such as the 'Armadillo'.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prPrecision","comment":" Threshold for the projection’s adaptive resampling in pixels.\nCorresponds to the Douglas–Peucker distance. If precision is not specified, the\nprojection’s current resampling precision of 0.707 is used.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prRadius","comment":" Radius value for map projections such as the 'Gingery'.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prRatio","comment":" Ratio value for map projections such as the 'Hill'.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prRotate","comment":" Projection’s three-axis rotation angle. This should be in order _lambda phi\ngamma_ specifying the rotation angles in degrees about each spherical axis.\n","type":"Basics.Float -> Basics.Float -> Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prSpacing","comment":" Spacing value for map projections such as the 'Lagrange'.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prTilt","comment":" 'Satellite' map projection tilt.\n","type":"Basics.Float -> VegaLite.ProjectionProperty"},{"name":"prType","comment":" Type of global map projection.\n","type":"VegaLite.Projection -> VegaLite.ProjectionProperty"},{"name":"projection","comment":" Map projection used for geospatial coordinates.\n","type":"List.List VegaLite.ProjectionProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"quarter","comment":" Year quarter time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"quarterMonth","comment":" Year quarter and month time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"raName","comment":" Name of a pre-defined scale range (e.g. `symbol` or `diverging`).\n","type":"String.String -> VegaLite.ScaleRange"},{"name":"raNums","comment":" Numeric scale range. Depending on the scaling this may be a [min, max]\npair, or a list of explicit numerical values.\n","type":"List.List Basics.Float -> VegaLite.ScaleRange"},{"name":"raStrs","comment":" Text scale range for discrete scales.\n","type":"List.List String.String -> VegaLite.ScaleRange"},{"name":"racoCategory","comment":" Default color scheme for categorical ranges.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"racoDiverging","comment":" Default diverging color scheme.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"racoHeatmap","comment":" Default 'heatmap' color scheme.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"racoOrdinal","comment":" Default ordinal color scheme.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"racoRamp","comment":" Default ramp (continuous) color scheme.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"racoSymbol","comment":" Default color scheme symbols.\n","type":"String.String -> VegaLite.RangeConfig"},{"name":"reAxis","comment":" Indicate how a channel's axes should be resolved when defined in more than\none view in a composite visualization.\n","type":"List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"},{"name":"reIndependent","comment":" Scale domain should be independent of others in a composite visualization.\n","type":"VegaLite.Resolution"},{"name":"reLegend","comment":" Indicate how a channel's legends should be resolved when defined in more\nthan one view in a composite visualization.\n","type":"List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"},{"name":"reScale","comment":" Indicate how a channel's scales should be resolved when defined in more\nthan one view in a composite visualization.\n","type":"List.List ( VegaLite.Channel, VegaLite.Resolution ) -> VegaLite.Resolve"},{"name":"reShared","comment":" Scale domain should be shared with others in a composite visualization.\n","type":"VegaLite.Resolution"},{"name":"rect","comment":" [Rectangle mark](https://vega.github.io/vega-lite/docs/rect.html).\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"repeat","comment":" Define the fields that will be used to compose rows and columns of a set of\nsmall multiples. Used when the encoding largely identical, but the data field used\nin each might vary. When a list of fields is identified with `repeat` you also\nneed to define a full specification to apply to each of those fields using `asSpec`.\n\n    spec = ...\n    toVegaLite\n        [ repeat [ columnFields [ \"Cat\", \"Dog\", \"Fish\" ] ]\n        , specification (asSpec spec)\n        ]\n\n","type":"List.List VegaLite.RepeatFields -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"resolution","comment":" Define a resolution option to be applied when scales, axes or legends in composite\nviews share channel encodings. This allows different color encodings to be created\nin a layered view, which would otherwise share color channels between layers. Each\nresolution rule should be in a tuple pairing the channel to which it applies and\nthe rule type. The first parameter identifies the type of resolution.\n\n    resolve\n        << resolution (reScale [ ( chY, reIndependent ) ])\n\n","type":"VegaLite.Resolve -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"resolve","comment":" Determine whether scales, axes or legends in composite views should share channel\nencodings.\n","type":"List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"rgb","comment":" RGB color interpolation for continuous color scales using the given gamma\nvalue (anchored at 1).\n","type":"Basics.Float -> VegaLite.CInterpolate"},{"name":"row","comment":" Encode a new facet to be arranged in rows. The first parameter is a list of\nfacet properties that define the faceting channel.\n","type":"List.List VegaLite.FacetChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"rowBy","comment":" Tthe mapping between a row and its field definitions in a set of faceted\nsmall multiples.\n","type":"List.List VegaLite.FacetChannel -> VegaLite.FacetMapping"},{"name":"rowFields","comment":" Create a list of fields to use in set of repeated small multiples arranged in\nrows. The list of fields named here can be referenced in an encoding with\n`pRepeat row`, `mRepeat row` etc.\n","type":"List.List String.String -> VegaLite.RepeatFields"},{"name":"rule","comment":" [Rule line](https://vega.github.io/vega-lite/docs/rule.html) connecting\ntwo vertices.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"sacoBandPaddingInner","comment":" Default inner padding for x and y band-ordinal scales.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoBandPaddingOuter","comment":" Default outer padding for x and y band-ordinal scales.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoClamp","comment":" Whether or not by default values that exceed the data domain are clamped to\nthe min/max range value.\n","type":"Basics.Bool -> VegaLite.ScaleConfig"},{"name":"sacoMaxBandSize","comment":" Default maximum value for mapping quantitative fields to a bar's\nsize/bandSize.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMaxFontSize","comment":" Default maximum value for mapping a quantitative field to a text\nmark's size.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMaxOpacity","comment":" Default maximum opacity (in the range [0, 1]) for mapping a field\nto opacity.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMaxSize","comment":" Default maximum size for point-based scales.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMaxStrokeWidth","comment":" Default maximum stroke width for rule, line and trail marks.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMinBandSize","comment":" Default minimum value for mapping quantitative fields to a bar's size/bandSize.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMinFontSize","comment":" Default minimum value for mapping a quantitative field to a text mark's size.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMinOpacity","comment":" Default minimum opacity (0 to 1) for mapping a field to opacity.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMinSize","comment":" Default minimum size for point-based scales (when not forced to start at zero).\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoMinStrokeWidth","comment":" Default minimum stroke width for rule, line and trail marks.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoPointPadding","comment":" Default padding for point-ordinal scales.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoRangeStep","comment":" Default range step for band and point scales when the mark is not text.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoRound","comment":" Whether or not numeric values are rounded to integers when scaling. Useful\nfor snapping to the pixel grid.\n","type":"Basics.Bool -> VegaLite.ScaleConfig"},{"name":"sacoTextXRangeStep","comment":" Default range step for x band and point scales of text marks.\n","type":"Basics.Float -> VegaLite.ScaleConfig"},{"name":"sacoUseUnaggregatedDomain","comment":" Whether or not to use the source data range before aggregation.\n","type":"Basics.Bool -> VegaLite.ScaleConfig"},{"name":"sample","comment":" Randomly sample rows from a data source up to a given maximum.\n","type":"Basics.Float -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"scBand","comment":" A band scale.\n","type":"VegaLite.Scale"},{"name":"scBinLinear","comment":" A linear band scale.\n","type":"VegaLite.Scale"},{"name":"scBinOrdinal","comment":" An ordinal band scale.\n","type":"VegaLite.Scale"},{"name":"scClamp","comment":" Whether or not values outside the data domain are clamped to the minimum or\nmaximum value.\n","type":"Basics.Bool -> VegaLite.ScaleProperty"},{"name":"scDomain","comment":" Custom scaling domain.\n","type":"VegaLite.ScaleDomain -> VegaLite.ScaleProperty"},{"name":"scInterpolate","comment":" Interpolation method for scaling range values.\n","type":"VegaLite.CInterpolate -> VegaLite.ScaleProperty"},{"name":"scLinear","comment":" A linear scale.\n","type":"VegaLite.Scale"},{"name":"scLog","comment":" A log scale.\n","type":"VegaLite.Scale"},{"name":"scNice","comment":" 'Nice' minimum and maximum values in a scaling (e.g. multiples of 10).\n","type":"VegaLite.ScaleNice -> VegaLite.ScaleProperty"},{"name":"scOrdinal","comment":" An ordinal scale.\n","type":"VegaLite.Scale"},{"name":"scPadding","comment":" Padding in pixels to apply to a scaling.\n","type":"Basics.Float -> VegaLite.ScaleProperty"},{"name":"scPaddingInner","comment":" Inner padding to apply to a band scaling.\n","type":"Basics.Float -> VegaLite.ScaleProperty"},{"name":"scPaddingOuter","comment":" Outer padding to apply to a band scaling.\n","type":"Basics.Float -> VegaLite.ScaleProperty"},{"name":"scPoint","comment":" A point scale.\n","type":"VegaLite.Scale"},{"name":"scPow","comment":" A power scale.\n","type":"VegaLite.Scale"},{"name":"scQuantile","comment":" A quantile scale.\n","type":"VegaLite.Scale"},{"name":"scQuantize","comment":" A quantizing scale.\n","type":"VegaLite.Scale"},{"name":"scRange","comment":" Range of a scaling. The type of range depends on the encoding channel.\n","type":"VegaLite.ScaleRange -> VegaLite.ScaleProperty"},{"name":"scRangeStep","comment":" Distance between the starts of adjacent bands in a band scaling. If\n`Nothing` is provided the distance is determined automatically.\n","type":"Maybe.Maybe Basics.Float -> VegaLite.ScaleProperty"},{"name":"scReverse","comment":" Reverse the order of a scaling.\n","type":"Basics.Bool -> VegaLite.ScaleProperty"},{"name":"scRound","comment":" Whether or not numeric values in a scaling are rounded to integers.\n","type":"Basics.Bool -> VegaLite.ScaleProperty"},{"name":"scScheme","comment":" Color scheme used by a color scaling. The first parameter is the name of the\nscheme (e.g. \"viridis\") and the second an optional specification of the number of\ncolors to use (list of one number), or the extent of the color range to use (list\nof two numbers between 0 and 1).\n","type":"String.String -> List.List Basics.Float -> VegaLite.ScaleProperty"},{"name":"scSequential","comment":" A sequential scale.\n","type":"VegaLite.Scale"},{"name":"scSqrt","comment":" A square root scale.\n","type":"VegaLite.Scale"},{"name":"scThreshold","comment":" A threshold scale.\n","type":"VegaLite.Scale"},{"name":"scTime","comment":" A temporal scale.\n","type":"VegaLite.Scale"},{"name":"scType","comment":" Type of scaling to apply.\n","type":"VegaLite.Scale -> VegaLite.ScaleProperty"},{"name":"scUtc","comment":" A UTC temporal scale.\n","type":"VegaLite.Scale"},{"name":"scZero","comment":" Whether or not a numeric scaling should be forced to include a zero value.\n","type":"Basics.Bool -> VegaLite.ScaleProperty"},{"name":"seBind","comment":" Binding to some input elements as part of a named selection.\n","type":"List.List VegaLite.Binding -> VegaLite.SelectionProperty"},{"name":"seBindScales","comment":" Enable two-way binding between a selection and the scales used in the same view.\n","type":"VegaLite.SelectionProperty"},{"name":"seEmpty","comment":" Make a selection empty by default when nothing selected.\n","type":"VegaLite.SelectionProperty"},{"name":"seEncodings","comment":" Encoding channels that form a named selection.\n","type":"List.List VegaLite.Channel -> VegaLite.SelectionProperty"},{"name":"seFields","comment":" Field names for projecting a selection.\n","type":"List.List String.String -> VegaLite.SelectionProperty"},{"name":"seGlobal","comment":" One selection available across all subviews (default).\n","type":"VegaLite.SelectionResolution"},{"name":"seIntersection","comment":" Each subview contains its own brush and marks are selected if they lie\nwithin _all_ of these individual selections.\n","type":"VegaLite.SelectionResolution"},{"name":"seInterval","comment":" Indicate a draggable bounding rectangle can be made for selecting all items\nthat intersect with it.\n","type":"VegaLite.Selection"},{"name":"seMulti","comment":" Indicate multiple interactive mark selections can be made (e.g. with shift-click).\n","type":"VegaLite.Selection"},{"name":"seNearest","comment":" Whether or not a selection should capture nearest marks to a pointer\nrather than an exact position match.\n","type":"Basics.Bool -> VegaLite.SelectionProperty"},{"name":"seOn","comment":" [Vega event stream](https://vega.github.io/vega/docs/event-streams)\nthat triggers a selection.\n","type":"String.String -> VegaLite.SelectionProperty"},{"name":"seResolve","comment":" Strategy that determines how selections’ data queries are resolved when applied\nin a filter transform, conditional encoding rule, or scale domain.\n","type":"VegaLite.SelectionResolution -> VegaLite.SelectionProperty"},{"name":"seSelectionMark","comment":" Appearance of an interval selection mark (dragged rectangle).\n","type":"List.List VegaLite.SelectionMarkProperty -> VegaLite.SelectionProperty"},{"name":"seSingle","comment":" Indicate a single, mark at a time, interactive selection can be made.\n","type":"VegaLite.Selection"},{"name":"seToggle","comment":" Predicate expression that determines a toggled selection. See the\n[Vega-Lite toggle documentation](https://vega.github.io/vega-lite/docs/toggle.html)\n","type":"String.String -> VegaLite.SelectionProperty"},{"name":"seTranslate","comment":" Translation selection transformation used for panning a view. See the\n[Vega-Lite translate documentation](https://vega.github.io/vega-lite/docs/translate.html)\n","type":"String.String -> VegaLite.SelectionProperty"},{"name":"seUnion","comment":" Each subview contains its own brush and marks are selected if they lie\nwithin _any_ of these individual selections.\n","type":"VegaLite.SelectionResolution"},{"name":"seZoom","comment":" Zooming selection transformation used for zooming a view. See the\n[Vega-Lite zoom documentation](https://vega.github.io/vega-lite/docs/zoom.html)\n","type":"String.String -> VegaLite.SelectionProperty"},{"name":"seconds","comment":" Second of a minute time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"secondsMilliseconds","comment":" Seconds and milliseconds time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"select","comment":" Create a single named selection that may be applied to a data query or transformation.\nThe first two parameters specify the name to be given to the selection for later\nreference and the type of selection made. The third allows additional selection options to\nbe specified.\n","type":"String.String -> VegaLite.Selection -> List.List VegaLite.SelectionProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"selected","comment":" Interactive selection that will be true or false as part of a logical composition.\ne.g., to filter a dataset so that only items selected interactively and that have\na weight of more than 30:\n\n    transform\n        << filter (fCompose (and (selected \"brush\") (expr \"datum.weight > 30\")))\n\n","type":"String.String -> VegaLite.BooleanOp"},{"name":"selection","comment":" Create a full selection specification from a list of selections.\n\n    sel =\n        selection\n            << select \"view\" seInterval [ seBindScales ] []\n            << select \"myBrush\" seInterval []\n            << select \"myPaintbrush\" seMulti [ seOn \"mouseover\", seNearest True ]\n\n","type":"List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"selectionName","comment":" Name a selection that is used as part of a conditional encoding.\n\n    color\n        [ mSelectionCondition (selectionName \"myBrush\")\n            [ mName \"myField\", mMType Nominal ]\n            [ mStr \"grey\" ]\n        ]\n\n","type":"String.String -> VegaLite.BooleanOp"},{"name":"shape","comment":" Encode a shape channel.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"siBottom","comment":" Bottom side, used to specify an axis position.\n","type":"VegaLite.Side"},{"name":"siLeft","comment":" Left side, used to specify an axis position.\n","type":"VegaLite.Side"},{"name":"siRight","comment":" Right side, used to specify an axis position.\n","type":"VegaLite.Side"},{"name":"siTop","comment":" Top side, used to specify an axis position.\n","type":"VegaLite.Side"},{"name":"size","comment":" Encode a size channel with a list of mark channel properties.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"smFill","comment":" Fill color of an interval selection mark (dragged rectangular area).\n","type":"String.String -> VegaLite.SelectionMarkProperty"},{"name":"smFillOpacity","comment":" Fill opacity of an interval selection mark in the range 0 to 1.\n","type":"Basics.Float -> VegaLite.SelectionMarkProperty"},{"name":"smStroke","comment":" Stroke color of an interval selection mark.\n","type":"String.String -> VegaLite.SelectionMarkProperty"},{"name":"smStrokeDash","comment":" Stroke dash style of an interval selection mark.\n","type":"List.List Basics.Float -> VegaLite.SelectionMarkProperty"},{"name":"smStrokeDashOffset","comment":" Stroke dash offset of an interval selection mark.\n","type":"Basics.Float -> VegaLite.SelectionMarkProperty"},{"name":"smStrokeOpacity","comment":" Stroke opacity of an interval selection mark in the range 0 to 1.\n","type":"Basics.Float -> VegaLite.SelectionMarkProperty"},{"name":"smStrokeWidth","comment":" Stroke width of an interval selection mark.\n","type":"Basics.Float -> VegaLite.SelectionMarkProperty"},{"name":"soAscending","comment":" Indicate sorting is to be applied from low to high.\n","type":"VegaLite.SortProperty"},{"name":"soByField","comment":" Sort by the aggregated summary of a given field using a given aggregation\noperation. e.g., sort the categorical data field `variety` by the mean age of\nthe data in each variety category:\n\n    position Y\n        [ pName \"variety\"\n        , pMType Ordinal\n        , pSort [ soByField \"age\" opMean, soDescending ]\n        ]\n\n","type":"String.String -> VegaLite.Operation -> VegaLite.SortProperty"},{"name":"soByRepeat","comment":" Sort by the aggregated summaries of the given fields (referenced by a repeat\niteration) using a given aggregation operation.\n","type":"VegaLite.Arrangement -> VegaLite.Operation -> VegaLite.SortProperty"},{"name":"soCustom","comment":" Custom sort order listing data values explicitly.\n","type":"VegaLite.DataValues -> VegaLite.SortProperty"},{"name":"soDescending","comment":" Indicate sorting is to be applied from high to low.\n","type":"VegaLite.SortProperty"},{"name":"spacing","comment":" Spacing between sub-views in a composition operator.\n","type":"Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"spacingRC","comment":" Similar to [spacing](#spacing) but with independent spacing for rows (first\nparameter) and columns (second parameter).\n","type":"Basics.Float -> Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"specification","comment":" Define a specification object for use with faceted and repeated small multiples.\n\n    spec = ...\n    toVegaLite\n        [ facet [ rowBy [ fName \"Origin\", fMType Nominal ] ]\n        , specifcation spec\n        ]\n\n","type":"VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"square","comment":" [Square mark](https://vega.github.io/vega-lite/docs/square.html) for symbolising\npoints.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"stAscending","comment":" Indicate that the given field should be sorted in ascending order.\n","type":"String.String -> VegaLite.SortField"},{"name":"stCenter","comment":" Offset a stacked layout using a central stack baseline.\n","type":"VegaLite.StackOffset"},{"name":"stDescending","comment":" Indicate that the given field should be sorted in descending order.\n","type":"String.String -> VegaLite.SortField"},{"name":"stNone","comment":" Do not stack marks (produces a layed plot).\n","type":"VegaLite.StackOffset"},{"name":"stNormalize","comment":" Rescale a stacked layout to use a common height while preserving relative size\nof stacked quantities.\n","type":"VegaLite.StackOffset"},{"name":"stOffset","comment":" Stack offset when applying a stack transformation.\n","type":"VegaLite.StackOffset -> VegaLite.StackProperty"},{"name":"stSort","comment":" Ordering within a stack when applying a stack transformation.\n","type":"List.List VegaLite.SortField -> VegaLite.StackProperty"},{"name":"stZero","comment":" Offset a stacked layout using a baseline at the foot of a stack.\n","type":"VegaLite.StackOffset"},{"name":"stack","comment":" Apply a stack transform for positioning multiple values. This is an alternative\nto specifying stacking directly when encoding position. First parameter is the field\nto be stacked; the second the fields to group by; the third and fourth are the names\nto give the output field names; the fifth lists the optional offset and sort properties.\n","type":"String.String -> List.List String.String -> String.String -> String.String -> List.List VegaLite.StackProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"stereographic","comment":" A stereographic map projection.\n","type":"VegaLite.Projection"},{"name":"str","comment":" A string data value.\n","type":"String.String -> VegaLite.DataValue"},{"name":"stroke","comment":" Encode a stroke channel. This acts in a similar way to encoding by `color` but\nonly affects the exterior boundary of marks.\n","type":"List.List VegaLite.MarkChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"strs","comment":" A list of string data values.\n","type":"List.List String.String -> VegaLite.DataValues"},{"name":"symCircle","comment":" Specify a circular symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"symCross","comment":" Specify a cross symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"symDiamond","comment":" Specify a diamond symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"symPath","comment":" A custom symbol shape as an\n[SVG path description](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n","type":"String.String -> VegaLite.Symbol"},{"name":"symSquare","comment":" Specify a square symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"symTriangleDown","comment":" Specify a downward triangular symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"symTriangleUp","comment":" Specify an upward triangular symbol for a shape mark.\n","type":"VegaLite.Symbol"},{"name":"tAggregate","comment":" Compute some aggregate summary statistics for a field to be encoded with a\ntext channel. The type of aggregation is determined by the given operation\nparameter.\n","type":"VegaLite.Operation -> VegaLite.TextChannel"},{"name":"tBin","comment":" Discretize numeric values into bins when encoding with a text channel.\n","type":"List.List VegaLite.BinProperty -> VegaLite.TextChannel"},{"name":"tBinned","comment":" Indicate that data encoded with a text channel are already binned.\n","type":"VegaLite.TextChannel"},{"name":"tDataCondition","comment":" Make a text channel conditional on one or more predicate expressions. The first\nparameter is a list of tuples each pairing an expression to evaluate with the encoding\nif that expression is true. The second is the encoding if none of the expressions\nare evaluated as true.\n","type":"List.List ( VegaLite.BooleanOp, List.List VegaLite.TextChannel ) -> List.List VegaLite.TextChannel -> VegaLite.TextChannel"},{"name":"tFormat","comment":" [Formatting pattern](https://vega.github.io/vega-lite/docs/format.html)\nfor a field when encoding with a text channel.\n","type":"String.String -> VegaLite.TextChannel"},{"name":"tMType","comment":" Level of measurement when encoding with a text channel.\n","type":"VegaLite.Measurement -> VegaLite.TextChannel"},{"name":"tName","comment":" Name of the field used for encoding with a text channel.\n","type":"String.String -> VegaLite.TextChannel"},{"name":"tRepeat","comment":" Reference in a text channel to a field name generated by `repeat`. The\nparameter identifies whether reference is being made to fields that are to be\nlaid out in columns or in rows.\n","type":"VegaLite.Arrangement -> VegaLite.TextChannel"},{"name":"tSelectionCondition","comment":" Make a text channel conditional on interactive selection. The first parameter\nis a selection condition to evaluate; the second the encoding to apply if that\nselection is true; the third parameter is the encoding if the selection is false.\n","type":"VegaLite.BooleanOp -> List.List VegaLite.TextChannel -> List.List VegaLite.TextChannel -> VegaLite.TextChannel"},{"name":"tTimeUnit","comment":" Time unit aggregation of field values when encoding with a text channel.\n","type":"VegaLite.TimeUnit -> VegaLite.TextChannel"},{"name":"tTitle","comment":" Title of a field when encoding with a text or tooltip channel.\n","type":"String.String -> VegaLite.TextChannel"},{"name":"text","comment":" Encode a text channel.\n","type":"List.List VegaLite.TextChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"textMark","comment":" [Text mark](https://vega.github.io/vega-lite/docs/text.html) to be\ndisplayed at some point location.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"tick","comment":" Short line ([tick](https://vega.github.io/vega-lite/docs/tick.html))\nmark for symbolising point locations.\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"ticoAnchor","comment":" Default anchor position when placing titles.\n","type":"VegaLite.Anchor -> VegaLite.TitleConfig"},{"name":"ticoAngle","comment":" Default angle when orientating titles.\n","type":"Basics.Float -> VegaLite.TitleConfig"},{"name":"ticoBaseline","comment":" Default vertical alignment when placing titles.\n","type":"VegaLite.VAlign -> VegaLite.TitleConfig"},{"name":"ticoColor","comment":" Default color when showing titles.\n","type":"String.String -> VegaLite.TitleConfig"},{"name":"ticoFont","comment":" Default font when showing titles.\n","type":"String.String -> VegaLite.TitleConfig"},{"name":"ticoFontSize","comment":" Default font size when showing titles.\n","type":"Basics.Float -> VegaLite.TitleConfig"},{"name":"ticoFontWeight","comment":" Default font weight when showing titles.\n","type":"VegaLite.FontWeight -> VegaLite.TitleConfig"},{"name":"ticoLimit","comment":" Default maximum length in pixel units when showing titles.\n","type":"Basics.Float -> VegaLite.TitleConfig"},{"name":"ticoOffset","comment":" Default offset in pixel units of titles relative to the chart body.\n","type":"Basics.Float -> VegaLite.TitleConfig"},{"name":"ticoOrient","comment":" Default placement of titles relative to the chart body.\n","type":"VegaLite.Side -> VegaLite.TitleConfig"},{"name":"timeUnitAs","comment":" Create a new data field based on the given temporal binning. Unlike the\ndirect encoding binning, this transformation is named and so can be referred\nto in multiple encodings. The first parameter is the width of each temporal bin,\nthe second is the field to bin and the third is name to give the newly binned\nfield.\n","type":"VegaLite.TimeUnit -> String.String -> String.String -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"title","comment":" Title to be displayed in the visualization.\n","type":"String.String -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"toVegaLite","comment":" Convert a list of Vega-Lite specifications into a single JSON object that may be\npassed to Vega-Lite for graphics generation. Commonly these will include at least\ndata, mark and encoding specifications.\n\nWhile simple functions like `bar` may be provided directly, it is usually clearer\nto label more complex ones such as encodings as separate expressions.\n\nSpecifications can be built up by chaining functions such as `dataColumn` or\n`position`. Functional composition using the `<<` operator allows this to be done\ncompactly.\n\n    let\n        data =\n            dataFromColumns []\n                << dataColumn \"a\" (strs [ \"C\", \"C\", \"D\", \"E\" ])\n                << dataColumn \"b\" (nums [ 2, 7, 1, 2 ])\n\n        enc =\n            encoding\n                << position X [ pName \"a\", pMType Nominal ]\n                << position Y [ pName \"b\", pMType Quantitative, pAggregate opMean ]\n    in\n    toVegaLite [ data [], bar [], enc [] ]\n\n","type":"List.List ( VegaLite.VLProperty, VegaLite.Spec ) -> VegaLite.Spec"},{"name":"tooltip","comment":" Encode a tooltip channel. To encode multiple tooltip values with a mark, use\n[tooltips](#tooltips).\n","type":"List.List VegaLite.TextChannel -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"tooltips","comment":" Encode a tooltip channel with multiple tooltips. The first parameter is a\nlist of the multiple tooltips, each of which is a list of text channel properties\nthat define the channel.\n","type":"List.List (List.List VegaLite.TextChannel) -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"topojsonFeature","comment":" A topoJSON feature format containing an object with the given name.\n","type":"String.String -> VegaLite.Format"},{"name":"topojsonMesh","comment":" A topoJSON mesh format containing an object with the given name. Unlike\n`topojsonFeature`, the corresponding geo data are returned as a single unified mesh,\nnot as individual GeoJSON features.\n","type":"String.String -> VegaLite.Format"},{"name":"trail","comment":" [Trail mark](https://vega.github.io/vega-lite/docs/trail.html) (line\nwith variable width along its length).\n","type":"List.List VegaLite.MarkProperty -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"transform","comment":" Create a single transform from a list of transformation specifications. The\norder of transformations can be important, e.g. labels created with [calculateAs](#calculateAs),\n[timeUnitAs](#timeUnitAs) and [binAs](#binAs) that are used in other transformations.\nUsing the functional composition pipeline idiom (as example below) allows you to\nprovide the transformations in the order intended in a clear manner.\n\n    trans =\n        transform\n            << filter (fiExpr \"datum.year == 2010\")\n            << calculateAs \"datum.sex == 2 ? 'Female' : 'Male'\" \"gender\"\n\n","type":"List.List VegaLite.LabelledSpec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"transverseMercator","comment":" A transverse Mercator map projection.\n","type":"VegaLite.Projection"},{"name":"true","comment":" A true value used for functions that can accept a Boolean literal or a reference\nto something that generates a Boolean value. Convenience function equivalent to `boo True`\n","type":"VegaLite.DataValue"},{"name":"tsv","comment":" TSV data file format (only necessary if the file extension does not indicate the\ntype).\n","type":"VegaLite.Format"},{"name":"ttData","comment":" Indicate tooltips are generated by data.\n","type":"VegaLite.TooltipContent"},{"name":"ttEncoding","comment":" Indicate tooltips are generated by encoding (default).\n","type":"VegaLite.TooltipContent"},{"name":"utc","comment":" UTC version of a given a time (coordinated universal time, independent of local\ntime zones or daylight saving). To encode a time as UTC (coordinated universal time,\nindependent of local time zones or daylight saving), just use this function to convert\nanother `TimeUnit` generating function. For example,\n\n    encoding\n        << position X [ pName \"date\", pMType Temporal, pTimeUnit (utc yearMonthDateHours) ]\n\n","type":"VegaLite.TimeUnit -> VegaLite.TimeUnit"},{"name":"vConcat","comment":" Specifications to be juxtaposed vertically in a visualization.\n","type":"List.List VegaLite.Spec -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"vaBottom","comment":" Bottom vertical text alignment.\n","type":"VegaLite.VAlign"},{"name":"vaMiddle","comment":" Middle vertical text alignment.\n","type":"VegaLite.VAlign"},{"name":"vaTop","comment":" Top vertical text alignment.\n","type":"VegaLite.VAlign"},{"name":"vicoClip","comment":" Whether or not by default single views should be clipped.\n","type":"Basics.Bool -> VegaLite.ViewConfig"},{"name":"vicoFill","comment":" Default fill color for single views.\n","type":"Maybe.Maybe String.String -> VegaLite.ViewConfig"},{"name":"vicoFillOpacity","comment":" Default fill opacity for single views.\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoHeight","comment":" Default height of single views (e.g. each view in a trellis plot).\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoStroke","comment":" Default stroke color for single views. If `Nothing` is provided,\nno strokes are drawn around the view.\n","type":"Maybe.Maybe String.String -> VegaLite.ViewConfig"},{"name":"vicoStrokeDash","comment":" Default stroke dash style for single views.\n","type":"List.List Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoStrokeDashOffset","comment":" Default stroke dash offset for single views.\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoStrokeOpacity","comment":" Default stroke opacity for single views.\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoStrokeWidth","comment":" Default stroke width of single views.\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"vicoWidth","comment":" Default width of single views (e.g. each view in a trellis plot).\n","type":"Basics.Float -> VegaLite.ViewConfig"},{"name":"wiAggregateOp","comment":" An aggregrate operation to be used in a window transformation.\n","type":"VegaLite.Operation -> VegaLite.Window"},{"name":"wiAscending","comment":" Indicate that the given field should be sorted in ascending order when performing\na window transform.\n","type":"String.String -> VegaLite.SortField"},{"name":"wiDescending","comment":" Indicate that the given field should be sorted in descending order when performing\na window transform.\n","type":"String.String -> VegaLite.SortField"},{"name":"wiField","comment":" Field for which to compute a window operation. Not needed for\noperations that do not apply to fields such as `opCount`, `woRank` and `woDenseRank`.\n","type":"String.String -> VegaLite.Window"},{"name":"wiFrame","comment":" Moving window for use by a window transform. The two parameters\nshould either be `Just` a number indicating the offset from the current data object,\nor `Nothing` to indicate unbounded rows preceding or following the current data object.\n","type":"Maybe.Maybe Basics.Int -> Maybe.Maybe Basics.Int -> VegaLite.WindowProperty"},{"name":"wiGroupBy","comment":" Fields for partitioning data objects in a window transform into separate windows.\nIf unspecified, all points will be in a single group.\n","type":"List.List String.String -> VegaLite.WindowProperty"},{"name":"wiIgnorePeers","comment":" Whether or not the sliding window frame in a window transform should ignore\npeer values (those considered identical by the sort criteria).\n","type":"Basics.Bool -> VegaLite.WindowProperty"},{"name":"wiOp","comment":" Window-specific operation to be used in a window transformation.\n","type":"VegaLite.WOperation -> VegaLite.Window"},{"name":"wiParam","comment":" Numeric parameter for window-only operations that can be parameterised\n(`woPercentile`, `woLag`, `woLead` and `woNthValue`).\n","type":"Basics.Int -> VegaLite.Window"},{"name":"wiSort","comment":" Comparator for sorting data objects within a window transform.\n","type":"List.List VegaLite.SortField -> VegaLite.WindowProperty"},{"name":"width","comment":" Override the default width of the visualization. If not specified the width\nwill be calculated based on the content of the visualization.\n","type":"Basics.Float -> ( VegaLite.VLProperty, VegaLite.Spec )"},{"name":"window","comment":" Window transform for performing calculations over sorted groups of\ndata objects such as ranking, lead/lag analysis, running sums and averages.\n\nThe first parameter is a list of tuples each comprising a window transform field\ndefinition and an output name. The second is the window transform definition.\n\n       trans =\n           transform\n               << window [ ( [ wiAggregateOp opSum, wiField \"Time\" ], \"TotalTime\" ) ]\n                   [ wiFrame Nothing Nothing ]\n\n","type":"List.List ( List.List VegaLite.Window, String.String ) -> List.List VegaLite.WindowProperty -> List.List VegaLite.LabelledSpec -> List.List VegaLite.LabelledSpec"},{"name":"woCumeDist","comment":" Cumulative distribution function to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woDenseRank","comment":" Dense rank function to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woFirstValue","comment":" First value in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woLag","comment":" Value preceding the current object in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woLastValue","comment":" Last value in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woLead","comment":" Value following the current object in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woNthValue","comment":" Nth value in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woPercentRank","comment":" Percentile of values in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woPercentile","comment":" Value preceding the current object in a sliding window to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woRank","comment":" Rank function to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"woRowNumber","comment":" Assign consecutive row number to values in a data object to be applied in a window transform.\n","type":"VegaLite.WOperation"},{"name":"year","comment":" Year time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearMonth","comment":" Year and month time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearMonthDate","comment":" Year, month and day of month time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearMonthDateHours","comment":" Year, month, day of month and hour of day time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearMonthDateHoursMinutes","comment":" Time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearMonthDateHoursMinutesSeconds","comment":" Time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearQuarter","comment":" Year and year quarter time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"},{"name":"yearQuarterMonth","comment":" Year, quarter and month time unit used for discretizing temporal data.\n","type":"VegaLite.TimeUnit"}],"binops":[]}]