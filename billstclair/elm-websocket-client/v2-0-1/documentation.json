[{"name":"WebSocketClient","comment":" Web sockets make it cheaper to talk to your servers.\n\nConnecting to a server takes some time, so with web sockets, you make that\nconnection once and then keep using. The major benefits of this are:\n\n1.  It faster to send messages. No need to do a bunch of work for every single\n    message.\n\n2.  The server can push messages to you. With normal HTTP you would have to\n    keep _asking_ for changes, but a web socket, the server can talk to you\n    whenever it wants. This means there is less unnecessary network traffic.\n\n\n# Web Sockets\n\n\n## Types\n\n@docs PortVersion, Config, State, Response, Error, ClosedCode\n\n\n## State\n\n@docs makeConfig, makeState\n@docs getKeyUrl, getConfig, setConfig\n\n\n## API\n\n@docs open, keepAlive, send, close, process\n@docs openWithKey, keepAliveWithKey\n\n\n## Simulator\n\n@docs makeSimulatorConfig\n\n\n## Printing errors\n\n@docs errorToString, closedCodeToString\n\n","unions":[{"name":"ClosedCode","comment":" This will usually be `NormalClosure`. The rest are standard, except for `UnknownClosure`, which denotes a code that is not defined, and `TimeoutOutOnReconnect`, which means that exponential backoff connection reestablishment attempts timed out.\n\nThe standard codes are from <https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent>\n\n","args":[],"cases":[["NormalClosure",[]],["GoingAwayClosure",[]],["ProtocolErrorClosure",[]],["UnsupportedDataClosure",[]],["NoStatusRecvdClosure",[]],["AbnormalClosure",[]],["InvalidFramePayloadDataClosure",[]],["PolicyViolationClosure",[]],["MessageTooBigClosure",[]],["MissingExtensionClosure",[]],["InternalErrorClosure",[]],["ServiceRestartClosure",[]],["TryAgainLaterClosure",[]],["BadGatewayClosure",[]],["TLSHandshakeClosure",[]],["TimedOutOnReconnect",[]],["UnknownClosure",[]]]},{"name":"Config","comment":" Packages up your ports to put inside a `State`.\n\nOpaque type, created by `makeConfig`.\n\n","args":["msg"],"cases":[]},{"name":"Error","comment":" All the errors that can be returned in a Response.ErrorResponse.\n\nIf an error tag has a single `String` arg, that string is a socket `key`.\n\n","args":[],"cases":[["UnimplementedError",["{ function : String.String }"]],["SocketAlreadyOpenError",["String.String"]],["SocketConnectingError",["String.String"]],["SocketClosingError",["String.String"]],["SocketNotOpenError",["String.String"]],["PortDecodeError",["{ error : String.String }"]],["UnexpectedConnectedError",["{ key : String.String, description : String.String }"]],["UnexpectedMessageError",["{ key : String.String, message : String.String }"]],["LowLevelError",["{ key : Maybe.Maybe String.String, code : String.String, description : String.String, name : Maybe.Maybe String.String }"]],["InvalidMessageError",["{ json : String.String }"]]]},{"name":"PortVersion","comment":" A custom type with one tag.\n\nThe tag encodes the version of the port JavaScript code.\nIt changes every time that code changes incompatibly, to remind\nyou that you need to update it, and change your `open`, `openWithKey`,\nand `send` calls accordingly.\n\n","args":[],"cases":[["PortVersion2",[]]]},{"name":"Response","comment":" A response that your code must process to update your model.\n\n`NoResponse` means there's nothing to do.\n\n`CmdResponse` is a `Cmd` that you must return from your `update` function. It will send something out the `sendPort` in your `Config`.\n\n`ConnectedReponse` tells you that an earlier call to `send` or `keepAlive` has successfully connected. You can usually ignore this.\n\n`MessageReceivedResponse` is a message from one of the connected sockets.\n\n`ClosedResponse` tells you that an earlier call to `close` has completed. Its `code`, `reason`, and `wasClean` fields are as passed by the JavaScript `WebSocket` interface. Its `expected` field will be `True`, if the response is to a `close` call on your part. It will be `False` if the close was unexpected, and reconnection attempts failed for 20 seconds (using exponential backoff between attempts).\n\n`ErrorResponse` means that something went wrong. Details in the encapsulated `Error`.\n\n","args":["msg"],"cases":[["NoResponse",[]],["CmdResponse",["Platform.Cmd.Cmd msg"]],["ConnectedResponse",["{ key : String.String, description : String.String }"]],["MessageReceivedResponse",["{ key : String.String, message : String.String }"]],["ClosedResponse",["{ key : String.String, code : WebSocketClient.ClosedCode, reason : String.String, wasClean : Basics.Bool, expected : Basics.Bool }"]],["ErrorResponse",["WebSocketClient.Error"]]]},{"name":"State","comment":" Internal state of the WebSocketClient module.\n\nCreate one with `makeState`, passed to most of the other functions.\n\n","args":["msg"],"cases":[]}],"aliases":[],"values":[{"name":"close","comment":" Close a WebSocket opened by `open` or `keepAlive`.\n\n    close state key\n\nThe `key` arg is either they `key` arg to `openWithKey` or\n`keepAliveWithKey` or the `url` arg to `open` or `keepAlive`.\n\n","type":"WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"closedCodeToString","comment":" Turn a `ClosedCode` into a `String`, for debugging.\n","type":"WebSocketClient.ClosedCode -> String.String"},{"name":"errorToString","comment":" Convert an `Error` to a string, for simple reporting.\n","type":"WebSocketClient.Error -> String.String"},{"name":"getConfig","comment":" Get a State's Config\n","type":"WebSocketClient.State msg -> WebSocketClient.Config msg"},{"name":"getKeyUrl","comment":" Get the URL for a key.\n","type":"String.String -> WebSocketClient.State msg -> Maybe.Maybe String.String"},{"name":"keepAlive","comment":" Keep a connection alive, but do not report any messages. This is useful\nfor keeping a connection open for when you only need to `send` messages. So\nyou might say something like this:\n\n    let (state2, response) =\n        keepAlive state \"ws://echo.websocket.org\"\n    in\n        ...\n\n**Note:** If the connection goes down, the effect manager tries to reconnect\nwith an exponential backoff strategy. Any messages you try to `send` while the\nconnection is down are queued and will be sent as soon as possible.\n\n","type":"WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"keepAliveWithKey","comment":" Like `keepAlive`, but allows matching a unique key to the connection.\n\n    keeAliveWithKey state key url\n\n","type":"WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"makeConfig","comment":" Make a real configuration, with your input and output ports.\n\nThe parameters are:\n\n    makeConfig sendPort\n\nWhere `sendPort` is your output (`Cmd`) port.\n\nYour input (`Sub`) port should wrap a `Json.Encode.Value` with a message,\nand when your `update` function gets that message, it should pass it to\n`process`, and then store the returned `State` in your model, and handle\nthe returned `Response`.\n\n","type":"(Json.Encode.Value -> Platform.Cmd.Cmd msg) -> WebSocketClient.Config msg"},{"name":"makeSimulatorConfig","comment":" Make a `Config` that enables running your code in `elm reactor`.\n\nThe arg is a server simulator, which translates a message sent with `send`\nto a response.\n\n","type":"(String.String -> Maybe.Maybe String.String) -> WebSocketClient.Config msg"},{"name":"makeState","comment":" Make state to store in your model.\n\nThe `Config` arg is the result of `makeConfig` or `makeSimulatorConfig`.\n\n","type":"WebSocketClient.Config msg -> WebSocketClient.State msg"},{"name":"open","comment":" Subscribe to any incoming messages on a websocket. You might say something\nlike this:\n\n    type Msg = Echo String | ...\n\n    subscriptions model =\n      open PortVersion2 \"ws://echo.websocket.org\" Echo\n\nThe first arg is a `PortVersion`, to remind you to update your JavaScript\nport code, when it changes incompatibly.\n\n    open PortVersion2 state url\n\n","type":"WebSocketClient.PortVersion -> WebSocketClient.State msg -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"openWithKey","comment":" Like `open`, but allows matching a unique key to the connection.\n\n`open` uses the url as the key.\n\n    openWithKey PortVersion2 state key url\n\n","type":"WebSocketClient.PortVersion -> WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"process","comment":" Process a Value that comes in over the subscription port.\n","type":"WebSocketClient.State msg -> Json.Encode.Value -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"send","comment":" Send a message to a particular address. You might say something like this:\n\n    send PortVersion2 state \"ws://echo.websocket.org\" \"Hello!\"\n\nYou must call `open` or `openWithKey` before calling `send`.\n\nIf you call `send` before the connection has been established, or while it is being reestablished after it was lost, your message will be buffered and sent after the connection has been (re)established.\n\nThe first arg is a `PortVersion`, to remind you to update your JavaScript\nport code, if it changes incompatibly.\n\n    send PortVersion2 state key message\n\n","type":"WebSocketClient.PortVersion -> WebSocketClient.State msg -> String.String -> String.String -> ( WebSocketClient.State msg, WebSocketClient.Response msg )"},{"name":"setConfig","comment":" Set a State's Config.\n\nWill likely break things if you do this while connections are active.\n\n","type":"WebSocketClient.Config msg -> WebSocketClient.State msg -> WebSocketClient.State msg"}],"binops":[]}]