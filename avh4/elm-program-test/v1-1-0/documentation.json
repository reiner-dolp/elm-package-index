[
  {
    "name": "TestContext",
    "comment": " A `TestContext` simulates the execution of an Elm program.\n\n\n## Creating\n\n@docs TestContext\n@docs create, createWithFlags, createWithJsonStringFlags, createWithBaseUrl\n@docs createWithNavigation, createWithNavigationAndFlags, createWithNavigationAndJsonStringFlags\n\n\n## Simulating user input\n\n@docs clickButton, clickLink\n@docs fillIn, fillInTextarea\n@docs check\n@docs routeChange\n\n\n## Simulating user input (advanced)\n\n@docs simulate\n@docs within\n\n\n## Directly sending Msgs\n\n@docs update\n\n\n## Final assertions\n\n@docs expectViewHas, expectView\n@docs expectLastEffect, expectModel\n@docs expectPageChange\n\n\n## Intermediate assertions\n\nThese functions can be used to make assertions on a `TestContext` without ending the test.\n\n@docs shouldHave, shouldNotHave, shouldHaveView\n@docs shouldHaveLastEffect\n\nTo end a `TestContext` without using a [final assertion](#final-assertions), use the following function:\n\n@docs done\n\n\n## Custom assertions\n\nThese functions may be useful if you are writing your own custom assertion functions.\n\n@docs fail\n\n",
    "aliases": [],
    "types": [
      {
        "name": "TestContext",
        "comment": " A `TestContext` represents an Elm program, a current state for that program,\nand a log of any errors that have occurred while simulating interaction with the program.\n\n  - To create a `TestContext, see the`create*` functions below.\n  - To advance the state of a `TestContext`, see [Simulating user input](#simulating-user-input), and [Directly sending Msgs](#directly-sending-msgs)\n  - To assert on the resulting state of a `TestContext`, see [Final assertions](#final-assertions)\n\n",
        "args": [
          "msg",
          "model",
          "effect"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "check",
        "comment": " Simulates setting the value of a checkbox labeled with the given label.\n\nNOTE: Currently, this function requires that you also provide the field id\n(which must match both the `id` attribute of the target `input` element,\nand the `for` attribute of the `label` element).\nAfter [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\na future release of this package will remove the `fieldId` parameter.\n\nNOTE: In the future, this will be generalized to work with\naria accessiblity attributes in addition to working with standard HTML label elements.\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n",
        "type": "String -> String -> Bool -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "clickButton",
        "comment": " Simulates clicking a button.\n\nCurrently, this function will find and click a `<button>` HTML node containing the given `buttonText`.\n\nNOTE: In the future, this function will be generalized to find buttons with accessibility attributes\nmatching the given `buttonText`.\n\n",
        "type": "String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "clickLink",
        "comment": " Simulates clicking a `<a href=\"...\">` link.\n\nNOTE: Currently, this function requires that you also provide the expected href.\nAfter [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\na future release of this package will remove the `href` parameter.\n\nNote for testing single-page apps,\nif the target `<a>` tag has an `onClick` handler,\nthen the message produced by the handler will be processed\nand the `href` will not be followed.\nNOTE: Currently this function cannot verify that the onClick handler\nsets `preventDefault`, but this will be done in the future after\n<https://github.com/eeue56/elm-html-test/issues/63> is resolved.\n\n",
        "type": "String -> String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "create",
        "comment": " Creates a `TestContext` from the parts of a standard `Html.program`.\n\nSee other `create*` functions below if the program you want to test\nuses flags or nagivation.\n\n",
        "type": "{ init : ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithBaseUrl",
        "comment": " Creates a `TestContext` from the parts of a standard `Html.program`\nand a base URL against which relative URLs can be resolved.\n\nIf you don't need to simulate clicking links with relative URLs,\nprefer [`create`](#create).\n\nIf your program uses navigation, see [`createWithNavigation`](#createWithNavigation).\n\n",
        "type": "{ init : ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> String -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithFlags",
        "comment": " Creates a `TestContext` from the parts of a standard with flags (`Html.programWithFlags`).\n\nIf your program uses `Json.Encode.Value` as its flags type,\nyou may find [`createWithJsonStringFlags`](#createWithJsonStringFlags) useful.\n\nIf your program does not use flags, see [`create`](#create).\n\nSee other `create*` functions below if the program you want to test\nuses nagivation.\n\n",
        "type": "{ init : flags -> ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> flags -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithJsonStringFlags",
        "comment": " A simplified way to create a `TestContext` for a program that decodes its flags with a JSON decoder.\n\nIf your program does not use `Json.Encode.Value` as its flags type,\nor you want more control over how the flags are provided in your tests,\nsee [`createWithFlags`](#createWithFlags).\n\nIf your program does not use flags, see [`create`](#create).\n\nSee other `create*` functions below if the program you want to test\nuses nagivation.\n\n",
        "type": "Json.Decode.Decoder flags -> { init : flags -> ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> String -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithNavigation",
        "comment": " Creates a `TestContext` from the parts of a `Navigation.program`.\n\nSee other `create*` functions above and below if the program you want to test\nuses flags or does not use nagivation.\n\n",
        "type": "(Navigation.Location -> msg) -> { init : Navigation.Location -> ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> String -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithNavigationAndFlags",
        "comment": " Creates a `TestContext` from the parts of a program with navigation and flags (`Navigation.programWithFlags`).\n\nIf your program uses `Json.Encode.Value` as its flags type,\nyou may find [`createWithNavigationAndJsonStringFlags`](#createWithNavigationAndJsonStringFlags) useful.\n\nIf your program does not use flags, see [`createWithNavigation`](#createWithNavigation).\n\nIf your program does not use navigation, see [`createWithFlags`](#createWithFlags).\n\n",
        "type": "(Navigation.Location -> msg) -> { init : flags -> Navigation.Location -> ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> String -> flags -> TestContext.TestContext msg model effect"
      },
      {
        "name": "createWithNavigationAndJsonStringFlags",
        "comment": " A simplified way to create a `TestContext` for a program with navigation that decodes its flags with a JSON decoder.\n\nIf your program does not use `Json.Encode.Value` as its flags type,\nor you want more control over how the flags are provided in your tests,\nsee [`createWithNavigationAndFlags`](#createWithNavigationAndFlags).\n\nIf your program does not use flags, see [`createWithNavigation`](#createWithNavigation).\n\nIf your program does not use navigation, see [`createWithJsonStringFlags`](#createWithJsonStringFlags).\n\n",
        "type": "Json.Decode.Decoder flags -> (Navigation.Location -> msg) -> { init : flags -> Navigation.Location -> ( model, effect ) , update : msg -> model -> ( model, effect ) , view : model -> Html.Html msg } -> String -> String -> TestContext.TestContext msg model effect"
      },
      {
        "name": "done",
        "comment": " Ends a `TestContext`, reporting any errors that occurred.\n\nNOTE: You should prefer using a [final assertion](#final-assertions) to end your test over using `done`,\nas doing so will [make the intent of your test more clear](https://www.artima.com/weblogs/viewpost.jsp?thread=35578).\n\n",
        "type": "TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "expectLastEffect",
        "comment": " Makes an assertion about the last effect produced by a `TestContext`'s program.\n",
        "type": "(effect -> Expect.Expectation) -> TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "expectModel",
        "comment": " Make an assertion about the current state of a `TestContext`'s model.\n",
        "type": "(model -> Expect.Expectation) -> TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "expectPageChange",
        "comment": " Asserts that the program ended by navigating away to another URL.\n",
        "type": "String -> TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "expectView",
        "comment": " Makes an assertion about the current state of a `TestContext`'s view.\n",
        "type": "(Test.Html.Query.Single msg -> Expect.Expectation) -> TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "expectViewHas",
        "comment": " A simpler way to assert that a `TestContext`'s view matches a given selector.\n\n`expectViewHas [...selector...]` is the same as `expectView (Test.Html.Query.has [...selector...])`.\n\n",
        "type": "List Test.Html.Selector.Selector -> TestContext.TestContext msg model effect -> Expect.Expectation"
      },
      {
        "name": "fail",
        "comment": " `fail` can be used to report custom errors if you are writing your own convenience functions to deal with test contexts.\n\nExample (this is a function that checks for a particular structure in the program's view,\nbut will also fail the TestContext if the `expectedCount` parameter is invalid):\n\n    expectNotificationCount : Int -> TestContext Msg Model effect -> TestContext Msg Model effect\n    expectNotificationCount expectedCount testContext =\n        if expectedCount <= 0 then\n            testContext\n                |> TestContext.fail \"expectNotificationCount\"\n                    (\"expectedCount must be positive, but was: \" ++ toString expectedCount)\n        else\n            testContext\n                |> shouldHave\n                    [ Test.Html.Selector.class \"notifications\"\n                    , Test.Html.Selector.text (toString expectedCount)\n                    ]\n\n",
        "type": "String -> String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "fillIn",
        "comment": " Simulates replacing the text in an input field labeled with the given label.\n\nNOTE: Currently, this function requires that you also provide the field id\n(which must match both the `id` attribute of the target `input` element,\nand the `for` attribute of the `label` element).\nAfter [eeue56/elm-html-test#52](https://github.com/eeue56/elm-html-test/issues/52) is resolved,\na future release of this package will remove the `fieldId` parameter.\n\nNOTE: TODO: In the future, this will be generalized to work with\nlabeled textareas as well as labeled input fields.\n(related to [eeue56/elm-html-test#49](https://github.com/eeue56/elm-html-test/issues/49>))\n\nNOTE: In the future, this will be generalized to work with\naria accessiblity attributes in addition to working with standard HTML label elements.\n\nIf you need to target a `<textarea>` that does not have a label,\nsee [`fillInTextarea`](#fillInTextArea).\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n",
        "type": "String -> String -> String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "fillInTextarea",
        "comment": " Simulates replacing the text in a `<textarea>`.\n\nThis function expects that there is only one `<textarea>` in the view.\nIf your view has more than one `<textarea>`,\nprefer adding associated `<label>` elements and use [`fillIn`](#fillIn).\nIf you cannot add `<label>` elements see [`within`](#within).\n\nIf you need more control over the finding the target element or creating the simulated event,\nsee [`simulate`](#simulate).\n\n",
        "type": "String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "routeChange",
        "comment": " `url` may be an absolute URL or relative URL\n",
        "type": "String -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "shouldHave",
        "comment": " `shouldHave [...selector...]` is equivalent to `shouldHaveView (Test.Html.Query.has [...selector...])`\n",
        "type": "List Test.Html.Selector.Selector -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "shouldHaveLastEffect",
        "comment": " Validates the last effect produced by a `TestContext`'s program without ending the `TestContext`.\n",
        "type": "(effect -> Expect.Expectation) -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "shouldHaveView",
        "comment": " Validates the the current state of a `TestContext`'s view without ending the `TestContext`.\n",
        "type": "(Test.Html.Query.Single msg -> Expect.Expectation) -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "shouldNotHave",
        "comment": " `shouldNotHave [...selector...]` is equivalent to `shouldHaveView (Test.Html.Query.hasNot [...selector...])`\n",
        "type": "List Test.Html.Selector.Selector -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "simulate",
        "comment": " Simulates a custom DOM event.\n\nNOTE: If there is another, more specific function (see [Simulating user input](#simulating-user-input)\nthat does what you want, prefer that instead, as you will get the benefit of better error messages.\n\nParameters:\n\n  - `findTarget`: A function to find the HTML element that responds to the event\n    (typically this will be a call to `Test.Html.Query.find [ ...some selector... ]`)\n  - `( eventName, eventValue )`: The event to simulate\n    (see [Test.Html.Event \"Event Builders\"](http://package.elm-lang.org/packages/eeue56/elm-html-test/latest/Test-Html-Event#event-builders))\n\n",
        "type": "(Test.Html.Query.Single msg -> Test.Html.Query.Single msg) -> ( String, Json.Encode.Value ) -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "update",
        "comment": " Advances the state of the `TestContext`'s program by using the `TestContext`'s program's update function\nwith the given `msg`.\n\nThis can be used to simulate events that can only be triggered by [commands (`Cmd`) and subscriptions (`Sub`)](https://guide.elm-lang.org/architecture/effects/)\n(i.e., that cannot be triggered by user interaction with the view).\n\nNOTE: When possible, you should prefer [Simulating user input](#simulating-user-input),\nas doing so will make your tests more robust to changes in your program's implementation details.\n\n",
        "type": "msg -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      },
      {
        "name": "within",
        "comment": " Focus on a part of the view for a particular operation.\n\nFor example, if your view produces the following HTML:\n\n```html\n<div>\n  <div id=\"sidebar\">\n    <button>Submit</button>\n  </div>\n  <div id=\"content\">\n    <button>Submit</button>\n  </div>\n</div>\n```\n\nthen the following will allow you to simulate clicking the \"Submit\" button in the sidebar\n(simply using `clickButton \"Submit\"` would fail because there are two buttons matching that text):\n\n    import Test.Html.Query as Query\n    import Test.Html.Selector exposing (id)\n\n    testContext\n        |> TestContext.within\n            (Query.find [ id \"sidebar\" ])\n            (TestContext.clickButton \"Submit\")\n        |> ...\n\n",
        "type": "(Test.Html.Query.Single msg -> Test.Html.Query.Single msg) -> (TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect) -> TestContext.TestContext msg model effect -> TestContext.TestContext msg model effect"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]