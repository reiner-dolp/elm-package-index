[
  {
    "name": "Pylon.DB.Filter",
    "comment": " A binding for ElmTextSearch and Pylon.DB.Group.\n\n# Types\n@docs Filter, FilterFeedback, Document\n\n# Construction\n@docs filter\n\n# Query\n@docs filterQuery, filterQueryIf\n\n# Getters\n@docs getFilterQuery, getFilterResults, getLastFilterResults\n\n# Group Mirroring\n@docs filterMirror, filterMirror'\n\n# Update\n@docs filterInputOne\n\n# Dispatch\n@docs filterSync, filterAsyncAs, filterAsync\n",
    "aliases": [
      {
        "name": "Document",
        "comment": " Represents the getters for a document type used by a filter. ",
        "args": [
          "doctype"
        ],
        "type": "{ ref : doctype -> String , fields : List ( doctype -> String, Float ) }"
      }
    ],
    "types": [
      {
        "name": "Filter",
        "comment": " A document filter. ",
        "args": [
          "doctype"
        ],
        "cases": []
      },
      {
        "name": "FilterFeedback",
        "comment": " FilterFeedback for a filter containing results. These will be matched to the current state by\nsequence number, so old search results will not overwrite a newer query. ",
        "args": [
          "doctype"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "filter",
        "comment": " Create a new filter from a document description. ",
        "type": "Pylon.DB.Filter.Document doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterAsync",
        "comment": " Filter asynchronously. When executed, the resulting task will send update(s) to the provided filter feedback address. ",
        "type": "Signal.Address (List (Pylon.DB.Filter.FilterFeedback doctype)) -> Pylon.DB.Filter.Filter doctype -> ( Pylon.DB.Filter.Filter doctype , List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "filterAsyncAs",
        "comment": " Filter asynchronously with a forwarding address. ",
        "type": "(List (Pylon.DB.Filter.FilterFeedback doctype) -> List action) -> Signal.Address (List action) -> Pylon.DB.Filter.Filter doctype -> ( Pylon.DB.Filter.Filter doctype , List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "filterInputOne",
        "comment": " Handle a filter result. This may update the latest field to reflect the latest results\ncontinuously, even if the sequence numbers do not match. If they do, the existing filter will be\nentirely replaced by the result one since the index cannot have changed since then. ",
        "type": "Pylon.DB.Filter.FilterFeedback doctype -> Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterMirror",
        "comment": " Synchronize the document store with the contents of a DB group. ",
        "type": "(String -> rectype -> doctype) -> Pylon.DB.Group.Group (Pylon.DB.Data rectype) -> Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterMirror'",
        "comment": " Synchronize the document store with the contents of a mirror. ",
        "type": "(String -> rectype -> doctype) -> Pylon.DB.Mirror.Mirror rectype -> Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterQuery",
        "comment": " Set a new query string. ",
        "type": "String -> Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterQueryIf",
        "comment": " Set a new query conditionally. ",
        "type": "(String -> Bool) -> String -> Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "filterSync",
        "comment": " Filter synchronously. The results are immediately available in the resulting Filter. ",
        "type": "Pylon.DB.Filter.Filter doctype -> Pylon.DB.Filter.Filter doctype"
      },
      {
        "name": "getFilterQuery",
        "comment": " Get the latest filter query. ",
        "type": "Pylon.DB.Filter.Filter doctype -> String"
      },
      {
        "name": "getFilterResults",
        "comment": " Get the current filter results. ",
        "type": "Pylon.DB.Filter.Filter doctype -> Pylon.Resource.Resource String (List ( doctype, Float ))"
      },
      {
        "name": "getLastFilterResults",
        "comment": " Get the latest filter results. ",
        "type": "Pylon.DB.Filter.Filter doctype -> Maybe.Maybe (List ( doctype, Float ))"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.DB.Mirror",
    "comment": " A binding for ElmTextSearch and Pylon.DB.Group.\n\n# Types\n@docs Mirror\n\n# Construction\n@docs mirror\n\n# Getters\n@docs refs, changedRefs, deltas\n\n# Group Mirroring\n@docs attach, forward\n\n# Integration\n@docs commit\n",
    "aliases": [],
    "types": [
      {
        "name": "Mirror",
        "comment": " A document mirror. ",
        "args": [
          "doctype"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "attach",
        "comment": " Mirror a DB group. ",
        "type": "(String -> rectype -> doctype) -> Pylon.DB.Group.Group (Pylon.DB.Data rectype) -> Pylon.DB.Mirror.Mirror doctype -> Pylon.DB.Mirror.Mirror doctype"
      },
      {
        "name": "changedRefs",
        "comment": " Get the pending reference dictionary. ",
        "type": "Pylon.DB.Mirror.Mirror doctype -> Dict.Dict String doctype"
      },
      {
        "name": "commit",
        "comment": " Accept the current changes. ",
        "type": "Pylon.DB.Mirror.Mirror doctype -> Pylon.DB.Mirror.Mirror doctype"
      },
      {
        "name": "deltas",
        "comment": " Get the deltas used to change the reference dictionary. ",
        "type": "Pylon.DB.Mirror.Mirror doctype -> Dict.Dict String (List ( Pylon.Resource.Resource Pylon.DB.DBError doctype , Pylon.Resource.Resource Pylon.DB.DBError doctype ))"
      },
      {
        "name": "forward",
        "comment": " Forward deltas from one mirror to another. ",
        "type": "(String -> doctype -> doctype') -> Pylon.DB.Mirror.Mirror doctype -> Pylon.DB.Mirror.Mirror doctype' -> Pylon.DB.Mirror.Mirror doctype'"
      },
      {
        "name": "mirror",
        "comment": " Create a new mirror from a document description. ",
        "type": "Pylon.DB.Mirror.Mirror doctype"
      },
      {
        "name": "refs",
        "comment": " Get the current reference dictionary. ",
        "type": "Pylon.DB.Mirror.Mirror doctype -> Dict.Dict String doctype"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.DB.Meta",
    "comment": " Subscribe to metadata about connectivity, timestamp offset, and authentication using the\nsame easy to understand pattern set forth in `Pylon.DB`.\n\n# Types\n@docs MetaFeedback, MetaBinding, MetaData\n\n# Special Server Metadata Binding\n@docs nilMetaData, metaBindingTo, metaSendingTo, metaForwardingTo, metaInputOne, metaInput, metaSubscribe\n\n# Getters\n@docs getTimestampOffset, getConnectionStatus, getAuthenticationStatus\n\n# Etc.\n@docs serverTimestampPlaceholder\n\n",
    "aliases": [
      {
        "name": "MetaBinding",
        "comment": " Server metadata binding. ",
        "args": [],
        "type": "{ address : Signal.Address (List Pylon.DB.Meta.MetaFeedback) , location : ElmFire.Location }"
      },
      {
        "name": "MetaData",
        "comment": " Server metadata record. ",
        "args": [],
        "type": "{ timeStampOffset : Pylon.Resource.Resource Pylon.DB.DBError Time.Time , isConnected : Pylon.Resource.Resource Pylon.DB.DBError Bool , authentication : Pylon.Resource.Resource Pylon.DB.DBError ElmFire.Auth.Authentication , subscriptions : Pylon.DB.Meta.MetaSubscriptions }"
      }
    ],
    "types": [
      {
        "name": "MetaFeedback",
        "comment": " Feedback for the the server metadata subscription. ",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "getAuthenticationStatus",
        "comment": " Get the resource representing the current authentication status to the server. ",
        "type": "Pylon.DB.Meta.MetaData -> Pylon.Resource.Resource Pylon.DB.DBError ElmFire.Auth.Authentication"
      },
      {
        "name": "getConnectionStatus",
        "comment": " Get the resource representing the current connection status to the server. ",
        "type": "Pylon.DB.Meta.MetaData -> Pylon.Resource.Resource Pylon.DB.DBError Bool"
      },
      {
        "name": "getTimestampOffset",
        "comment": " Get the resource representing the current timestamp offset to the server. ",
        "type": "Pylon.DB.Meta.MetaData -> Pylon.Resource.Resource Pylon.DB.DBError Time.Time"
      },
      {
        "name": "metaBindingTo",
        "comment": " Create a metadata binding for a firebase location. Should be the root location. ",
        "type": "ElmFire.Location -> Pylon.DB.Meta.MetaBinding"
      },
      {
        "name": "metaForwardingTo",
        "comment": " Add an address to a metadata binding with a forwarding function. ",
        "type": "(List Pylon.DB.Meta.MetaFeedback -> List action) -> Signal.Address (List action) -> Pylon.DB.Meta.MetaBinding -> Pylon.DB.Meta.MetaBinding"
      },
      {
        "name": "metaInput",
        "comment": " Server metadata list update function. ",
        "type": "List Pylon.DB.Meta.MetaFeedback -> Pylon.DB.Meta.MetaData -> Pylon.DB.Meta.MetaData"
      },
      {
        "name": "metaInputOne",
        "comment": " Server metadata single update function. ",
        "type": "Pylon.DB.Meta.MetaFeedback -> Pylon.DB.Meta.MetaData -> Pylon.DB.Meta.MetaData"
      },
      {
        "name": "metaSendingTo",
        "comment": " Add an address to a metadata binding. Unless you do this, feedback will go to a hidden internal\ndrain. ",
        "type": "Signal.Address (List Pylon.DB.Meta.MetaFeedback) -> Pylon.DB.Meta.MetaBinding -> Pylon.DB.Meta.MetaBinding"
      },
      {
        "name": "metaSubscribe",
        "comment": " Subscribe to the server metadata at your root Firebase location. ",
        "type": "Pylon.DB.Meta.MetaBinding -> Pylon.DB.Meta.MetaData -> ( Pylon.DB.Meta.MetaData, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "nilMetaData",
        "comment": " Empty metadata record. A metadata record should always be initialized to this. ",
        "type": "Pylon.DB.Meta.MetaData"
      },
      {
        "name": "serverTimestampPlaceholder",
        "comment": " A placeholder for encoding the server timestamp. ",
        "type": "Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.DB.Group",
    "comment": " Nested data. The typing is done such that one can arbitrarily nest groups, trivial data records,\nor even a compatible API fitting the same pattern such that this system is easily extensible.\n\n# Types\n@docs GroupFeedback, GroupBinding, Group\n\n# Direct Group Inquiry\n\n@docs getGroupCurrentData, getGroupDeltaData, getGroupDataResDeltas, getGroupDataResDeltaList, groupDataResDeltaFoldL, groupDataResDeltaFoldR, groupDeriveSub\n\n# Direct Group Manipulation\n\nYou can use these functions to perform nested operations on groups directly. You will need this\nfunctionality to write new items in to a group. Take care, however, that you _do not try to remove\nitems form the group by using `groupRemoveSub` directly._ To effect the remote data, you must\ninvoke the operations provided by `Pylon.DB`.\n\n@docs groupUpdateSub, groupDoSub, groupDoEachSub, groupAddSub, groupRemoveSub\n\n# Convenience Sub-Binding Shortcuts\n@docs dataSubBinding, groupSubBinding, dataRebasedBinding, groupRebasedBinding\n\n# DB.Binding Construction\n@docs bindingGroupTo, orderGroupBy, sendingGroupTo, forwardingGroupTo\n\n# Group Constructors\n@docs newGroup, voidGroup\n\n# Raw Group Operations\n@docs groupInputOne, groupInput, cancelGroup, resetGroup, cancelAndResetGroup, groupSubscriber\n\n# DB.Data Group Convenience\n@docs groupDataInputOne, groupDataInput, cancelDataGroup, cancelAndResetDataGroup, groupDataSubscriber, groupRebasedDataSubscriber\n\n",
    "aliases": [
      {
        "name": "Group",
        "comment": " Nested group record. ",
        "args": [
          "subtype"
        ],
        "type": "{ dataDelta : Dict.Dict String ( subtype, Pylon.DB.Group.GroupDelta ) , data : Pylon.Resource.Resource Pylon.DB.DBError (Dict.Dict String subtype) , addSubscription : Pylon.Resource.Resource Pylon.DB.DBError ElmFire.Subscription , removeSubscription : Pylon.Resource.Resource Pylon.DB.DBError ElmFire.Subscription , currentLocation : Maybe.Maybe ElmFire.Location }"
      },
      {
        "name": "GroupBinding",
        "comment": " Nested group subscription binding. ",
        "args": [
          "subfeedback"
        ],
        "type": "{ location : ElmFire.Location , address : Signal.Address (List (Pylon.DB.Group.GroupFeedback subfeedback)) , ordering : ElmFire.OrderOptions }"
      }
    ],
    "types": [
      {
        "name": "GroupFeedback",
        "comment": " DB.Feedback for nested group subscriptions. ",
        "args": [
          "subfeedback"
        ],
        "cases": [
          [
            "GroupSubscribedAdd",
            [
              "ElmFire.Subscription"
            ]
          ],
          [
            "GroupSubscribedRemove",
            [
              "ElmFire.Subscription"
            ]
          ],
          [
            "GroupAdd",
            [
              "String"
            ]
          ],
          [
            "GroupRemove",
            [
              "String"
            ]
          ],
          [
            "GroupSub",
            [
              "String",
              "subfeedback"
            ]
          ],
          [
            "GroupCancelledAdd",
            []
          ],
          [
            "GroupCancelledRemove",
            []
          ],
          [
            "GroupAddSubscriptionError",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "GroupRemoveSubscriptionError",
            [
              "ElmFire.Error"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "bindingGroupTo",
        "comment": " Construct a new incomplete group binding from a ElmFire Firebase location. ",
        "type": "ElmFire.Location -> Pylon.DB.Group.GroupBinding subfeedback"
      },
      {
        "name": "cancelAndResetDataGroup",
        "comment": " Convenience function for cancelling and resetting a `Group (DB.Data v)` at once, such that the next\ntime a `group*Subscriber` is reached, it will be immediately rebound. ",
        "type": "Pylon.DB.Group.Group (Pylon.DB.Data v) -> ( Pylon.DB.Group.Group (Pylon.DB.Data v) , List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "cancelAndResetGroup",
        "comment": " Convenience function for cancelling and resetting a group at once, such that the next time\na `group*Subscriber` is reached, it will be immediately rebound. ",
        "type": "(subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> Pylon.DB.Group.Group subtype -> ( Pylon.DB.Group.Group subtype, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "cancelDataGroup",
        "comment": " Convenience function for cancelling a `Group (DB.Data v)`. ",
        "type": "Pylon.DB.Group.Group (Pylon.DB.Data v) -> ( Pylon.DB.Group.Group (Pylon.DB.Data v) , List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "cancelGroup",
        "comment": " Cancel a `Group`'s active subscription if any, resulting in a `Group` that is not effected by\nsubscriptions until a call to `groupReset`. ",
        "type": "(subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> Pylon.DB.Group.Group subtype -> ( Pylon.DB.Group.Group subtype, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "dataRebasedBinding",
        "comment": " Rebased binding uses the key of the discovered item to get a child at a diffeent location than\nthat of the group binding. A good example would be a subscription that tracks a group of users,\nbut actually pulls data from a global profiles list. ",
        "type": "ElmFire.Location -> Pylon.DB.Config v -> Pylon.DB.Group.GroupBinding (Pylon.DB.Feedback v) -> String -> Pylon.DB.Binding v"
      },
      {
        "name": "dataSubBinding",
        "comment": " A convenience function which makes it a little bit easier to declare a sub-binding function for\nconcrete data. Note that if you are using the `groupDataSubscriber` convenience function, then this\nis already invoked internally, making the task of bindin a group of concrete records even easier. ",
        "type": "Pylon.DB.Config v -> Pylon.DB.Group.GroupBinding (Pylon.DB.Feedback v) -> String -> Pylon.DB.Binding v"
      },
      {
        "name": "forwardingGroupTo",
        "comment": " Provide an address for group feedback actions with a transformation function for forwarding. If\nthis is not applied to the binding, no feedback will be recieved. ",
        "type": "(List (Pylon.DB.Group.GroupFeedback subfeedback) -> List action) -> Signal.Address (List action) -> Pylon.DB.Group.GroupBinding subfeedback -> Pylon.DB.Group.GroupBinding subfeedback"
      },
      {
        "name": "getGroupCurrentData",
        "comment": " Get the current dictionary representing the group's sub-record mapping, without the most recent\ndeltas factored in. ",
        "type": "Pylon.DB.Group.Group subtype -> Dict.Dict String subtype"
      },
      {
        "name": "getGroupDataResDeltaList",
        "comment": " Get the current change in the group's data as a list of (key, (prior, current)) structures. ",
        "type": "Pylon.DB.Group.Group (Pylon.DB.Data v) -> List ( String , ( Pylon.Resource.Resource Pylon.DB.DBError v , Pylon.Resource.Resource Pylon.DB.DBError v ) )"
      },
      {
        "name": "getGroupDataResDeltas",
        "comment": " Get the current change in the group's data as a dictionary of resource pairs, each representing\nthe prior and current values of the data respectively. ",
        "type": "Pylon.DB.Group.Group (Pylon.DB.Data v) -> Dict.Dict String ( Pylon.Resource.Resource Pylon.DB.DBError v , Pylon.Resource.Resource Pylon.DB.DBError v )"
      },
      {
        "name": "getGroupDeltaData",
        "comment": " Get the current change in the group's data. ",
        "type": "Pylon.DB.Group.Group subtype -> Dict.Dict String (Maybe.Maybe subtype)"
      },
      {
        "name": "groupAddSub",
        "comment": " Add a sub item to the group. This is how you can write new data within a group. One should use\n`groupAddSub` to add a new record, then invoke a write operation to add a new item. ",
        "type": "subtype -> String -> Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "groupDataInput",
        "comment": " Convenience concrete `DB.Data` record group update function accepting a list of `DB.Feedback`. ",
        "type": "List (Pylon.DB.Group.GroupFeedback (Pylon.DB.Feedback v)) -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> Pylon.DB.Group.Group (Pylon.DB.Data v)"
      },
      {
        "name": "groupDataInputOne",
        "comment": " Convenience concrete `DB.Data` record group update function accepting one `DB.Feedback`. ",
        "type": "Pylon.DB.Group.GroupFeedback (Pylon.DB.Feedback v) -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> Pylon.DB.Group.Group (Pylon.DB.Data v)"
      },
      {
        "name": "groupDataResDeltaFoldL",
        "comment": " Fold from the left across the deltas, using a particular fold function and initial output. ",
        "type": "(String -> ( Pylon.Resource.Resource Pylon.DB.DBError v , Pylon.Resource.Resource Pylon.DB.DBError v ) -> foldout -> foldout) -> foldout -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> foldout"
      },
      {
        "name": "groupDataResDeltaFoldR",
        "comment": " Fold from the right across the deltas, using a particular fold function and initial output. ",
        "type": "(String -> ( Pylon.Resource.Resource Pylon.DB.DBError v , Pylon.Resource.Resource Pylon.DB.DBError v ) -> foldout -> foldout) -> foldout -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> foldout"
      },
      {
        "name": "groupDataSubscriber",
        "comment": " Convenience function that makes it easier to bind a `Group (DB.Data v)`. ",
        "type": "Pylon.DB.Config v -> Pylon.DB.Group.GroupBinding (Pylon.DB.Feedback v) -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> ( Pylon.DB.Group.Group (Pylon.DB.Data v) , List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "groupDeriveSub",
        "comment": " ",
        "type": "(subtype -> derived) -> String -> Pylon.DB.Group.Group subtype -> Maybe.Maybe derived"
      },
      {
        "name": "groupDoEachSub",
        "comment": " Perform groupDoSub at every existing key after deltas. ",
        "type": "(subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> Pylon.DB.Group.Group subtype -> ( Pylon.DB.Group.Group subtype, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "groupDoSub",
        "comment": " Update the data at the given key using an effector, as documented in `Pylon.App`. This can be\nused to nest the effectors provided by `Pylon.DB`, or in the case of nested groups, nesting can be\ndone as many layers deep as needed. _NOTE_ that this is how you can perform concrete operations\n`op*` on `DB.DB.Data` records bound recursively within the group. ",
        "type": "(subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> String -> Pylon.DB.Group.Group subtype -> ( Pylon.DB.Group.Group subtype, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "groupInput",
        "comment": " Group feedback update function accepting a list of `DB.Feedback`. ",
        "type": "subtype -> (subfeedback -> subtype -> subtype) -> List (Pylon.DB.Group.GroupFeedback subfeedback) -> Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "groupInputOne",
        "comment": " Group feedback update function accepting one `DB.Feedback`. ",
        "type": "subtype -> (subfeedback -> subtype -> subtype) -> Pylon.DB.Group.GroupFeedback subfeedback -> Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "groupRebasedBinding",
        "comment": " Rebased binding for nested groups. ",
        "type": "ElmFire.Location -> ElmFire.OrderOptions -> Pylon.DB.Group.GroupBinding (Pylon.DB.Group.GroupFeedback subfeedback') -> String -> Pylon.DB.Group.GroupBinding subfeedback'"
      },
      {
        "name": "groupRebasedDataSubscriber",
        "comment": " Convenience function that makes it easier to bind a `Group (DB.Data v)`. ",
        "type": "ElmFire.Location -> Pylon.DB.Config v -> Pylon.DB.Group.GroupBinding (Pylon.DB.Feedback v) -> Pylon.DB.Group.Group (Pylon.DB.Data v) -> ( Pylon.DB.Group.Group (Pylon.DB.Data v) , List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "groupRemoveSub",
        "comment": " Remove a sub item from the group. Note that this should very, very rarely ever be called manually\nunless the group in question is deliberately not currently bound, in which case this becomes a simple\ncollection type anyway. ",
        "type": "String -> Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "groupSubBinding",
        "comment": " A convenience function which makes it a little bit easier to declare a sub-binding function for\nnested groups. ",
        "type": "ElmFire.OrderOptions -> Pylon.DB.Group.GroupBinding (Pylon.DB.Group.GroupFeedback subfeedback') -> String -> Pylon.DB.Group.GroupBinding subfeedback'"
      },
      {
        "name": "groupSubscriber",
        "comment": " Subscribe to a group, such that members will be automatically added and removed on synchronization\nwith the remote database. This is designed to work recursively, such that nested groups and concrete\ndata record groups alike will be subscribed and cancelled appropriately as they are added and removed\ntransparently. Since using this function directly requires you to define the cancellation, subscription,\nand binding functions for the subtype, a convenience function is provided for binding groups of\nconcrete data records called `groupDataSubscriber` which makes subscribing to flat groups of data\nsubstantially easier. ",
        "type": "(subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> (subbinding -> subtype -> ( subtype, List (Pylon.DB.DBTask never) )) -> (Pylon.DB.Group.GroupBinding subfeedback -> String -> subbinding) -> Pylon.DB.Group.GroupBinding subfeedback -> Pylon.DB.Group.Group subtype -> ( Pylon.DB.Group.Group subtype, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "groupUpdateSub",
        "comment": " Update the item at the given key using a transformation function. This can be used to nest the\ntransformations provided by `Pylon.DB`, or in the case of nested groups from this module\n(`Pylon.DB.Group`), nesting can be done as many layers deep as needed. ",
        "type": "(subtype -> subtype) -> String -> Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "newGroup",
        "comment": " A new group item. ",
        "type": "Pylon.DB.Group.Group subtype"
      },
      {
        "name": "orderGroupBy",
        "comment": " Give an ordering for the group subscription's internal query. Note that this _will not order the\nresulting key-value dictionary_, but it is still useful because it will have an effect on which\nresults are produced by the Firebase API in the event that limiting is used, which is the case for\nmost practical applications. ",
        "type": "ElmFire.OrderOptions -> Pylon.DB.Group.GroupBinding subfeedback -> Pylon.DB.Group.GroupBinding subfeedback"
      },
      {
        "name": "resetGroup",
        "comment": " Reset a `Group`, such that the next time a `group*Subscriber` is reached, the `Group` will be\nrebound to the given `GroupBinding`.  ",
        "type": "Pylon.DB.Group.Group subtype -> Pylon.DB.Group.Group subtype"
      },
      {
        "name": "sendingGroupTo",
        "comment": " Provide an address for group feedback actions. If this is not applied to the binding, no feedback\nwill be recieved. ",
        "type": "Signal.Address (List (Pylon.DB.Group.GroupFeedback subfeedback)) -> Pylon.DB.Group.GroupBinding subfeedback -> Pylon.DB.Group.GroupBinding subfeedback"
      },
      {
        "name": "voidGroup",
        "comment": " A new void group item, which is to say that it starts in the cancelled state, so subscriptions\nwill have no effect when reached until a call to `resetGroup`. ",
        "type": "Pylon.DB.Group.Group subtype"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.DB",
    "comment": " High level 2-way data binding against Firebase using ElmFire. For 2-way binding of arbitrary,\npossibly nested collections of data, use `Pylon.DB.Group`. You should have ElmFire installed to\nuse this, and in order to avoid redundancy. A more general API that can be wired to other DB\nbackends is planned, but not promised.\n\n# Types\n@docs DBTask, DBError, Feedback, Config, Binding, Operation, Data\n\n# Define Operations\n@docs opSet, opSetAndPrioritize, opPrioritize, opUpdateChildren, opSetOrUpdateChildren, opDelete\n\n# Configuration\n@docs config, configDecoder, configEncoder, nilConfig, withEncoder, withDecoder, bindingTo, bindingFrom, sendingTo, forwardingTo\n\n# Data Constructors\n@docs newData, voidData\n\n# Data Binding\n@docs subscribe, cancel, reset, cancelAndReset, inputOne, input\n\n# Interrogating Data\n@docs getResource, getPriorResource, getLastFailed\n\n# Operate on Data\n@docs doOperationIf, doMap, doTransform, enqueueOperation, flushQueue, doOperation, doRetry\n\n",
    "aliases": [
      {
        "name": "Binding",
        "comment": " Data binding. Consists of a `Config`, an address for `Feedback`, and a location in Firebase. ",
        "args": [
          "v"
        ],
        "type": "{ config : Pylon.DB.Config v , address : Signal.Address (List (Pylon.DB.Feedback v)) , location : ElmFire.Location }"
      },
      {
        "name": "Config",
        "comment": " Data configuration, consisting of a JSON decoder/encoder pair. ",
        "args": [
          "v"
        ],
        "type": "{ decoder : Json.Decode.Decoder v, encoder : v -> Json.Encode.Value }"
      },
      {
        "name": "DBTask",
        "comment": " An alias for `App.FinalTask`. Kept for legacy reasons in our proprietary codebase. ",
        "args": [
          "never"
        ],
        "type": "Pylon.App.FinalTask never"
      },
      {
        "name": "Data",
        "comment": " Represents a piece of data that may be bound to a Firebase location. ",
        "args": [
          "v"
        ],
        "type": "{ subscription : Pylon.Resource.Resource Pylon.DB.DBError ElmFire.Subscription , value : Pylon.Resource.Resource Pylon.DB.DBError v , priorValue : Pylon.Resource.Resource Pylon.DB.DBError v , lastFailed : Maybe.Maybe (Pylon.DB.Operation v) , queue : List (Pylon.DB.Operation v) }"
      }
    ],
    "types": [
      {
        "name": "DBError",
        "comment": " A database error. ",
        "args": [],
        "cases": [
          [
            "QueryErrorTag",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "PermissionErrorTag",
            [
              "String"
            ]
          ],
          [
            "DataUnavailableErrorTag",
            [
              "String"
            ]
          ],
          [
            "OperationErrorTag",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "SubscriptionErrorTag",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "DecodingErrorTag",
            [
              "String"
            ]
          ]
        ]
      },
      {
        "name": "Feedback",
        "comment": " Feedback from the database. ",
        "args": [
          "v"
        ],
        "cases": [
          [
            "Subscribed",
            [
              "ElmFire.Subscription"
            ]
          ],
          [
            "SubscriptionError",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "Cancelled",
            []
          ],
          [
            "DecodingFailed",
            [
              "String"
            ]
          ],
          [
            "QueryError",
            [
              "ElmFire.Error"
            ]
          ],
          [
            "Updated",
            [
              "v"
            ]
          ],
          [
            "UpdatedToVoid",
            []
          ],
          [
            "OperationError",
            [
              "Pylon.DB.Operation v",
              "ElmFire.Error"
            ]
          ]
        ]
      },
      {
        "name": "Operation",
        "comment": " Opaque type for a database operation. ",
        "args": [
          "v"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "bindingFrom",
        "comment": " Flipped version of `bindingTo` that composes more naturally in the event that your configuration\nwas created elsewhere and reused with a new ElmFire location. ",
        "type": "Pylon.DB.Config v -> ElmFire.Location -> Pylon.DB.Binding v"
      },
      {
        "name": "bindingTo",
        "comment": " Create a new data binding from a configuration and an ElmFire location. ",
        "type": "ElmFire.Location -> Pylon.DB.Config v -> Pylon.DB.Binding v"
      },
      {
        "name": "cancel",
        "comment": " Cancel your subscription to the data. This puts the data in a void state, so that the\n`subscribe` function ceases to have any effect. In order to reactivate the binding, you must\ncall `reset`. A convenience function `cancelAndReset` is provided, which allows you to skip the\nsecond call if you simply wish to refresh, but not disable, the data binding. ",
        "type": "Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "cancelAndReset",
        "comment": " A convenience function that cancels any current bindings that might be live, then `reset`s the\nstructure so that the next time `subscribe` is reached the bindings will be reactivated immediately.\n",
        "type": "Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "config",
        "comment": " Declare a data configuration with a decoder/encoder pair. ",
        "type": "Json.Decode.Decoder v -> (v -> Json.Encode.Value) -> Pylon.DB.Config v"
      },
      {
        "name": "configDecoder",
        "comment": " Declare a data configuration with a decoder, but a dummy encoder. This is useful when you only\nwant one way binding from the server, or if you wish to declare the encoder and encoder seperately\nfor aesthetic reasons. ",
        "type": "Json.Decode.Decoder v -> Pylon.DB.Config v"
      },
      {
        "name": "configEncoder",
        "comment": " Same as above, but declare only an encoder. Offered for symmetry. ",
        "type": "(v -> Json.Encode.Value) -> Pylon.DB.Config v"
      },
      {
        "name": "doMap",
        "comment": " Map the current value of a bound `Data` record _iff_ the value is currently known. ",
        "type": "Pylon.DB.Binding v -> (v -> v) -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "doOperation",
        "comment": " Dispatch the given operation immediately on a bound `Data` record. ",
        "type": "Pylon.DB.Binding v -> Pylon.DB.Operation v -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "doOperationIf",
        "comment": " Conditionally dispatch an operation on a bound `Data` record. ",
        "type": "(Pylon.Resource.Resource Pylon.DB.DBError v -> Bool) -> Pylon.DB.Binding v -> Pylon.DB.Operation v -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "doRetry",
        "comment": " Retry the last operation that failed on a given bound `Data` record in the case that any\nexists. ",
        "type": "Pylon.DB.Binding v -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "doTransform",
        "comment": " Transform the resource within a bound `Data` record. Do not use this unless you absolutely know what you are doing! ",
        "type": "Pylon.DB.Binding v -> (Pylon.Resource.Resource Pylon.DB.DBError v -> Pylon.Resource.Resource Pylon.DB.DBError v) -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "enqueueOperation",
        "comment": " Add an operation to the queue. ",
        "type": "Pylon.DB.Operation v -> Pylon.DB.Data v -> Pylon.DB.Data v"
      },
      {
        "name": "flushQueue",
        "comment": " Flush the queue of pending operations, resulting in a list of tasks. ",
        "type": "Pylon.DB.Binding v -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "forwardingTo",
        "comment": " Set the `Feedback` address for a data binding to some forwarding address. Commonly, this is used\nto nest `Feedback` within an action type from your application. ",
        "type": "(List (Pylon.DB.Feedback v) -> List action) -> Signal.Address (List action) -> Pylon.DB.Binding v -> Pylon.DB.Binding v"
      },
      {
        "name": "getLastFailed",
        "comment": " Get the last operation that failed on the record, if it exists. ",
        "type": "Pylon.DB.Data v -> Maybe.Maybe (Pylon.DB.Operation v)"
      },
      {
        "name": "getPriorResource",
        "comment": " Get the prior value of the resource tracked in the `Data` record, as of the last time it changed. ",
        "type": "Pylon.DB.Data v -> Pylon.Resource.Resource Pylon.DB.DBError v"
      },
      {
        "name": "getResource",
        "comment": " Get the underlying resource tracked in the `Data` record. ",
        "type": "Pylon.DB.Data v -> Pylon.Resource.Resource Pylon.DB.DBError v"
      },
      {
        "name": "input",
        "comment": " Input list update function for `Data`. ",
        "type": "List (Pylon.DB.Feedback v) -> Pylon.DB.Data v -> Pylon.DB.Data v"
      },
      {
        "name": "inputOne",
        "comment": " Single input update function for `Data`. ",
        "type": "Pylon.DB.Feedback v -> Pylon.DB.Data v -> Pylon.DB.Data v"
      },
      {
        "name": "newData",
        "comment": " An empty, unbound data. Always initialize instance of Data to this and then invoke `subscribe`\nto enable data flow back to the client. ",
        "type": "Pylon.DB.Data v"
      },
      {
        "name": "nilConfig",
        "comment": " A configuration that hasn't yet been filled out. The decoder always fails, and the encoder\nalways encodes a `null`. Used by `configDecoder` and `configEncoder`. ",
        "type": "Pylon.DB.Config v"
      },
      {
        "name": "opDelete",
        "comment": " Delete the bound data. ",
        "type": "Pylon.DB.Operation v"
      },
      {
        "name": "opPrioritize",
        "comment": " Give the data a Firebase priority. ",
        "type": "ElmFire.Priority -> Pylon.DB.Operation v"
      },
      {
        "name": "opSet",
        "comment": " Set the data to some value. ",
        "type": "v -> Pylon.DB.Operation v"
      },
      {
        "name": "opSetAndPrioritize",
        "comment": " Set the data to some value and give it a Firebase priority. ",
        "type": "v -> ElmFire.Priority -> Pylon.DB.Operation v"
      },
      {
        "name": "opSetOrUpdateChildren",
        "comment": " Combination operation that sets the data if the data is known to be void, or else performs the\nabove listed `opUpdateChildren`. ",
        "type": "v -> Pylon.DB.Operation v"
      },
      {
        "name": "opUpdateChildren",
        "comment": " Update the children in the JSON structure of the data. This diffs the value of the data\ncurrently against the given value after encoding so that a minimal update is always done.\n\nTODO : This may not work right in the event that the data has been updated remotely but not yet\nsynced to the server. One way around this might be to manually fetch the data first as part of\nthe operation. ",
        "type": "v -> Pylon.DB.Operation v"
      },
      {
        "name": "reset",
        "comment": " Reset the given data from a void or error state so that the binding can be attempted again the\nnext time `subscribe` is reached. Notice that this is a simple transformation and not an effector,\nso if the data binding is live, this will have no effect. If you wish to cancel an existing\nsubscription that is live and has not erred, then you should use `cancel`, or `cancelAndReset` in\nthe case that you wish to rebind the data right away. ",
        "type": "Pylon.DB.Data v -> Pylon.DB.Data v"
      },
      {
        "name": "sendingTo",
        "comment": " Set the `Feedback` address for a data binding. By default, data bindings are bound to a\nhidden drain so that you can more comfortably construct bindings without being sure of the target\naddress right away. ",
        "type": "Signal.Address (List (Pylon.DB.Feedback v)) -> Pylon.DB.Binding v -> Pylon.DB.Binding v"
      },
      {
        "name": "subscribe",
        "comment": " `subscribe` is an effector (see Pylon.App for what what we define an effector to be) that takes\na `Binding` and a `Data`. The resulting tasks when executed will set up 2 way data binding using the\n`Config` within the `Binding` to encode and decode the data, and sending all feedback to the\naddress within the `Binding`.  _Take care to set an address on your `Binding`_, or else the\nfeedback from the database _will not be recieved by your application._ ",
        "type": "Pylon.DB.Binding v -> Pylon.DB.Data v -> ( Pylon.DB.Data v, List (Pylon.DB.DBTask never) )"
      },
      {
        "name": "voidData",
        "comment": " A new void data item, which will not be bound by a subscription until it is `reset`. ",
        "type": "Pylon.DB.Data v"
      },
      {
        "name": "withDecoder",
        "comment": " Add a decoder to an existing configuration. ",
        "type": "Json.Decode.Decoder v -> Pylon.DB.Config v -> Pylon.DB.Config v"
      },
      {
        "name": "withEncoder",
        "comment": " Add an encoder to an existing configuration. ",
        "type": "(v -> Json.Encode.Value) -> Pylon.DB.Config v -> Pylon.DB.Config v"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.Resource",
    "comment": " Resource types and reductions. Heavily pruned from Scaffold predecessor to give only what has\nbeen tested, used in practice, and proven useful.\n\n# Resource Type\n\nThis type represents a single remote resource in such a way that it's state can be easily reduced\nto a more abstract representation, either for another part of the system, or the user's view itself.\n\nWe export the tags as well so as to allow the user easy case destructuring.\n@docs Resource\n\n\n# Resource Constructors\n@docs def, pending, undecided, void, unknown\n\n\n# Predicate Composition\n@docs isAll, isAny\n\n\n# Predicates\n@docs isKnown, isNotKnown, isPending, isNotPending, isNotUndecided, isNotUnknown, isNotVoid, isUndecided, isUnknown, isVoid\n\n\n# Reduction\n@docs therefore, otherwise, decideBy, assumeIf, assumeIfNot, assumeInCase, deriveIf\n\n\n# Interop with Result and Maybe\n@docs maybeKnown, maybeOr, resultOr\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Resource",
        "comment": " A resource item. ",
        "args": [
          "errortype",
          "v"
        ],
        "cases": [
          [
            "Unknown",
            []
          ],
          [
            "Pending",
            []
          ],
          [
            "Void",
            []
          ],
          [
            "Undecided",
            [
              "errortype"
            ]
          ],
          [
            "Known",
            [
              "v"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "assumeIf",
        "comment": " If the given predicate is satisfied, the result will be known to the the given value, otherwise\nthe given resource will be given unchanged. ",
        "type": "(Pylon.Resource.Resource errortype v -> Bool) -> v -> Pylon.Resource.Resource errortype v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "assumeIfNot",
        "comment": " Negation of assumeIf. ",
        "type": "(Pylon.Resource.Resource errortype v -> Bool) -> v -> Pylon.Resource.Resource errortype v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "assumeInCase",
        "comment": " In the case that the provided function returns `Just x`, the resource shall be known as that\nvalue, otherwise the Resource shall remain unchanged.  ",
        "type": "(Pylon.Resource.Resource errortype v -> Maybe.Maybe v) -> Pylon.Resource.Resource errortype v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "decideBy",
        "comment": " If the resource is an undecided resource, then the given  ",
        "type": "(errortype -> Pylon.Resource.Resource errortype v) -> Pylon.Resource.Resource errortype v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "def",
        "comment": "  ",
        "type": "v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "deriveIf",
        "comment": " If the predicate is true, apply the given transformation to get a new resource. ",
        "type": "(Pylon.Resource.Resource errortype v' -> Bool) -> (Pylon.Resource.Resource errortype v' -> Pylon.Resource.Resource errortype v') -> Pylon.Resource.Resource errortype v' -> Pylon.Resource.Resource errortype v'"
      },
      {
        "name": "isAll",
        "comment": " True if _all_ of the given predicates is True, otherwise False. ",
        "type": "List (Pylon.Resource.Resource errortype v -> Bool) -> Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isAny",
        "comment": " True if _any_ of the given predicates is True, otherwise False. ",
        "type": "List (Pylon.Resource.Resource errortype v -> Bool) -> Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isKnown",
        "comment": " True if the resource is known. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isNotKnown",
        "comment": " False if the resource is known. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isNotPending",
        "comment": " False if the resource is pending. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isNotUndecided",
        "comment": " False if the resource is undecided. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isNotUnknown",
        "comment": " False if the resource is unknown. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isNotVoid",
        "comment": " False if the resource is void. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isPending",
        "comment": " True if the resource is pending. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isUndecided",
        "comment": " True if the resource is undecided. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isUnknown",
        "comment": " True if the resource is unknown. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "isVoid",
        "comment": " True if the resource is void. ",
        "type": "Pylon.Resource.Resource errortype v -> Bool"
      },
      {
        "name": "maybeKnown",
        "comment": " If a resource is known, then give Just it's value, otherwise Nothing. ",
        "type": "Pylon.Resource.Resource errortype v' -> Maybe.Maybe v'"
      },
      {
        "name": "maybeOr",
        "comment": " ",
        "type": "Pylon.Resource.Resource errortype v -> Maybe.Maybe v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "otherwise",
        "comment": " In the event that the given resource is not a simple `def`, we replace it with a different simple\nresource. ",
        "type": "v' -> Pylon.Resource.Resource errortype v' -> v'"
      },
      {
        "name": "pending",
        "comment": "  ",
        "type": "Pylon.Resource.Resource errortype v"
      },
      {
        "name": "resultOr",
        "comment": "  ",
        "type": "(errortype -> Pylon.Resource.Resource errortype v) -> Result.Result errortype v -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "therefore",
        "comment": " Given a resource of value type v, create a resource of value type v' by transforming the\nknown value or group using some function (v -> v'). NOTE that this will create an entirely new\nresouce structure, and thus any pending changes will be integrated immediately. If you wish to\npreserve deltas for the purpose of mirroring and efficient data flow, then one should be using\ndeltaTo in order to transform just the changes. ",
        "type": "(v -> v') -> Pylon.Resource.Resource errortype v -> Pylon.Resource.Resource errortype v'"
      },
      {
        "name": "undecided",
        "comment": "  ",
        "type": "errortype -> Pylon.Resource.Resource errortype v"
      },
      {
        "name": "unknown",
        "comment": "  ",
        "type": "Pylon.Resource.Resource errortype v"
      },
      {
        "name": "void",
        "comment": "  ",
        "type": "Pylon.Resource.Resource errortype v"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  },
  {
    "name": "Pylon.App",
    "comment": " Application module. Similar to StartApp, but with a few extra utilities. Heavily pruned and\nsimplified with respect to it's predecessor in Scaffold. No longer suffers from heinous type\nbloat.\n\n\n# Configuration And Application Structures\n\nThe basic building blocks of the application top level.\n\n@docs Options, Config, Output\n\n\n# Task Types\n\n@docs Dispatch, ActionTask, FinalTask\n\n\n# Task List Dispatch Methods\n\n@docs parallel, sequence\n\n\n# Constructing Options\n\n@docs defaultOptions, optionsDispatchMethod, optionsRunInputsOnStartup\n\n\n# Configuration DSL\n\nCumulatively build a configuration using this convenient DSL, starting either from a `nilConfig`\nor starting from a `configWithOptions`. The latter can be very nice for flowing right in to building\na configuration from building an `Options` struct.\n\n@docs nilConfig, configWithOptions, configOptions, configInit, configUpdateList, configUpdate, configStage, configPresent, configInput, configListInput, configRawInput\n\n# Chaining Effectors\n\nEffectors are functions which give a pair, the first element of which is the of the same type as the\nlast argument, and the second element of which is some list of tasks. Chaining is a useful way to\noperate on a single model with a sequence of actions, all of which might produce tasks. We use\nlists of tasks so that we can elegantly account for the case where no tasks are produced as well as\npossibly producing a number of tasks to execute. Such task lists can be either explicitly reduced\nby the user using `finalizeTasks`, or they can be converted to `ActionTask`s and returned to the\ntop level, where the configured `Dispatch` method is used to run the tasks.\n\n@docs chain, chainIf, chainSub, chainSubIf, chainFinalizingEach, asEffector, mappedEffector, finalizedEffector\n\n\n# Task Manipulation\n\nSend the results of tasks to addresses, and dispatch them. Use of existing task primitives to handle\nsituations outside the scope of simply sending/forwarding results to the app's mailbox address and\ndetermining their order of execution is encouraged, so that a repeat of the awful `agent` DSL\nfrom Pylon's predecessor Scaffold is not repeated.\n\n@docs promoteActions, handleErrors, mapErrors, sendActions, forwardActions, sendErrorActions, sendResultActions, finalizeTasks, finalizeTask, thenDo, thenDoNothing\n\n\n# Running The Application\n\n`run` will allow you to run an application given an initial model and view with a configuration.\n`doCycle` exposes the internal functionality used by run, with a little syntactic sugar.\n\n@docs doCycle, run\n\n\n# Manipulating Sub Models\n@docs doSubUpdate, doSubStage, doSubPresent, doSubCycle\n\n",
    "aliases": [
      {
        "name": "ActionTask",
        "comment": " A task which results in a list of actions. This can be routed to an address. ",
        "args": [
          "errortype",
          "actiontype"
        ],
        "type": "Task.Task errortype (List actiontype)"
      },
      {
        "name": "Config",
        "comment": " Configure an application. Sane defaults are provided so that you can construct as much or as\nlittle as you need using the provided DSL. ",
        "args": [
          "never",
          "modeltype",
          "actiontype",
          "viewtype"
        ],
        "type": "{ init : Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) ) , inputs : List (Signal.Signal (List actiontype)) , update : List actiontype -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) ) , stage : Signal.Address (List actiontype) -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) ) , present : Signal.Address (List actiontype) -> Time.Time -> modeltype -> ( Maybe.Maybe viewtype, List (Pylon.App.FinalTask never) ) , options : Pylon.App.Options }"
      },
      {
        "name": "FinalTask",
        "comment": " FinalTask represents a task whose results have been routed to an address, and is ready to be\nexecuted. ",
        "args": [
          "never"
        ],
        "type": "Task.Task never ()"
      },
      {
        "name": "Options",
        "comment": " Some extra options for apps.\n\n    runInputsOnStartup    -- If this is true, run the actions produced by the initial input signals\n                          -- on startup.\n\n    dispatchMethod        -- May either dispatch the top level tasks returned in sequence or in\n                          -- parallel.\n\n",
        "args": [],
        "type": "{ runInputsOnStartup : Bool, dispatchMethod : Pylon.App.Dispatch }"
      },
      {
        "name": "Output",
        "comment": " Output of the application. Contains the current view, the current model, the current time, and the latest task if it exists. ",
        "args": [
          "never",
          "modeltype",
          "viewtype"
        ],
        "type": "{ view : Signal.Signal viewtype , model : Signal.Signal modeltype , now : Signal.Signal Time.Time , tasks : Signal.Signal (Pylon.App.FinalTask never) }"
      }
    ],
    "types": [
      {
        "name": "Dispatch",
        "comment": " Task dispatch mode. ",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "asEffector",
        "comment": " If you want to take a simple transformation `a -> a` and include it in a chain of\n`a -> (a, List (Task z r))`, this is your tool for doing that. ",
        "type": "(modeltype -> modeltype) -> modeltype -> ( modeltype, List (Task.Task z r) )"
      },
      {
        "name": "chain",
        "comment": " Utility function for chaining effectors. ",
        "type": "List (modeltype -> ( modeltype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Task.Task z r) )"
      },
      {
        "name": "chainFinalizingEach",
        "comment": " Chaining effectors, finalizing each resultant task list seperately using the given dispatch\nmethod. ",
        "type": "Pylon.App.Dispatch -> List (modeltype -> ( modeltype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "chainIf",
        "comment": " Conditionally chain some effectors. ",
        "type": "(modeltype -> Bool) -> List (modeltype -> ( modeltype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Task.Task z r) )"
      },
      {
        "name": "chainSub",
        "comment": " Chain a list of effectors on a sub model. Provide a fetch and an update function to extract\nand replace the sub model, before and after executing the chain of effectors on the sub model\nrespectively. ",
        "type": "(modeltype -> innertype) -> (innertype -> modeltype -> modeltype) -> List (innertype -> ( innertype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Task.Task z r) )"
      },
      {
        "name": "chainSubIf",
        "comment": " Conditionally subchain some effectors. ",
        "type": "(modeltype -> Bool) -> (modeltype -> innertype) -> (innertype -> modeltype -> modeltype) -> List (innertype -> ( innertype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Task.Task z r) )"
      },
      {
        "name": "configInit",
        "comment": " Set an initialization function on the app. ",
        "type": "(Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configInput",
        "comment": " Configure an input. ",
        "type": "(inputtype -> actiontype) -> Signal.Signal inputtype -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configListInput",
        "comment": " Configure a list input. ",
        "type": "(List inputtype -> List actiontype) -> Signal.Signal (List inputtype) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configOptions",
        "comment": " Set some extra options on the configuration. ",
        "type": "Pylon.App.Options -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configPresent",
        "comment": " Set a presentation function on the app. This can optionally update the view of the application,\nor not by returning nothing. ",
        "type": "(Signal.Address (List actiontype) -> Time.Time -> modeltype -> ( Maybe.Maybe viewtype, List (Pylon.App.FinalTask never) )) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configRawInput",
        "comment": " Configure a raw input. ",
        "type": "Signal.Signal (List actiontype) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configStage",
        "comment": " Set a staging function on the app. Staging is done after all actions are passed through update,\nbut before presentation. ",
        "type": "(Signal.Address (List actiontype) -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configUpdate",
        "comment": " Add a classic single action update function, which is simpler and just as good for most use\ncases. ",
        "type": "(actiontype -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configUpdateList",
        "comment": " Add an update function which is aware of an entire atomic action list as it comes in. ",
        "type": "(List actiontype -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )) -> Pylon.App.Config never modeltype actiontype viewtype -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "configWithOptions",
        "comment": " A nil configuration, with the given options set. ",
        "type": "Pylon.App.Options -> Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "defaultOptions",
        "comment": " Default options. `runInputsOnStartup` set to `True`. ",
        "type": "Pylon.App.Options"
      },
      {
        "name": "doCycle",
        "comment": " Perform a full cycle on a `(model, view)` pair, using the given application configuration. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> Signal.Address (List actiontype) -> List actiontype -> Time.Time -> ( modeltype, viewtype ) -> ( ( modeltype, viewtype ), List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "doSubCycle",
        "comment": " Perform a full cycle with action promotion. Useful for nesting models. This is\ndeliberately left very unambiguous to avoid obfuscation. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> (List actiontype -> List outeraction) -> Signal.Address (List outeraction) -> List actiontype -> Time.Time -> ( modeltype, viewtype ) -> ( ( modeltype, viewtype ), List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "doSubPresent",
        "comment": " Present a sub model. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> (List actiontype -> List outeraction) -> Signal.Address (List outeraction) -> Time.Time -> modeltype -> ( Maybe.Maybe viewtype, List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "doSubStage",
        "comment": " Stage a sub model. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> (List actiontype -> List outeraction) -> Signal.Address (List outeraction) -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "doSubUpdate",
        "comment": " Update a sub model. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> (List actiontype -> List outeraction) -> List actiontype -> Time.Time -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "finalizeTask",
        "comment": " Convert any task in to a `FinalTask`. This does not take a `Dispatch` method, because said\nmethod only makes sense when applied to a list of tasks, not a single task. ",
        "type": "Task.Task e r -> List (Pylon.App.FinalTask never)"
      },
      {
        "name": "finalizeTasks",
        "comment": " Dispatch any arbitrary list of tasks using the given dispatch mode, which may be `parallel` or\n`sequence`. Note that for the sake of cleaner typing, the output of this function is a list of\n`FinalTask`s, however, this list may only have one member in the case that tasks are being\ndispatched, otherwise empty if the input list was empty. This is because finalizing a list of\ntasks will collapse it, encoding the manner in which is should execute in the resultant task if\nit exists. ",
        "type": "Pylon.App.Dispatch -> List (Task.Task e r) -> List (Pylon.App.FinalTask never)"
      },
      {
        "name": "finalizedEffector",
        "comment": " Transform an effector by finalizing it's resulting tasks immediately using the given dispatch method. ",
        "type": "Pylon.App.Dispatch -> (modeltype -> ( modeltype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Pylon.App.FinalTask never) )"
      },
      {
        "name": "forwardActions",
        "comment": " Forward the list of actions produced on the success of this task to the given address using the given transformation function. ",
        "type": "(List actiontype -> List actiontype') -> Signal.Address (List actiontype') -> Pylon.App.ActionTask errortype actiontype -> Pylon.App.ActionTask errortype actiontype'"
      },
      {
        "name": "handleErrors",
        "comment": " Transform errors from the given task in to actions. ",
        "type": "(errortype -> List actiontype) -> Pylon.App.ActionTask errortype actiontype -> Pylon.App.ActionTask z actiontype"
      },
      {
        "name": "mapErrors",
        "comment": " Map the errors of a given task to another type of error. ",
        "type": "(errortype -> errortype') -> Task.Task errortype r -> Task.Task errortype' r"
      },
      {
        "name": "mappedEffector",
        "comment": " Transform the task output of an effector. This is useful if an effector works on the right type of model\nbut needs a shim to fit the correct task type ",
        "type": "(List (Task.Task z r) -> List (Task.Task z' r')) -> (modeltype -> ( modeltype, List (Task.Task z r) )) -> modeltype -> ( modeltype, List (Task.Task z' r') )"
      },
      {
        "name": "nilConfig",
        "comment": " Empty configuration, providing all defaults and nil behavior. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype"
      },
      {
        "name": "optionsDispatchMethod",
        "comment": " Set the dispatch method for the top level ActionTasks returned by application functions. ",
        "type": "Pylon.App.Dispatch -> Pylon.App.Options -> Pylon.App.Options"
      },
      {
        "name": "optionsRunInputsOnStartup",
        "comment": " Set whether or not to run options. ",
        "type": "Bool -> Pylon.App.Options -> Pylon.App.Options"
      },
      {
        "name": "parallel",
        "comment": " Dispatch tasks in parallel, no ordering is required. ",
        "type": "Pylon.App.Dispatch"
      },
      {
        "name": "promoteActions",
        "comment": " Transform the action list type of an `ActionTask`. ",
        "type": "(List actiontype -> List actiontype') -> Pylon.App.ActionTask errortype actiontype -> Pylon.App.ActionTask errortype actiontype'"
      },
      {
        "name": "run",
        "comment": " With the given configuration, start the application as in StartApp with the given initial model,\nand the given default view. ",
        "type": "Pylon.App.Config never modeltype actiontype viewtype -> modeltype -> viewtype -> Pylon.App.Output never modeltype viewtype"
      },
      {
        "name": "sendActions",
        "comment": " Send the list of actions produced on the success of this task to the given address.  ",
        "type": "Signal.Address (List actiontype) -> Pylon.App.ActionTask errortype actiontype -> Pylon.App.ActionTask errortype actiontype"
      },
      {
        "name": "sendErrorActions",
        "comment": " Translate task error to a list of actions and send to the given address. ",
        "type": "(errortype -> List actiontype) -> Signal.Address (List actiontype) -> Pylon.App.ActionTask errortype actiontype -> Pylon.App.ActionTask errortype actiontype"
      },
      {
        "name": "sendResultActions",
        "comment": " Interpret the result of the task whether success or failure as some list of actions and then send. ",
        "type": "(Result.Result errortype successtype -> List actiontype) -> Signal.Address (List actiontype) -> Task.Task errortype successtype -> Pylon.App.ActionTask errortype actiontype"
      },
      {
        "name": "sequence",
        "comment": " Dispatch tasks in sequence. Tasks will execute strictly in the order provided. ",
        "type": "Pylon.App.Dispatch"
      },
      {
        "name": "thenDo",
        "comment": " Turn any task in to an `ActionTask` by performing the given list of actions upon it's successful\ncompletion. Notably, this may be used to turn an `FinalTask` back in to an action task. ",
        "type": "List actiontype -> Task.Task errortype r -> Pylon.App.ActionTask errortype actiontype"
      },
      {
        "name": "thenDoNothing",
        "comment": " Turn any task in to an `ActionTask` without actually performing any actions. This is good for\ntransforming tasks that need to be returned from the top level of the application which have already\nbeen finalized, so the types simply have to match. It should be noted that empty action lists do\nnot trigger any update, staging, or presentation, and as such a busy loop caused by repeated\ndispatchment of empty action tasks will not occur. ",
        "type": "Task.Task errortype r -> Pylon.App.ActionTask errortype a"
      }
    ],
    "generated-with-elm-version": "0.16.0"
  }
]