[{"name":"UUID","comment":" A UUID looks something like `e1631449-6321-4a58-920c-5440029b092e`, and can\nbe used as an identifier for anything. Each 128-bit number, usually represented\nas 32 hexadecimal digits, is generally assumed to be Universally Unique (hence\nthe name).\n\n@docs UUID\n\n\n## Creating UUIDs\n\nUUIDs have version numbers (1-5), which describe how they were created, and\nvariant numbers (1-2) which describes how they are stored. This module can read\nall UUIDs, but can only currently create versions 3, 5 (namespaced, heirarchical\nsystems) and 4 (a randomly-generated UUID). It creates variant 1 UUIDs (probably\nthe best choice if you don't have a specific need for variant 2), but can\nconvert them to variant 2.\n\n\n### Nil UUID\n\n@docs nil\n\n\n### Random UUIDs (Version 4)\n\nRandomly-generated UUIDs are called version 4 UUIDs. This package provides a\n`Random.Generator` for the [`elm/random`][elm-random] library.\n\n[elm-random]: https://package.elm-lang.org/packages/elm/random/latest/\n\n@docs generator\n\n\n### Hierarchical, namespaced UUIDs (Version 3, Version 5)\n\nUUIDs can be created using a namespace UUID and a name, which is then hashed to\ncreate a new UUID. The hash function used depends on the version of UUID:\nverison 3 UUIDs use MD5, and version 5 UUIDs use SHA-1. **Version 5 (using\nSHA-1) is the [recommended] version to use.**\n\nOnce generated, these UUIDs can then be used as a namespace, making a hierarchy!\nI think this is pretty cool! You can use this method for making predictable\nUUIDs from data, and it also has the added bonus that you don't have to deal\nwith random generators/seeds.\n\n[recommended]: https://tools.ietf.org/html/rfc4122#section-4.3\n\n@docs childNamed, v5ChildNamed, v3ChildNamed\n\nThe [RFC defining UUIDs][rfc] defines some [base UUIDs][appendix-c] to start\nyour hierarchy.\n\n[rfc]: https://tools.ietf.org/html/rfc4122\n[appendix-c]: https://tools.ietf.org/html/rfc4122#appendix-C\n\n@docs dns, url, oid, x500\n\n\n### Making variant 2 UUIDs\n\nThe above functions for creating UUIDs all create variant 1 UUIDs. If you need\nto create a variant 2 UUID, any UUID can be converted to a variant 2 UUID with\n`toVariant2`. Note that variant 2 UUIDs cannot be converted to variant 1 UUIDs.\n\n@docs toVariant2\n\n\n### Existing UUIDs\n\n@docs fromString\n\n\n## Formatting\n\nUUIDs are generally represented by 32 hexadecimal digits in the form\n`00112233-4455-M677-N899-aabbccddeeff`, where the four bits at position `M`\ndenote the UUID version, and the first two or three bits at position `N` denote\nthe variant. This is the \"canonical\" representation, but there is also a\nMicrosoft GUID representation and a URN representation.\n\n@docs toString, canonical, microsoftGUID, urn\n\n\n## Inspecting UUIDs\n\nSometimes you may need to check a UUID's version, variant, or whether it's nil.\n\n@docs isNil, version, isVersion, variant, isVariant, isValid\n\nSometimes you may need to ensure that a UUID is definitely a certain version or\nvariant. If you're decoding from JSON, you may find the following functions\nuseful in conjunction with [json-extra's fromResult function][fromResult].\n\n[fromResult]: https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra#fromResult\n\n    import Json.Decode\n    import Json.Decode.Extra\n\n    uuidDecoder : Json.Decode.Decoder UUID\n    uuidDecoder =\n        Json.Decode.string\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.fromString)\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.checkVersion 4)\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.checkVariant 1)\n\n    Json.Decode.decodeString uuidDecoder \"\\\"00000000-0000-0000-0000-000000000000\\\"\"\n        |> Result.toMaybe\n    --> Nothing\n\n    Json.Decode.decodeString uuidDecoder \"\\\"7d25c9af-c80d-4304-a984-1d0b20fc581a\\\"\"\n        |> Result.map UUID.canonical\n    --> Ok \"7d25c9af-c80d-4304-a984-1d0b20fc581a\"\n\n@docs checkNotNil, checkVersion, checkVariant, checkValid\n\n","unions":[{"name":"UUID","comment":" This modules provides a UUID type, and functions to work with them. It is an\n[opaque type], which basically means you have to use the provided functions if\nyou want to do anything with it!\n\n[opaque type]: https://medium.com/@ckoster22/advanced-types-in-elm-opaque-types-ec5ec3b84ed2\n\nHere is an example of a `Book` model, which uses UUIDs to identify both the book\nand its authors:\n\n    type alias Book =\n        { title : String\n        , uuid : UUID\n        , published : Maybe Date\n        , authors : List UUID\n        }\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"canonical","comment":" Convert UUID to [canonical textual representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    canonical nil\n    --> \"00000000-0000-0000-0000-000000000000\"\n\n","type":"UUID.UUID -> String.String"},{"name":"checkNotNil","comment":" A simple function to use while chaining `Result`s. Makes sure the UUID\nyou're dealing with isn't the Nil UUID!\n\n    \"8b681345-171d-48a0-9406-469d0a9de997\"\n        |> UUID.fromString\n        |> Result.andThen checkNotNil\n        |> Result.map canonical\n    --> Ok \"8b681345-171d-48a0-9406-469d0a9de997\"\n\n","type":"UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"checkValid","comment":" Checks if the UUID properly defines a version and variant, and if not return\nan `Err`. Note: the nil UUID is not valid!\n\n    checkValid nil == Err \"UUID is nil\"\n\n    UUID.fromString \"c72c207b-0847-386d-bdbc-2e5def81cf81\"\n        |> Result.andThen UUID.checkValid\n        |> Result.map UUID.canonical\n        |> (==) Ok \"c72c207b-0847-386d-bdbc-2e5def81cf81\"\n\n    UUID.fromString \"c72c207b-0847-986d-bdbc-2e5def81cf81\"\n        |> Result.andThen UUID.checkValid\n        |> (==) Err \"Version not defined\"\n\n","type":"UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"checkVariant","comment":" Check which variant a UUID is, and if it's not the right one, return an `Err`.\n\n    import Random\n\n    someVariant1UUID : UUID\n    someVariant1UUID = Random.step generator (Random.initialSeed 2355673) |> Tuple.first\n\n    someVariant1UUID |> checkVariant 1\n    --> Ok someVariant1UUID\n\n    nil |> v3ChildNamed \"hello\" |> checkVariant 2\n    --> Err \"UUID is not variant 2\"\n\n    nil |> checkVariant 2\n    --> Err \"UUID does not define a valid variant\"\n\n","type":"Basics.Int -> UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"checkVersion","comment":" Check which version a UUID is, and if it's not the right one, return an `Err`.\n\n    import Random\n\n    someVersion4UUID : UUID\n    someVersion4UUID = Random.step generator (Random.initialSeed 3476326) |> Tuple.first\n\n    someVersion4UUID |> checkVersion 4\n    --> Ok someVersion4UUID\n\n    nil |> v3ChildNamed \"hello\" |> checkVersion 4\n    --> Err \"UUID is not Version 4\"\n\n    nil |> checkVersion 1\n    --> Err \"UUID does not define a valid version\"\n\n","type":"Basics.Int -> UUID.UUID -> Result.Result String.String UUID.UUID"},{"name":"childNamed","comment":" Start with an existing UUID as a \"parent\" UUID, and provide a name to create\na new UUID.\n\n    grandparent : UUID\n    grandparent = nil\n\n    parent : UUID\n    parent = grandparent |> childNamed \"parent\"\n\n    parentsSibling : UUID\n    parentsSibling = grandparent |> childNamed \"parent's sibling\"\n\n    child1 : UUID\n    child1 = parent |> childNamed \"child1\"\n\n    child2 : UUID\n    child2 = parent |> childNamed \"child2\"\n\n    cousin : UUID\n    cousin = parentsSibling |> childNamed \"cousin\"\n\n    canonical child2\n    --> \"8081b7b9-1fb0-54a5-bcf3-e27b4b07f381\"\n\n","type":"String.String -> UUID.UUID -> UUID.UUID"},{"name":"dns","comment":" A UUID for the DNS namespace, \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\".\n\n    UUID.dns |> v3ChildNamed \"elm-lang.org\" |> UUID.canonical\n    --> \"bb125218-fead-3b3f-bcc5-05fbbe879f4d\"\n\n","type":"UUID.UUID"},{"name":"fromString","comment":" You can attempt to create a UUID from a string. This function can interpret\na fairly broad range of formatted (and mis-formatted) UUIDs, including ones with\ntoo much whitespace, too many (or not enough) hyphens, or uppercase characters.\n\n    fromString \"c72c207b-0847-386d-bdbc-2e5def81cf811\"\n    --> Err \"UUID was not correct length\"\n\n    fromString \"c72c207b-0847-386d-bdbc-2e5def81cg81\"\n    --> Err \"UUID contained non-hexadecimal digits\"\n\n    fromString \"00000000-0000-0000-0000-000000000000\"\n    --> Ok nil\n\n    fromString \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n    --> Ok nil\n\n    fromString \"{00000000-0000-0000-0000-000000000000}\"\n    --> Ok nil\n\n    fromString \"\\n\\n     {urn:uuid: 00  000000-0000-0000-0-000-000000000000}\"\n    --> Ok nil\n\n**Note:** if you are decoding from JSON, you may like [json-extra's fromResult function][fromResult].\n\n[fromResult]: https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra#fromResult\n\n    uuidDecoder =\n        Json.Decode.string\n            |> Json.Decode.andThen (Json.Decode.Extra.fromResult << UUID.fromString)\n\n","type":"String.String -> Result.Result String.String UUID.UUID"},{"name":"generator","comment":" Generating a random UUID is, I think, the most straightforward way of making a UUID, and I see them used all the time. There are a couple of ways of using a generator to create a value, which are described nicely in the [elm/random docs][elm-random]. Here is an example of how you might use the UUID generator:\n\n[elm-random]: https://package.elm-lang.org/packages/elm/random/latest/\n\n    import Random\n\n    type Comment\n        = Comment String UUID\n\n    makeComment : String -> Random.Seed -> ( Comment, Random.Seed )\n    makeComment comment seed =\n        UUID.generator\n            |> Random.map (Comment comment)\n            |> Random.step seed\n\n","type":"Random.Generator UUID.UUID"},{"name":"isNil","comment":" `True` if the given UUID is \"00000000-0000-0000-0000-000000000000\".\n","type":"UUID.UUID -> Basics.Bool"},{"name":"isValid","comment":" `True` if the given UUID correctly defines a version and variant. Note: the\nnil UUID is not valid!\n\n    isValid nil == False\n\n    Result.map UUID.isValid (UUID.fromString \"c72c207b-0847-386d-bdbc-2e5def81cf81\") == True\n\n    Result.map UUID.isValid (UUID.fromString \"c72c207b-0847-986d-bdbc-2e5def81cf81\") == False\n\n","type":"UUID.UUID -> Basics.Bool"},{"name":"isVariant","comment":" `True` if the given UUID is the given variant number. Always `False` is the\ninteger provided is not 1 or 2!\n\n    isVariant 4 someUUID -- Always False, variant 4 doesn't exist!\n\n    someJsonValue\n        |> Json.Decode.decodeValue UUID.decoder\n        |> UUID.isVariant 1\n\n    isVariant 2 (someUUID |> toVariant2) -- True\n\n","type":"Basics.Int -> UUID.UUID -> Basics.Bool"},{"name":"isVersion","comment":" `True` if the given UUID is the given version number. Always `False` is the\ninteger provided is not 1, 2, 3, 4 or 5!\n\n    isVersion 8 someUUID -- always False!\n\n    isVersion 4 nil -- False!\n\n    someJsonValue\n        |> Json.Decode.decodeValue UUID.decoder\n        |> UUID.isVersion 5\n\n    isVersion 3 (nil |> v3ChildNamed \"hello\") -- True\n\n","type":"Basics.Int -> UUID.UUID -> Basics.Bool"},{"name":"microsoftGUID","comment":" Convert UUID to [Microsoft GUID representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    microsoftGUID nil\n    --> \"{00000000-0000-0000-0000-000000000000}\"\n\n","type":"UUID.UUID -> String.String"},{"name":"nil","comment":" One type of UUID not defined above is the nil UUID. This is a [\"special form\nof UUID\"][nil-rfc] defined as \"00000000-0000-0000-0000-000000000000\". I suppose\nit can be used as a placeholder for something that doesn't have a UUID yet?\n\n[nil-rfc]: https://tools.ietf.org/html/rfc4122#section-4.1.7\n\n","type":"UUID.UUID"},{"name":"oid","comment":" A UUID for the [ISO object ID (OID)][oid] namespace,\n\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\". I am not going to try to explain what an\nOID is, if you need to use this, you probably have a better grasp of them than I\ndo!\n\n[oid]: https://en.wikipedia.org/wiki/Object_identifier\n\n    UUID.oid |> v3ChildNamed \"1.2.250.1\" |> UUID.canonical\n    --> \"2eab101c-060d-3424-aad5-8805218a67bc\"\n\n","type":"UUID.UUID"},{"name":"toString","comment":" This is just an alias for `canonical`, the most common way to represent a UUID.\n\n    import Random\n\n    someUUID : UUID\n    someUUID = Random.step generator (Random.initialSeed 345465) |> Tuple.first\n\n    toString someUUID\n    --> canonical someUUID\n\n","type":"UUID.UUID -> String.String"},{"name":"toVariant2","comment":" Variant 2 UUIDs are very similar to variant 1 UUIDs, the main _end-user_\ndifference being that they provide 1 fewer bit of randomness, but are a\nMicrosoft standard. Note the single digit change in the following example:\n\n    var1UUID : UUID\n    var1UUID =\n        fromString \"12345678-1234-4321-bcde-123456789abc\"\n          |> Result.withDefault nil\n\n    canonical var1UUID\n    --> \"12345678-1234-4321-bcde-123456789abc\"\n\n    canonical (toVariant2 var1UUID)\n    -->\"12345678-1234-4321-dcde-123456789abc\"\n\n","type":"UUID.UUID -> UUID.UUID"},{"name":"url","comment":" A UUID for the URL namespace, \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"\n\n    UUID.url |> v3ChildNamed \"https://package.elm-lang.org\" |> UUID.canonical\n    --> \"2035dad9-ee50-3732-a2a5-d76a84f42a8a\"\n\n","type":"UUID.UUID"},{"name":"urn","comment":" Convert UUID to [URN-namespaced representation](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)\n\n    urn nil\n    --> \"urn:uuid:00000000-0000-0000-0000-000000000000\"\n\n","type":"UUID.UUID -> String.String"},{"name":"v3ChildNamed","comment":" Start with an existing UUID as a \"parent\" UUID, and provide a name to create\na new UUID. **Note: unless you have good reason to use version 3 UUIDs, it is\n[recommended] you create version 5 UUIDs with [`childNamed`](#childNamed).**\n\n[recommended]: https://tools.ietf.org/html/rfc4122#section-4.3\n\n    grandparent : UUID\n    grandparent = nil\n\n    parent : UUID\n    parent = grandparent |> v3ChildNamed \"parent\"\n\n    parentsSibling : UUID\n    parentsSibling = grandparent |> v3ChildNamed \"parent's sibling\"\n\n    child1 : UUID\n    child1 = parent |> v3ChildNamed \"child1\"\n\n    child2 : UUID\n    child2 = parent |> v3ChildNamed \"child2\"\n\n    cousin : UUID\n    cousin = parentsSibling |> v3ChildNamed \"cousin\"\n\n    canonical child2\n    --> \"4cacaf93-fcc5-3a02-bc41-c0a3e359e11d\"\n\n","type":"String.String -> UUID.UUID -> UUID.UUID"},{"name":"v5ChildNamed","comment":" Alias for [`childNamed`](#childNamed), for parity with\n[`v3ChildNamed`](#v3ChildNamed), and just in case you need to make extra-clear\nwhich version UUID you are using!\n","type":"String.String -> UUID.UUID -> UUID.UUID"},{"name":"variant","comment":" If the bits of the UUID indicate that it is a variant 1 or 2 UUID, returns\n`Just 1` or `Just 2`, respectively. Otherwise, `Nothing`!\n\n    variant nil == Nothing\n\n    variant (nil |> v3ChildNamed \"Hello\") == Just 1\n\n","type":"UUID.UUID -> Maybe.Maybe Basics.Int"},{"name":"version","comment":" If the bits of the UUID indicate that it is properly versioned UUID e.g. version 1,\nreturns e.g. `Just 1`. Otherwise, `Nothing`!\n\n    version nil == Nothing\n\n    version (nil |> v3ChildNamed \"Hello\") == Just 3\n\n","type":"UUID.UUID -> Maybe.Maybe Basics.Int"},{"name":"x500","comment":" A UUID for the [X.500 Distinguished Name (DN)][x500] namespace,\n\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\". I am not going to try to explain what a\nX.500 DN is, if you need to use this, you probably have a better grasp of them\nthan I do!\n\n[x500]: https://en.wikipedia.org/wiki/X.500\n\n","type":"UUID.UUID"}],"binops":[]}]