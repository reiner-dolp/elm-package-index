[{"name":"AssocSet","comment":" Implimentation of elm/core Set based on pzp1997/assoc-list\n\nA set of unique values. The values can be any type that can be compared using (==).\nInsert, remove, and query operation performance subject to\nperformance characteristics of the underlying assoc-list implementations.\n\n\n# Sets\n\n@docs Set\n\n\n# Build\n\n@docs empty, singleton, insert, remove\n\n\n# Query\n\n@docs isEmpty, member, size\n\n\n# Combine\n\n@docs union, intersect, diff\n\n\n# Lists\n\n@docs toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n","unions":[{"name":"Set","comment":" Represents a set of unique values. So `(Set Id)` is a set of custom Id types and\n`(Set String)` works as usual.\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n","type":"AssocSet.Set a -> AssocSet.Set a -> AssocSet.Set a"},{"name":"empty","comment":" Create an empty set.\n","type":"AssocSet.Set a"},{"name":"filter","comment":" Only keep elements that pass the given test.\nimport Set exposing (Set)\nnumbers : Set Int\nnumbers =\nSet.fromList [-2,-1,0,1,2]\npositives : Set Int\npositives =\nSet.filter (\\\\x -> x > 0) numbers\n-- positives == Set.fromList [1,2]\n","type":"(a -> Basics.Bool) -> AssocSet.Set a -> AssocSet.Set a"},{"name":"foldl","comment":" Fold over the values in a set, in order from lowest to highest.\n","type":"(a -> b -> b) -> b -> AssocSet.Set a -> b"},{"name":"foldr","comment":" Fold over the values in a set, in order from highest to lowest.\n","type":"(a -> b -> b) -> b -> AssocSet.Set a -> b"},{"name":"fromList","comment":" Convert a list into a set, removing any duplicates.\n","type":"List.List a -> AssocSet.Set a"},{"name":"insert","comment":" Insert a value into a set.\n","type":"a -> AssocSet.Set a -> AssocSet.Set a"},{"name":"intersect","comment":" Get the intersection of two sets. Keeps values that appear in both sets.\n","type":"AssocSet.Set a -> AssocSet.Set a -> AssocSet.Set a"},{"name":"isEmpty","comment":" Determine if a set is empty.\n","type":"AssocSet.Set a -> Basics.Bool"},{"name":"map","comment":" Map a function onto a set, creating a new set with no duplicates.\n","type":"(a -> b) -> AssocSet.Set a -> AssocSet.Set b"},{"name":"member","comment":" Determine if a value is in a set.\n","type":"a -> AssocSet.Set a -> Basics.Bool"},{"name":"partition","comment":" Create two new sets. The first contains all the elements that passed the\ngiven test, and the second contains all the elements that did not.\n","type":"(a -> Basics.Bool) -> AssocSet.Set a -> ( AssocSet.Set a, AssocSet.Set a )"},{"name":"remove","comment":" Remove a value from a set. If the value is not found, no changes are made.\n","type":"a -> AssocSet.Set a -> AssocSet.Set a"},{"name":"singleton","comment":" Create a set with one value.\n","type":"a -> AssocSet.Set a"},{"name":"size","comment":" Determine the number of elements in a set.\n","type":"AssocSet.Set a -> Basics.Int"},{"name":"toList","comment":" Convert a set into a list, sorted from lowest to highest.\n","type":"AssocSet.Set a -> List.List a"},{"name":"union","comment":" Get the union of two sets. Keep all values.\n","type":"AssocSet.Set a -> AssocSet.Set a -> AssocSet.Set a"}],"binops":[]}]