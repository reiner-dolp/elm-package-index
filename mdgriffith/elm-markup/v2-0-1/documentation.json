[{"name":"Mark","comment":" `elm-markup` is about defining what you're expecting in a markup document.\n\nThe `elm-markup` language relies heavily on indentation, which always some multiple of 4 spaces.\n\n@docs parse\n\n\n# Blocks\n\n@docs Document, document\n\n@docs Block, block, bool, int, float, string, multiline, exactly, stub, map, andThen\n\n\n# Text\n\n@docs text, Text, Style\n\n@docs Inline, inline, inlineString, inlineText\n\n@docs Replacement, replacement, balanced\n\n\n# Blocks\n\n@docs oneOf, manyOf, startWith\n\n@docs nested, Nested\n\n\n# Records\n\nEmbed a data record.\n\nHere's an implementation to render an `<img>`\n\n    Mark.record2 \"Image\"\n        (\\src description ->\n            Html.img [ Html.Attribute.src src, Html.Attribute.alt description ] []\n        )\n        (Mark.field \"src\" Mark.string)\n        (Mark.field \"description\" Mark.string)\n\nWhich would parse\n\n    | Image\n        src = http://placekitten/200/500\n        description = A super cute kitten.\n\n**Note** The order of the fields in the document does not matter, so this will parse correctly as well:\n\n    | Image\n        description = A super cute kitten.\n        src = http://placekitten/200/500\n\n@docs Field, field, record2, record3, record4, record5, record6, record7, record8, record9, record10\n\n\n# Errors\n\n@docs Context, Problem\n\n\n# Advanced\n\n@docs advanced\n\n","unions":[{"name":"Block","comment":" A `Block data` is just a parser that results in `data`.\n\nYou'll be building up your `Document` in terms of the `Blocks`.\n\n","args":["data"],"cases":[]},{"name":"Context","comment":" ","args":[],"cases":[["InBlock",["String.String"]],["InInline",["String.String"]],["InRecordField",["String.String"]]]},{"name":"Document","comment":" ","args":["result"],"cases":[]},{"name":"Field","comment":" ","args":["value"],"cases":[]},{"name":"Inline","comment":" ","args":["result"],"cases":[]},{"name":"Nested","comment":" ","args":["item"],"cases":[["Nested",["{ content : item, children : List.List (Mark.Nested item) }"]]]},{"name":"Problem","comment":" ","args":[],"cases":[["ExpectingIndent",["Basics.Int"]],["InlineStart",[]],["InlineEnd",[]],["BlockStart",[]],["Expecting",["String.String"]],["ExpectingBlockName",["String.String"]],["ExpectingInlineName",["String.String"]],["ExpectingFieldName",["String.String"]],["NonMatchingFields",["{ expecting : List.List String.String, found : List.List String.String }"]],["MissingField",["String.String"]],["RecordError",[]],["Escape",[]],["EscapedChar",[]],["Newline",[]],["Space",[]],["End",[]],["Integer",[]],["FloatingPoint",[]],["InvalidNumber",[]],["UnexpectedEnd",[]],["CantStartTextWithSpace",[]],["UnclosedStyles",["List.List Mark.Style"]],["UnexpectedField",["{ found : String.String, options : List.List String.String, recordName : String.String }"]]]},{"name":"Replacement","comment":" ","args":[],"cases":[]},{"name":"Style","comment":" ","args":[],"cases":[["Bold",[]],["Italic",[]],["Strike",[]]]},{"name":"Text","comment":" A text fragment with some styling.\n","args":[],"cases":[["Text",["List.List Mark.Style","String.String"]]]}],"aliases":[],"values":[{"name":"advanced","comment":" Define your own parser using [\\`elm/parser'](https://package.elm-lang.org/packages/elm/parser/latest/).\n\nThis would be the place to start if you wanted to create a parser for syntax highlighting for an Elm block.\n\n**Warning** This is the only place where you can break the rules/conventions of `elm-markup`.\n\n**Note** You can get the current expected indentation using [`Parser.Advanced.getIndent`](https://package.elm-lang.org/packages/elm/parser/latest/Parser-Advanced#getIndent).\n\n","type":"Parser.Advanced.Parser Mark.Context Mark.Problem result -> Mark.Block result"},{"name":"andThen","comment":" Expect a different block based on the result of a previous one.\n","type":"(a -> Mark.Block b) -> Mark.Block a -> Mark.Block b"},{"name":"balanced","comment":" A balanced replacement. This is used in `Mark.Default` to do auto-curly quotes.\n\n    Mark.balanced\n        { start = ( \"\\\"\", \"“\" )\n        , end = ( \"\\\"\", \"”\" )\n        }\n\n","type":"{ start : ( String.String, String.String ), end : ( String.String, String.String ) } -> Mark.Replacement"},{"name":"block","comment":" A named block.\n\n    Mark.block \"MyBlock\"\n        Html.text\n        Mark.string\n\nWill parse the following and render it as `Html.text`\n\n    | MyBlock\n        Here is an unformatted string!\n\n**Note** block names should be capitalized. In the future this may be enforced.\n\n","type":"String.String -> (child -> result) -> Mark.Block child -> Mark.Block result"},{"name":"bool","comment":" Parse either `True` or `False`.\n","type":"Mark.Block Basics.Bool"},{"name":"document","comment":" Create a markup `Document`. You're first goal is to describe a document in terms of the blocks you're expecting.\n\nHere's a brief example of a document that will parse many `MyBlock` blocks, and capture the string that's indented inside the block.\n\n    document : Mark.Document (List String)\n    document =\n        Mark.document\n            identity\n            (Mark.manyOf\n                [ Mark.block \"MyBlock\"\n                    identity\n                    Mark.string\n                , Mark.string\n                ]\n            )\n\n    parse : String -> Result (DeadEnd Context Problem) (List String)\n    parse source =\n        Mark.parse document source\n\nWhich will parse a document with many of either raw strings or`MyBlock` blocks. The `identity` function usage above means that this will result in a `List String`, but you could change that function to make this parser result in anything you want!\n\n    | MyBlock\n        Here's text captured in a MyBlock\n\n    This text is captured at the top level.\n\n    | MyBlock\n        Here's some more text in a MyBlock.\n\n","type":"(child -> result) -> Mark.Block child -> Mark.Document result"},{"name":"exactly","comment":" Parse an exact string. This can be useful to parse custom types if you pair it with `Mark.oneOf`.\n\n    type Plant = IsWatered | IsDying\n\n\n    Mark.oneOf\n        [ Mark.exactly \"IsWatered\" IsWatered\n        , Mark.exactly \"IsDying\" IsDying\n        ]\n\n","type":"String.String -> value -> Mark.Block value"},{"name":"field","comment":" ","type":"String.String -> Mark.Block value -> Mark.Field value"},{"name":"float","comment":" ","type":"Mark.Block Basics.Float"},{"name":"inline","comment":" Create a custom inline element.\n\nFor example, here is how you could parse a link:\n\n    Mark.inline \"Link\"\n        (\\txt url ->\n            Html.a [ Html.Attriutes.href url ] (List.map renderText txt)\n        )\n        |> Mark.inlineText\n        |> Mark.inlineString \"url\"\n\nHere's an example of a sentence with the above link:\n\n`Here is my sentence {link| with a link to a web-comic. |url=http://www.poorlydrawnlines.com/comic/website-bird/}  You're welcome.`\n\n","type":"String.String -> result -> Mark.Inline result"},{"name":"inlineString","comment":" Parse an inline String field\n","type":"String.String -> Mark.Inline (String.String -> result) -> Mark.Inline result"},{"name":"inlineText","comment":" ","type":"Mark.Inline (List.List Mark.Text -> result) -> Mark.Inline result"},{"name":"int","comment":" ","type":"Mark.Block Basics.Int"},{"name":"manyOf","comment":" Many blocks that are all at the same indentation level.\n","type":"List.List (Mark.Block a) -> Mark.Block (List.List a)"},{"name":"map","comment":" Change the result of a block by applying a function to it.\n","type":"(a -> b) -> Mark.Block a -> Mark.Block b"},{"name":"multiline","comment":" Parse multiple lines at the current indentation level.\n\nFor example:\n\n    Mark.block \"Poem\"\n        (\\str -> str)\n        Mark.multiline\n\nWill parse the following:\n\n    | Poem\n        Whose woods these are I think I know.\n        His house is in the village though;\n        He will not see me stopping here\n        To watch his woods fill up with snow.\n\nWhere `str` in the above function will be\n\n    \"\"\"Whose woods these are I think I know.\n    His house is in the village though;\n    He will not see me stopping here\n    To watch his woods fill up with snow.\"\"\"\n\n","type":"Mark.Block String.String"},{"name":"nested","comment":" It can be useful to parse a tree structure. For example, here's a nested list.\n\n    | List\n        - item one\n        - item two\n            - nested item two\n            additional text for nested item two\n        - item three\n            - nested item three\n\nIn order to parse the above, you could define a block as\n\n    Mark.block \"List\"\n        (\\(Nested nested) ->\n            -- Do something with nested.content and nested.children\n        )\n        (Mark.nested\n            { item = text\n            , start = Mark.exactly \"-\" ()\n            }\n        )\n\n**Note** the indentation is always a multiple of 4.\n**Another Note** `text` in the above code is defined elsewhere.\n\n","type":"{ item : Mark.Block item, start : Mark.Block icon } -> Mark.Block (List.List (Mark.Nested ( icon, List.List item )))"},{"name":"oneOf","comment":" ","type":"List.List (Mark.Block a) -> Mark.Block a"},{"name":"parse","comment":" ","type":"Mark.Document result -> String.String -> Result.Result (List.List (Parser.Advanced.DeadEnd Mark.Context Mark.Problem)) result"},{"name":"record10","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> six -> seven -> eight -> nine -> ten -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Field six -> Mark.Field seven -> Mark.Field eight -> Mark.Field nine -> Mark.Field ten -> Mark.Block data"},{"name":"record2","comment":" A record with two fields.\n\n**Note** there's no `record1`, because that's basically just a `block`.\n\n","type":"String.String -> (one -> two -> data) -> Mark.Field one -> Mark.Field two -> Mark.Block data"},{"name":"record3","comment":" ","type":"String.String -> (one -> two -> three -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Block data"},{"name":"record4","comment":" ","type":"String.String -> (one -> two -> three -> four -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Block data"},{"name":"record5","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Block data"},{"name":"record6","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> six -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Field six -> Mark.Block data"},{"name":"record7","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> six -> seven -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Field six -> Mark.Field seven -> Mark.Block data"},{"name":"record8","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> six -> seven -> eight -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Field six -> Mark.Field seven -> Mark.Field eight -> Mark.Block data"},{"name":"record9","comment":" ","type":"String.String -> (one -> two -> three -> four -> five -> six -> seven -> eight -> nine -> data) -> Mark.Field one -> Mark.Field two -> Mark.Field three -> Mark.Field four -> Mark.Field five -> Mark.Field six -> Mark.Field seven -> Mark.Field eight -> Mark.Field nine -> Mark.Block data"},{"name":"replacement","comment":" Replace a string with another string. This can be useful to have shortcuts to unicode characters.\n\nFor example, in `Mark.Default`, this is used to replace `...` with the unicode ellipses character: `…`.\n\n","type":"String.String -> String.String -> Mark.Replacement"},{"name":"startWith","comment":" Parse two blocks in sequence.\n\nThis can be useful to do things like require that a specific block comes first.\n\nSo, the classic case of a blog post that has some meta data at the start could be done like this\n\n    Mark.startWith\n        (\\metadata article ->\n            { meta = metadata\n            , article = article\n            }\n        )\n        (Mark.record3 \"Article\"\n            (\\author title published ->\n                { author = author\n                , title = title\n                , published = published\n                }\n            )\n            (Mark.field \"author\" Mark.string)\n            (Mark.field \"title\" Mark.string)\n            (Mark.field \"published\" Mark.bool)\n        )\n        (Mark.manyOf [ Mark.text ])\n\nWhich would parse the following doc:\n\n    | Article\n        author = Mortimer, the Stylish Elephant\n        published = False\n        title = How to use CSS to rearrange your living room.\n\n    First off, thank you for using my library.\n\n    Secondly, who knew that flex-box could wrap a sofa?\n\n","type":"(start -> rest -> result) -> Mark.Block start -> Mark.Block rest -> Mark.Block result"},{"name":"string","comment":" Parse a single line and return it as a string.\n","type":"Mark.Block String.String"},{"name":"stub","comment":" An empty block. This could be useful for inserting something that doesn't need parameters.\n\n    | Logo\n\n","type":"String.String -> result -> Mark.Block result"},{"name":"text","comment":" Handling formatted text is a little more involved than may be initially apparent.\n\nText styling can be overlapped such as\n\n    /My italicized sentence can have *bold*/\n\nIn order to render this, the above sentence is chopped up into `Text` fragments that can have multiple styles active.\n\n  - `view` is the function to render an individual fragment.\n  - `inlines` are custom inline blocks. These are how links are implemented in `Mark.Default`!\n  - `replacements` will replace characters before rendering. For example, we can replace `...` with the real ellipses unicode character, `…`.\n\n**Note** check out `Mark.Default.text` to see an example.\n\n","type":"{ view : Mark.Text -> rendered, inlines : List.List (Mark.Inline rendered), replacements : List.List Mark.Replacement } -> Mark.Block (List.List rendered)"}],"binops":[]},{"name":"Mark.Default","comment":" This is a document that renders to [`elm-ui`'s](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/) `Element msg`.\n\n**Though remember**, one of the great powers of this library is in [writing custom blocks](https://package.elm-lang.org/packages/mdgriffith/elm-markup/latest/Mark) to suit your specific domain or style needs! You can parse a document to any data structure.\n\nThink of this module as a **starting point** for writing something like a blog article.\n\nCheck out the source to get an idea of how things fit together.\n\n_Then feel free to borrow or copy anything you see._\n\n@docs document\n\n\n# Common Blocks\n\nThese are some common blocks that you might need.\n\nFeel free to define your own document and pick and choose what blocks make sense for you.\n\n@docs title, header, monospace, image, ListIcon, list, listIcon\n\n\n# Text and Inlines\n\n@docs textWith, defaultTextStyle, code, link, textFragment\n\n","unions":[{"name":"ListIcon","comment":" List icon options.\n\nFor `Number`, we have\n\n  - `reset`, which is the desired index reset if there is one.\n  - `decorations`, which are the strings to append after each number.\n\nSo, a list item like:\n\n`#.5)`\n\nWould result in the following `ListIcon`:\n\n    Number\n        { reset = [ Nothing, Just 5 ]\n        , decorations = [ \".\", \")\" ]\n        }\n\n","args":[],"cases":[["Bullet",[]],["Arrow",[]],["Number",["{ reset : List.List (Maybe.Maybe Basics.Int), decorations : List.List String.String }"]]]}],"aliases":[],"values":[{"name":"code","comment":" A custom inline block for code. This is analagous to `backticks` in markdown.\n\nThough, style it however you'd like.\n\n`{Code| Here is my styled inline code block }`\n\n","type":"List.List (Element.Attribute msg) -> Mark.Inline (model -> Element.Element msg)"},{"name":"defaultTextStyle","comment":" Some default styling for `code` and `link` inline blocks.\n\nAlso replaces certain characters with some typographical niceties.\n\n  - `...` is converted to the ellipses unicode character.\n  - `\"` Straight double quotes are [replaced with curly quotes](https://practicaltypography.com/straight-and-curly-quotes.html)\n  - `'` Single Quotes are replaced with apostrophes. In the future we might differentiate between curly single quotes and apostrophes.\n  - `--` is replaced with an en-dash.\n  - `---` is replaced with an em-dash.\n  - `<>` - will create a non-breaking space (`&nbsp;`). This is not for manually increasing space (sequential `<>` tokens will only render as one `&nbsp;`), but to signify that the space between two words shouldn't break when wrapping. Think of this like glueing two words together.\n  - `//` will change to `/`. Normally `/` starts italic formatting. To escape this, we'd normally do `\\/`, though that looks pretty funky. `//` just feels better!\n\nThese transformations also don't apply inside inline `code` or inside the `monospace` block.\n\n**Note** Escaping the start of any of these characters will skip the replacement.\n\n**Also Note** If you're not familiar with `en-dash` or `em-dash`, I definitely [recommend reading a small bit about it](https://practicaltypography.com/hyphens-and-dashes.html)—they're incredibly useful.\n\n","type":"{ code : List.List (Element.Attribute msg1), link : List.List (Element.Attribute msg), inlines : List.List (Mark.Inline (a -> Element.Element msg)), replacements : List.List Mark.Replacement }"},{"name":"document","comment":" This document results in a `view` function, `model -> Element msg`.\n\nIt includes all the blocks and inline blocks referenced in this module.\n\n**Note** this document requires a `title` as the first block of each document by using `Mark.startWith`. If that isn't what you want, create your own document with your own constraints.\n\n","type":"Mark.Document (model -> Element.Element msg)"},{"name":"header","comment":" A header.\n\n    | Header\n        My header\n\nRenders as an `h2`.\n\n","type":"List.List (Element.Attribute msg) -> Mark.Block (model -> List.List (Element.Element msg)) -> Mark.Block (model -> Element.Element msg)"},{"name":"image","comment":" Create an image.\n\n    | Image\n        src = https://placekitten.com/200/300\n        description = A cute kitty cat.\n\n","type":"List.List (Element.Attribute msg) -> Mark.Block (model -> Element.Element msg)"},{"name":"link","comment":" A custom inline block for links.\n\n`{Link|My link text|url=http://google.com}`\n\n","type":"List.List (Element.Attribute msg) -> Mark.Inline (model -> Element.Element msg)"},{"name":"list","comment":" A nested list with an expected indentation of 4 spaces per level. As far as icons:\n\n  - `-` or `--` indicates a bullet.\n  - `->` or `-->` will render as an ➙\n  - `#.` will be auto-numbered as and rendered `1.`, or `2.` or whatever number you're at.\n      - Any punctuation that comes after the alpha character will be maintained. So, `#)` will format as `1)` and `#.` will format as `1.`\n      - Nested numbers can be rendered if they're in the right place. So `#.#)` would render as `1.2)`\n  - A literal number instead of an alpha will reset the auto numbering to that literal number. So, `9.` means start counting up from 9 from here on out.\n  - This can also applied in a nested manner as `#.9`, which will reset the inner number.\n\nFor configuring this block.\n\n  - `icon` takes in a `List Int`, which is the current index of where that element is in the nested list. So, `[1,2]` means you're at postion `1.2`.\n  - `style` is\n\n","type":"{ icon : List.List Basics.Int -> Mark.Default.ListIcon -> Element.Element msg, style : List.List Basics.Int -> List.List (Element.Attribute msg) } -> Mark.Block (model -> List.List (Element.Element msg)) -> Mark.Block (model -> Element.Element msg)"},{"name":"listIcon","comment":" A default list icon renderer.\n","type":"List.List Basics.Int -> Mark.Default.ListIcon -> Element.Element msg"},{"name":"monospace","comment":" A monospaced code block without syntax highlighting.\n\n    | Monospace\n        Everything in this block will be rendered monospaced.\n\n        Including this line.\n\n        And this one.\n\n","type":"List.List (Element.Attribute msg) -> Mark.Block (model -> Element.Element msg)"},{"name":"textFragment","comment":" Render a text fragment.\n","type":"Mark.Text -> model -> Element.Element msg"},{"name":"textWith","comment":" Render text into `Element msg`.\n\nIncludes `Mark.Default.link` and `Mark.Default.code` inline blocks, which can be styled as you'd like.\n\n**Note** this is not a complicated function. If it doesn't meet your needs, don't be afraid to write your own using `Mark.text`!\n\n","type":"{ code : List.List (Element.Attribute msg), link : List.List (Element.Attribute msg), inlines : List.List (Mark.Inline (model -> Element.Element msg)), replacements : List.List Mark.Replacement } -> Mark.Block (model -> List.List (Element.Element msg))"},{"name":"title","comment":" The title of your document. Renders as an `h1`.\n\n    | Title\n        The title of my document.\n\n","type":"List.List (Element.Attribute msg) -> Mark.Block (model -> List.List (Element.Element msg)) -> Mark.Block (model -> Element.Element msg)"}],"binops":[]}]