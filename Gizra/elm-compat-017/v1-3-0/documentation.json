[
  {
    "name": "Time019",
    "comment": " Elm 0.19 moved the `Date` module to a separate package\n[elm-time](https://package.elm-lang.org/packages/elm/time/1.0.0/)\nand renamed it `Time`. So, this is an implementation for Elm 0.17.\n\n\n# Time\n\n@docs Posix, now, every, posixToMillis, millisToPosix\n\n\n# Time Zones\n\n@docs Zone, utc, here\n\n\n# Human Times\n\n@docs toYear, toMonth, toDay, toWeekday, toHour, toMinute, toSecond, toMillis\n\n\n# Weeks and Months\n\n@docs Weekday, Month\n\n\n# For Package Authors\n\n@docs customZone, getZoneName, ZoneName\n\n",
    "aliases": [
      {
        "name": "Month",
        "comment": " Represents a `Month` so that you can convert it to a `String` or `Int`\nhowever you please. For example, if you need the Danish representation, you\ncan say:\n\n    toDanishMonth : Month -> String\n    toDanishMonth month =\n        case month of\n            Jan ->\n                \"januar\"\n\n            Feb ->\n                \"februar\"\n\n            Mar ->\n                \"marts\"\n\n            Apr ->\n                \"april\"\n\n            May ->\n                \"maj\"\n\n            Jun ->\n                \"juni\"\n\n            Jul ->\n                \"juli\"\n\n            Aug ->\n                \"august\"\n\n            Sep ->\n                \"september\"\n\n            Oct ->\n                \"oktober\"\n\n            Nov ->\n                \"november\"\n\n            Dec ->\n                \"december\"\n\n",
        "args": [],
        "type": "Date.Month"
      },
      {
        "name": "Weekday",
        "comment": " Represents a `Weekday` so that you can convert it to a `String` or `Int`\nhowever you please. For example, if you need the Japanese representation, you\ncan say:\n\n    toJapaneseWeekday : Weekday -> String\n    toJapaneseWeekday weekday =\n        case weekday of\n            Mon ->\n                \"月\"\n\n            Tue ->\n                \"火\"\n\n            Wed ->\n                \"水\"\n\n            Thu ->\n                \"木\"\n\n            Fri ->\n                \"金\"\n\n            Sat ->\n                \"土\"\n\n            Sun ->\n                \"日\"\n\n",
        "args": [],
        "type": "Date.Day"
      }
    ],
    "types": [
      {
        "name": "Posix",
        "comment": " A computer representation of time. It is the same all over Earth, so if we\nhave a phone call or meeting at a certain POSIX time, there is no ambiguity.\nIt is very hard for humans to _read_ a POSIX time though, so we use functions\nlike [`toHour`](#toHour) and [`toMinute`](#toMinute) to `view` them.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Zone",
        "comment": " Information about a particular time zone.\n\nThe [IANA Time Zone Database][iana] tracks things like UTC offsets and\ndaylight-saving rules so that you can turn a `Posix` time into local times\nwithin a time zone.\n\nSee [`utc`](#utc), [`here`](#here), and [`Browser.Env`][env] to learn how to\nobtain `Zone` values.\n\n[iana]: https://www.iana.org/time-zones\n[env]: /packages/elm/browser/latest/Browser#Env\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "ZoneName",
        "comment": " **Intended for package authors.**\n\nThe `getZoneName` function relies on a JavaScript API that is not supported\nin all browsers yet, so it can return the following:\n\n    -- in more recent browsers\n    Name \"Europe/Moscow\"\n    Name \"America/Havana\"\n\n    -- in older browsers\n    Offset 180\n    Offset -300\n\nSo if the real info is not available, it will tell you the current UTC offset\nin minutes, just like what `here` uses to make zones like `customZone -60 []`.\n\n",
        "args": [],
        "cases": [
          [
            "Name",
            [
              "String"
            ]
          ],
          [
            "Offset",
            [
              "Int"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "customZone",
        "comment": " **Intended for package authors.**\n\nThe documentation of [`here`](#here) explains that it has certain accuracy\nlimitations that block on adding new APIs to JavaScript. The `customZone`\nfunction is a stopgap that takes:\n\n1.  A default offset in minutes. So `Etc/GMT-5` is `customZone (-5 * 60) []`\n    and `Etc/GMT+9` is `customZone (9 * 60) []`.\n2.  A list of exceptions containing their `start` time in \"minutes since the Unix\n    epoch\" and their `offset` in \"minutes from UTC\"\n\nHuman times will be based on the nearest `start`, falling back on the default\noffset if the time is older than all of the exceptions.\n\nWhen paired with `getZoneName`, this allows you to load the real IANA time zone\ndatabase however you want: HTTP, cache, hardcode, etc.\n\n**Note:** If you use this, please share your work in an Elm community forum! I\nam sure others would like to hear about it, and more experience reports will\nhelp me and the any potential TC39 proposal.\n\n",
        "type": "Int -> List { start : Int, offset : Int } -> Time019.Zone"
      },
      {
        "name": "every",
        "comment": " Get the current time periodically. How often though? Well, you provide an\ninterval in milliseconds (like `1000` for a second or `60 * 1000` for a minute\nor `60 * 60 * 1000` for an hour) and that is how often you get a new time!\n\nCheck out [this example](https://elm-lang.org/examples/time) to see how to use\nit in an application.\n\n**This function is not for animation.** Use the [`elm/animation-frame`][af]\npackage for that sort of thing! It syncs up with repaints and will end up\nbeing much smoother for any moving visuals.\n\n[af]: /packages/elm/animation-frame/latest\n\n",
        "type": "Float -> (Time019.Posix -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "getZoneName",
        "comment": " **Intended for package authors.**\n\nUse `Intl.DateTimeFormat().resolvedOptions().timeZone` to try to get names\nlike `Europe/Moscow` or `America/Havana`. From there you can look it up in any\nIANA data you loaded yourself.\n\n",
        "type": "Task.Task x Time019.ZoneName"
      },
      {
        "name": "here",
        "comment": " Produce a `Zone` based on the current UTC offset.\n\nYou can use this to figure out what day it is where you are:\n\n    import Task exposing (Task)\n\n    whatDayIsIt : Task x Int\n    whatDayIsIt =\n        Task.map2 Time.toDay Time.here Time.now\n\n**Accuracy Note:** This function can only give time zones like `Etc/GMT+9` or\n`Etc/GMT-6`. It cannot give you `Europe/Stockholm`, `Asia/Tokyo`, or any other\nnormal time zone from the [full list][tz] due to limitations in JavaScript.\nFor example, if you run `here` in New York City, the resulting `Zone` will\nnever be `America/New_York`. Instead you get `Etc/GMT-5` or `Etc/GMT-4`\ndepending on Daylight Saving Time. So even though browsers must have internal\naccess to `America/New_York` to figure out that offset, there is no public API\nto get the full information. This means the `Zone` you get from this function\nwill act weird if (1) an application stays open across a Daylight Saving Time\nboundary or (2) you try to use it on historical data.\n\n**Future Note:** We can improve `here` when there is good browser support for\nJavaScript functions that (1) expose the IANA time zone database and (2) let\nyou ask the time zone of the computer. The committee that reviews additions to\nJavaScript is called TC39, and I encourage you to push for these capabilities! I\ncannot do it myself unfortunately.\n\n**Alternatives:** See the `customZone` docs to learn how to implement stopgaps.\n[tz]: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>\n\n",
        "type": "Task.Task x Time019.Zone"
      },
      {
        "name": "millisToPosix",
        "comment": " Turn milliseconds into a `Posix` time.\n",
        "type": "Int -> Time019.Posix"
      },
      {
        "name": "now",
        "comment": " Get the POSIX time at the moment when this task is run.\n",
        "type": "Task.Task x Time019.Posix"
      },
      {
        "name": "posixToMillis",
        "comment": " Turn a `Posix` time into the number of milliseconds since 1970 January 1\nat 00:00:00 UTC. It was a Thursday.\n",
        "type": "Time019.Posix -> Int"
      },
      {
        "name": "toDay",
        "comment": " What day is it?! (Days go from 1 to 31)\n\n    toDay utc (millisToPosix 0) --> 1\n\n    toDay nyc (millisToPosix 0) == 31\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "toHour",
        "comment": " What hour is it? (From 0 to 23)\n\n    toHour utc (millisToPosix 0) --> 0 -- 12am\n\n    toHour nyc (millisToPosix 0) == 19 -- 7pm\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "toMillis",
        "comment": "\n\n    toMillis utc (millisToPosix    0) --> 0\n\n    toMillis utc (millisToPosix 1234) --> 234\n\n    toMillis utc (millisToPosix 5678) --> 678\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "toMinute",
        "comment": " What minute is it? (From 0 to 59)\n\n    toMinute utc (millisToPosix 0) --> 0\n\nThis can be different in different time zones. Some time zones are offset\nby 30 or 45 minutes!\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "toMonth",
        "comment": " What month is it?!\n\n    import Date exposing (Month(..))\n\n    toMonth utc (millisToPosix 0) --> Jan\n\n    toMonth nyc (millisToPosix 0) == Dec\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Time019.Month"
      },
      {
        "name": "toSecond",
        "comment": " What second is it?\n\n    toSecond utc (millisToPosix 0) --> 0\n\n    toSecond utc (millisToPosix 1234) --> 1\n\n    toSecond utc (millisToPosix 5678) --> 5\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "toWeekday",
        "comment": " What day of the week is it?\n\n    toWeekday utc (millisToPosix 0) == Thu\n\n    toWeekday nyc (millisToPosix 0) == Wed\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Time019.Weekday"
      },
      {
        "name": "toYear",
        "comment": " What year is it?!\n\n    toYear utc (millisToPosix 0) --> 1970\n\n    toYear nyc (millisToPosix 0) == 1969\n    -- pretend `nyc` is the `Zone` for America/New_York.\n\n",
        "type": "Time019.Zone -> Time019.Posix -> Int"
      },
      {
        "name": "utc",
        "comment": " The time zone for Coordinated Universal Time ([UTC])\n\nThe `utc` zone has no time adjustments. It never observes daylight-saving\ntime and it never shifts around based on political restructuring.\n[UTC]: <https://en.wikipedia.org/wiki/Coordinated_Universal_Time>\n\n",
        "type": "Time019.Zone"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Http018",
    "comment": " The API for this module had significant changes in Elm 0.18. This\nrepresents a full implementation of the Elm 0.18 API.\n\n\n# Send Requests\n\n@docs Request, send, Error\n\n\n# GET\n\n@docs getString, get\n\n\n# POST\n\n@docs post\n\n\n# Custom Requests\n\n@docs request\n\n\n## Headers\n\n@docs Header, header\n\n\n## Request Bodies\n\n@docs Body, emptyBody, jsonBody, stringBody, multipartBody, Part, stringPart\n\n\n## Responses\n\n@docs Expect, expectString, expectJson, expectStringResponse, Response\n\n\n# Low-Level\n\n@docs toTask\n\n",
    "aliases": [
      {
        "name": "Part",
        "comment": " Contents of a multi-part body. Right now it only supports strings, but we\nwill support blobs and files when we get an API for them in Elm.\n",
        "args": [],
        "type": "Http.Data"
      },
      {
        "name": "Response",
        "comment": " The response from a `Request`.\n",
        "args": [
          "body"
        ],
        "type": "{ url : String , status : { code : Int, message : String } , headers : Dict.Dict String String , body : body }"
      }
    ],
    "types": [
      {
        "name": "Body",
        "comment": " Represents the body of a `Request`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Error",
        "comment": " A `Request` can fail in a couple ways:\n\n  - `BadUrl` means you did not provide a valid URL.\n  - `Timeout` means it took too long to get a response.\n  - `NetworkError` means the user turned off their wifi, went in a cave, etc.\n  - `BadStatus` means you got a response back, but the [status code][sc]\n    indicates failure.\n  - `BadPayload` means you got a response back with a nice status code, but\n    the body of the response was something unexpected. The `String` in this\n    case is a debugging message that explains what went wrong with your JSON\n    decoder or whatever.\n\n[sc]: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n\n> Note that `BadUrl` is not actually used at the moment, because it is\n> impractical to check the URL in Elm 0.17.\n\n",
        "args": [],
        "cases": [
          [
            "BadUrl",
            [
              "String"
            ]
          ],
          [
            "Timeout",
            []
          ],
          [
            "NetworkError",
            []
          ],
          [
            "BadStatus",
            [
              "Http018.Response String"
            ]
          ],
          [
            "BadPayload",
            [
              "String",
              "Http018.Response String"
            ]
          ]
        ]
      },
      {
        "name": "Expect",
        "comment": " Logic for interpreting a response body.\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "Header",
        "comment": " An HTTP header for configuring requests. See a bunch of common headers\n[here].\n\n[here]: https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\n\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Request",
        "comment": " Describes an HTTP request.\n",
        "args": [
          "a"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "emptyBody",
        "comment": " Create an empty body for your `Request`. This is useful for GET requests\nand POST requests where you are not sending any data.\n",
        "type": "Http018.Body"
      },
      {
        "name": "expectJson",
        "comment": " Expect the response body to be JSON. You provide a `Decoder` to turn that\nJSON into an Elm value. If the body cannot be parsed as JSON or if the JSON\ndoes not match the decoder, the request will resolve to a `BadPayload` error.\n",
        "type": "Json.Decode.Decoder a -> Http018.Expect a"
      },
      {
        "name": "expectString",
        "comment": " Expect the response body to be a `String`.\n",
        "type": "Http018.Expect String"
      },
      {
        "name": "expectStringResponse",
        "comment": " Maybe you want the whole `Response`: status code, headers, body, etc. This\nlets you get all of that information. From there you can use functions like\n`Json.Decode.decodeString` to interpret it as JSON or whatever else you want.\n",
        "type": "(Http018.Response String -> Result.Result String a) -> Http018.Expect a"
      },
      {
        "name": "get",
        "comment": " Create a `GET` request and try to decode the response body from JSON to\nsome Elm value.\n\n    import Http\n    import Json.Decode exposing (list, string)\n\n    getBooks : Http.Request (List String)\n    getBooks =\n        Http.get \"https://example.com/books\" (list string)\n\nYou can learn more about how JSON decoders work [here] in the guide.\n\n[here]: https://guide.elm-lang.org/interop/json.html\n\n",
        "type": "String -> Json.Decode.Decoder a -> Http018.Request a"
      },
      {
        "name": "getString",
        "comment": " Create a `GET` request and interpret the response body as a `String`.\n\n    import Http\n\n    getWarAndPeace : Http.Request String\n    getWarAndPeace =\n        Http.getString \"https://example.com/books/war-and-peace\"\n\n",
        "type": "String -> Http018.Request String"
      },
      {
        "name": "header",
        "comment": " Create a `Header`.\n\n    header \"If-Modified-Since\" \"Sat 29 Oct 1994 19:43:31 GMT\"\n\n    header \"Max-Forwards\" \"10\"\n\n    header \"X-Requested-With\" \"XMLHttpRequest\"\n\n**Note:** In the future, we may split this out into an `Http.Headers` module\nand provide helpers for cases that are common on the client-side. If this\nsounds nice to you, open an issue [here] describing the helper you want and\nwhy you need it.\n\n[here]: https://github.com/elm/http/issues\n\n",
        "type": "String -> String -> Http018.Header"
      },
      {
        "name": "jsonBody",
        "comment": " Put some JSON value in the body of your `Request`. This will automatically\nadd the `Content-Type: application/json` header.\n",
        "type": "Json.Encode.Value -> Http018.Body"
      },
      {
        "name": "multipartBody",
        "comment": " Create multi-part bodies for your `Request`, automatically adding the\n`Content-Type: multipart/form-data` header.\n",
        "type": "List Http018.Part -> Http018.Body"
      },
      {
        "name": "post",
        "comment": " Create a `POST` request and try to decode the response body from JSON to\nan Elm value. For example, if we want to send a POST without any data in the\nrequest body, it would be like this:\n\n    import Http\n    import Json.Decode exposing (list, string)\n\n    postBooks : Http.Request (List String)\n    postBooks =\n        Http.post \"https://example.com/books\" Http.emptyBody (list string)\n\nSee [`jsonBody`](#jsonBody) to learn how to have a more interesting request\nbody. And check out [this section][here] of the guide to learn more about\nJSON decoders.\n\n[here]: https://guide.elm-lang.org/interop/json.html\n\n",
        "type": "String -> Http018.Body -> Json.Decode.Decoder a -> Http018.Request a"
      },
      {
        "name": "request",
        "comment": " Create a custom request. For example, a custom PUT request would look like\nthis:\n\n    put : String -> Body -> Request ()\n    put url body =\n        request\n            { method = \"PUT\"\n            , headers = []\n            , url = url\n            , body = body\n            , expect = expectStringResponse (\\_ -> Ok ())\n            , timeout = Nothing\n            , withCredentials = False\n            }\n\nThe `timeout` is the number of milliseconds you are willing to wait before\ngiving up.\n\n",
        "type": "{ method : String , headers : List Http018.Header , url : String , body : Http018.Body , expect : Http018.Expect a , timeout : Maybe.Maybe Float , withCredentials : Bool } -> Http018.Request a"
      },
      {
        "name": "send",
        "comment": " Send a `Request`. We could get the text of “War and Peace” like this:\n\n    import Http\n\n    type Msg = Click | NewBook (Result Http.Error String)\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n      case msg of\n        Click ->\n          ( model, getWarAndPeace )\n\n        NewBook (Ok book) ->\n          ...\n\n        NewBook (Err _) ->\n          ...\n\n    getWarAndPeace : Cmd Msg\n    getWarAndPeace =\n      Http.send NewBook <|\n        Http.getString \"https://example.com/books/war-and-peace.md\"\n\n",
        "type": "(Result.Result Http018.Error a -> msg) -> Http018.Request a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "stringBody",
        "comment": " Put some string in the body of your `Request`. Defining `jsonBody` looks\nlike this:\n\n    import Json.Encode as Encode\n\n    jsonBody : Encode.Value -> Body\n    jsonBody value =\n        stringBody \"application/json\" (Encode.encode 0 value)\n\nNotice that the first argument is a [MIME type][mime] so we know to add\n`Content-Type: application/json` to our request headers. Make sure your\nMIME type matches your data. Some servers are strict about this!\n\n[mime]: https://en.wikipedia.org/wiki/Media_type\n\n",
        "type": "String -> String -> Http018.Body"
      },
      {
        "name": "stringPart",
        "comment": " A named chunk of string data.\n\n    body =\n        multipartBody\n            [ stringPart \"user\" \"tom\"\n            , stringPart \"payload\" \"42\"\n            ]\n\n",
        "type": "String -> String -> Http018.Part"
      },
      {
        "name": "toTask",
        "comment": " Convert a `Request` into a `Task`. This is only really useful if you want\nto chain together a bunch of requests (or any other tasks) in a single command.\n",
        "type": "Http018.Request a -> Task.Task Http018.Error a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Random018",
    "comment": " Like in other modules, the paramenters of `andThen` were flipped in Elm\n0.18.\n\n@docs andThen\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain random operations, threading through the seed. In the following\nexample, we will generate a random letter by putting together uppercase and\nlowercase letters.\n\n    letter : Generator Char\n    letter =\n      bool\n        |> andThen upperOrLower\n\n    upperOrLower : Bool -> Generator Char\n    upperOrLower b =\n      if b then uppercaseLetter else lowercaseLetter\n\n    -- bool : Generator Bool\n    -- uppercaseLetter : Generator Char\n    -- lowercaseLetter : Generator Char\n",
        "type": "(a -> Random.Generator b) -> Random.Generator a -> Random.Generator b"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Random019",
    "comment": " Elm 0.19 moved `Random` to a separate module and added several functions\nto the API. Those functions are provided here.\n\nElm 0.19 also improved the basic algorithm for randomness. That is not\nimplemented here -- so, this is the Elm 0.17 algorithm with the Elm 0.19 API.\n\n@docs uniform, weighted, constant, lazy, independentSeed\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "constant",
        "comment": " Generate the same value every time.\n\n    import Random\n\n    alwaysFour : Random.Generator Int\n    alwaysFour =\n        Random.constant 4\n\nThink of it as picking from a hat with only one thing in it. It is weird,\nbut it can be useful with [`elm-community/random-extra`][extra] which has\ntons of nice helpers.\n\n[extra]: /packages/elm-community/random-extra/latest\n\n",
        "type": "a -> Random.Generator a"
      },
      {
        "name": "independentSeed",
        "comment": " A generator that produces a seed that is independent of any other seed in\nthe program. These seeds will generate their own unique sequences of random\nvalues. They are useful when you need an unknown amount of randomness *later*\nbut can request only a fixed amount of randomness *now*.\n\n> It does not seem possible to implement Elm 0.19's exact algorithm in an Elm\n> 0.17 user package. So, what is implemented here is an approximation of what Elm\n> 0.19 does, and probably does not have the same quality of randomness.\n\n",
        "type": "Random.Generator Random.Seed"
      },
      {
        "name": "lazy",
        "comment": " Helper for defining self-recursive generators. Say we want to generate a\nrandom number of probabilities:\n\n    import Random\n\n    probabilities : Random.Generator (List Float)\n    probabilities =\n        Random.andThen identity <|\n            Random.uniform\n                (Random.constant [])\n                [ Random.map2 (::)\n                    (Random.float 0 1)\n                    (Random.lazy (\\_ -> probabilities))\n                ]\n\nIn 50% of cases we end the list. In 50% of cases we generate a probability and\nadd it onto a random number of probabilities. The `lazy` call is crucial\nbecause it means we do not unroll the generator unless we need to.\n\nThis is a pretty subtle issue, so I recommend reading more about it\n[here](https://elm-lang.org/hints/0.19.0/bad-recursion)!\n\n**Note:** You can delay evaluation with `andThen` too. The thing that matters\nis that you have a function call that delays the creation of the generator!\n\n",
        "type": "(() -> Random.Generator a) -> Random.Generator a"
      },
      {
        "name": "uniform",
        "comment": " Generate values with equal probability. Say we want a random suit for some\ncards:\n\n    import Random\n\n    type Suit\n        = Diamond\n        | Club\n        | Heart\n        | Spade\n\n    suit : Random.Generator Suit\n    suit =\n        Random.uniform Diamond [ Club, Heart, Spade ]\n\nThat generator produces all `Suit` values with equal probability, 25% each.\n\n**Note:** Why not have `uniform : List a -> Generator a` as the API? It looks\na little prettier in code, but it leads to an awkward question. What do you do\nwith `uniform []`? How can it produce an `Int` or `Float`? The current API\nguarantees that we always have *at least* one value, so we never run into that\nquestion!\n\n",
        "type": "a -> List a -> Random.Generator a"
      },
      {
        "name": "weighted",
        "comment": " Generate values with a *weighted* probability. Say we want to simulate a\n[loaded die](https://en.wikipedia.org/wiki/Dice#Loaded_dice) that lands\non ⚄ and ⚅ more often than the other faces:\n\n    import Random\n\n    type Face\n        = One\n        | Two\n        | Three\n        | Four\n        | Five\n        | Six\n\n    roll : Random.Generator Face\n    roll =\n        Random.weighted\n            ( 10, One )\n            [ ( 10, Two )\n            , ( 10, Three )\n            , ( 10, Four )\n            , ( 20, Five )\n            , ( 40, Six )\n            ]\n\nSo there is a 40% chance of getting `Six`, a 20% chance of getting `Five`, and\nthen a 10% chance for each of the remaining faces.\n\n**Note:** I made the weights add up to 100, but that is not necessary. I always\nadd up your weights into a `total`, and from there, the probablity of each case\nis `weight / total`. Negative weights do not really make sense, so I just flip\nthem to be positive.\n\n",
        "type": "( Float, a ) -> List ( Float, a ) -> Random.Generator a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Json.Decode018",
    "comment": " There were quite a few changes between Elm 0.17 and 0.18 in `Json.Decode`.\nHere are some things from Elm 0.18 that you might want to use in Elm 0.17.\n\n@docs andThen, field, index, lazy\n@docs map2, map3, map4, map5, map6, map7, map8\n@docs nullable\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Create decoders that depend on previous results. If you are creating\nversioned data, you might do something like this:\n\n    info : Decoder Info\n    info =\n        field \"version\" int\n            |> andThen infoHelp\n\n    infoHelp : Int -> Decoder Info\n    infoHelp version =\n        case version of\n            4 ->\n                infoDecoder4\n\n            3 ->\n                infoDecoder3\n\n            _ ->\n                fail <|\n                    \"Trying to decode info, but version \"\n                        ++ toString version\n                        ++ \" is not supported.\"\n\n\n    -- infoDecoder4 : Decoder Info\n    -- infoDecoder3 : Decoder Info\n\n",
        "type": "(a -> Json.Decode.Decoder b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b"
      },
      {
        "name": "field",
        "comment": " Decode a JSON object, requiring a particular field.\n\n    decodeString (field \"x\" int) \"{ \"x\": 3 }\" == Ok 3\n    decodeString (field \"x\" int) \"{ \"x\": 3, \"y\": 4 }\" == Ok 3\n    decodeString (field \"x\" int) \"{ \"x\": true }\" == Err ...\n    decodeString (field \"x\" int) \"{ \"y\": 4 }\" == Err ...\n    decodeString (field \"name\" string) \"{ \"name\": \"tom\" }\" == Ok \"tom\"\n\nThe object *can* have other fields. Lots of them! The only thing this decoder\ncares about is if `x` is present and that the value there is an `Int`.\nCheck out [`map2`](#map2) to see how to decode multiple fields!\n\n",
        "type": "String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "index",
        "comment": " Decode a JSON array, requiring a particular index.\n\n    json = \"\"\"[ \"alice\", \"bob\", \"chuck\" ]\"\"\"\n\n    decodeString (index 0 string) json  == Ok \"alice\"\n    decodeString (index 1 string) json  == Ok \"bob\"\n    decodeString (index 2 string) json  == Ok \"chuck\"\n    decodeString (index 3 string) json  == Err ...\n\n",
        "type": "Int -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "lazy",
        "comment": " Sometimes you have JSON with recursive structure, like nested comments.\nYou can use `lazy` to make sure your decoder unrolls lazily.\n\n    type alias Comment =\n        { message : String\n        , responses : Responses\n        }\n\n    type Responses\n        = Responses (List Comment)\n\n    comment : Decoder Comment\n    comment =\n        map2 Comment\n            (field \"message\" string)\n            (field \"responses\" (map Responses (list (lazy (\\_ -> comment)))))\n\nIf we had said `list comment` instead, we would start expanding the value\ninfinitely. What is a `comment`? It is a decoder for objects where the\n`responses` field contains comments. What is a `comment` though? Etc.\n\nBy using `list (lazy (\\_ -> comment))` we make sure the decoder only expands\nto be as deep as the JSON we are given. You can read more about recursive data\nstructures [here].\n[here]: <https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md>\n\n",
        "type": "(() -> Json.Decode.Decoder a) -> Json.Decode.Decoder a"
      },
      {
        "name": "map2",
        "comment": " Try two decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Point =\n        { x : Float, y : Float }\n\n    point : Decoder Point\n    point =\n        map2 Point\n            (field \"x\" float)\n            (field \"y\" float)\n\n\n    -- decodeString point \"\"\"{ \"x\": 3, \"y\": 4 }\"\"\" == Ok { x = 3, y = 4 }\n\nIt tries each individual decoder and puts the result together with the `Point`\nconstructor.\n\n",
        "type": "(a -> b -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder value"
      },
      {
        "name": "map3",
        "comment": " Try three decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Person =\n        { name : String, age : Int, height : Float }\n\n    person : Decoder Person\n    person =\n        map3 Person\n            (at [ \"name\" ] string)\n            (at [ \"info\", \"age\" ] int)\n            (at [ \"info\", \"height\" ] float)\n\n\n    -- json = \"\"\"{ \"name\": \"tom\", \"info\": { \"age\": 42, \"height\": 1.8 } }\"\"\"\n    -- decodeString person json == Ok { name = \"tom\", age = 42, height = 1.8 }\n\nLike `map2` it tries each decoder in order and then give the results to the\n`Person` constructor. That can be any function though!\n\n",
        "type": "(a -> b -> c -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder value"
      },
      {
        "name": "map4",
        "comment": " ",
        "type": "(a -> b -> c -> d -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder value"
      },
      {
        "name": "map5",
        "comment": " ",
        "type": "(a -> b -> c -> d -> e -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder value"
      },
      {
        "name": "map6",
        "comment": " ",
        "type": "(a -> b -> c -> d -> e -> f -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder value"
      },
      {
        "name": "map7",
        "comment": " ",
        "type": "(a -> b -> c -> d -> e -> f -> g -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder value"
      },
      {
        "name": "map8",
        "comment": " ",
        "type": "(a -> b -> c -> d -> e -> f -> g -> h -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder h -> Json.Decode.Decoder value"
      },
      {
        "name": "nullable",
        "comment": " Decode a nullable JSON value into an Elm value.\n\n    decodeString (nullable int) \"13\"    == Ok (Just 13)\n    decodeString (nullable int) \"42\"    == Ok (Just 42)\n    decodeString (nullable int) \"null\"  == Ok Nothing\n    decodeString (nullable int) \"true\"  == Err ..\n\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Json.Encode019",
    "comment": " Elm 0.19 moved this module to a separate package, and added\na couple of new encoders.\n\n@docs dict, set\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "dict",
        "comment": " Turn a `Dict` into a JSON object.\n\n    import Dict\n    import Json.Encode as Encode\n\n    Dict.fromList [ (\"Tom\",42), (\"Sue\", 38) ]\n        |> dict identity Encode.int\n        |> Encode.encode 0\n        --> \"\"\"{\"Tom\":42,\"Sue\":38}\"\"\"\n\n",
        "type": "(comparable -> String) -> (v -> Json.Encode.Value) -> Dict.Dict comparable v -> Json.Encode.Value"
      },
      {
        "name": "set",
        "comment": " Turn an `Set` into a JSON array.\n\n    import Json.Encode as Encode\n    import Set\n\n    Set.fromList [ 42, 38 ]\n        |> set Encode.int\n        |> Encode.encode 0\n        --> \"[38,42]\"\n\n",
        "type": "(comparable -> Json.Encode.Value) -> Set.Set comparable -> Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Task018",
    "comment": " Elm 0.18 flipped parameters for `andThen` and `onError`,\nadded `attempt` and altered `perform`.\n\n@docs attempt, andThen, onError, perform\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together a task and a callback. The first task will run, and if it is\nsuccessful, you give the result to the callback resulting in another task. This\ntask then gets run.\n\n    succeed 2\n      |> andThen (\\n -> succeed (n + 2))\n      -- succeed 4\n\nThis is useful for chaining tasks together. Maybe you need to get a user from\nyour servers *and then* lookup their picture once you know their name.\n",
        "type": "(a -> Task.Task x b) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "attempt",
        "comment": " Command the Elm runtime to attempt a task that might fail!\n",
        "type": "(Result.Result x a -> msg) -> Task.Task x a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "onError",
        "comment": " Recover from a failure in a task. If the given task fails, we use the\ncallback to recover.\n\n    fail \"file not found\"\n      |> onError (\\msg -> succeed 42)\n      -- succeed 42\n\n    succeed 9\n      |> onError (\\msg -> succeed 42)\n      -- succeed 9\n",
        "type": "(x -> Task.Task y a) -> Task.Task x a -> Task.Task y a"
      },
      {
        "name": "perform",
        "comment": " The only way to *do* things in Elm is to give commands to the Elm runtime.\nSo we describe some complex behavior with a `Task` and then command the runtime\nto `perform` that task. For example, getting the current time looks like this:\n\n    import Task\n    import Time exposing (Time)\n\n    type Msg = Click | NewTime Time\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n      case msg of\n        Click ->\n          ( model, Task.perform NewTime Time.now )\n\n        NewTime time ->\n          ...\n",
        "type": "(a -> msg) -> Task.Task Basics.Never a -> Platform.Cmd.Cmd msg"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "String019",
    "comment": " Elm 0.19 added several new functions, and changed the\nsignature for `toInt` and `toFloat`.\n\n@docs replace, fromInt, fromFloat\n@docs toInt, toFloat\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "fromFloat",
        "comment": " Convert a `Float` to a `String`.\n\n    fromFloat 123 --> \"123\"\n\n    fromFloat -42 --> \"-42\"\n\n    fromFloat 3.9 --> \"3.9\"\n\nCheck out [`Debug.toString`](Debug#toString) to convert _any_ value to a string\nfor debugging purposes.\n\n",
        "type": "Float -> String"
      },
      {
        "name": "fromInt",
        "comment": " Convert an `Int` to a `String`.\n\n    fromInt 123 --> \"123\"\n\n    fromInt -42 --> \"-42\"\n\nCheck out [`Debug.toString`](Debug#toString) to convert _any_ value to a string\nfor debugging purposes.\n\n",
        "type": "Int -> String"
      },
      {
        "name": "replace",
        "comment": " Replace all occurrences of some substring.\n\n    replace \".\" \"-\" \"Json.Decode.succeed\" --> \"Json-Decode-succeed\"\n\n    replace \",\" \"/\" \"a,b,c,d,e\" --> \"a/b/c/d/e\"\n\n**Note:** If you need more advanced replacements, check out the\n[`elm/parser`][parser] or [`elm/regex`][regex] package.\n\n[parser]: /packages/elm/parser/latest\n[regex]: /packages/elm/regex/latest\n\n",
        "type": "String -> String -> String -> String"
      },
      {
        "name": "toFloat",
        "comment": " Try to convert a string into a float, failing on improperly formatted strings.\n\n    String019.toFloat \"123\" --> Just 123.0\n\n    String019.toFloat \"-42\" --> Just -42.0\n\n    String019.toFloat \"3.1\" --> Just 3.1\n\n    String019.toFloat \"31a\" --> Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String019.toFloat \"42.5\") --> 42.5\n\n    Maybe.withDefault 0 (String019.toFloat \"cats\") --> 0\n\n",
        "type": "String -> Maybe.Maybe Float"
      },
      {
        "name": "toInt",
        "comment": " Try to convert a string into an int, failing on improperly formatted strings.\n\n    String019.toInt \"123\" --> Just 123\n\n    String019.toInt \"-42\" --> Just -42\n\n    String019.toInt \"3.1\" --> Nothing\n\n    String019.toInt \"31a\" --> Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String019.toInt \"42\") --> 42\n\n    Maybe.withDefault 0 (String019.toInt \"ab\") --> 0\n\n",
        "type": "String -> Maybe.Maybe Int"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Regex019",
    "comment": " `Regex` was moved to a separate package in Elm 0.19, and the\nAPI had some significant changes. Those changes are back-ported here, so much\nas is possible.\n\n@docs fromString, fromStringWith, Options, never\n\n@docs split, splitAtMost, find, findAtMost\n\n",
    "aliases": [
      {
        "name": "Options",
        "comment": " This type was introduced in Elm 0.19. In Elm 0.19, it also has a\n`multiline` field, but it is not practical to back-port that behaviour\nto Elm 0.17.\n",
        "args": [],
        "type": "{ caseInsensitive : Bool }"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "find",
        "comment": " Find matches in a string:\n\n    import Regex\n\n    location : Regex.Regex\n    location =\n        Maybe.withDefault Regex.never <|\n            Regex.fromString \"[oi]n a (\\\\w+)\"\n\n    places : List Regex.Match\n    places =\n        Regex.find location \"I am on a boat in a lake.\"\n\n\n    -- map .match      places == [ \"on a boat\", \"in a lake\" ]\n    -- map .submatches places == [ [Just \"boat\"], [Just \"lake\"] ]\n\nIf you need `submatches` for some reason, a library like\n[`elm/parser`][parser] will probably lead to better code in the long run.\n\n[parser]: /packages/elm/parser/latest\n\n",
        "type": "Regex.Regex -> String -> List Regex.Match"
      },
      {
        "name": "findAtMost",
        "comment": " Just like `find` but it stops after some number of matches.\n\nA library like [`elm/parser`][parser] will probably lead to better code in\nthe long run.\n\n[parser]: /packages/elm/parser/latest\n\n",
        "type": "Int -> Regex.Regex -> String -> List Regex.Match"
      },
      {
        "name": "fromString",
        "comment": " Try to create a `Regex`.\n\n    import Regex\n\n    lowerCase : Regex.Regex\n    lowerCase =\n        Maybe.withDefault Regex.never <|\n            Regex.fromString \"[a-z]+\"\n\n**Note:** There are some [shorthand character classes][short] like `\\w` for\nword characters, `\\s` for whitespace characters, and `\\d` for digits. **Make\nsure they are properly escaped!** If you specify them directly in your code,\nthey would look like `\"\\\\w\\\\s\\\\d\"`.\n\n[short]: https://www.regular-expressions.info/shorthand.html\n\n> In Elm 0.19, this returns a `Maybe` in order to cover cases where the\n> input is not a valid regular expression. It is not practical to port this\n> behaviour back to Elm 0.17, so we always return `Just ...`, and crash if\n> the input is not valid (as Elm 0.17 would do).\n\n",
        "type": "String -> Maybe.Maybe Regex.Regex"
      },
      {
        "name": "fromStringWith",
        "comment": " Create a `Regex` with some additional options. For example, you can define\n`fromString` like this:\n\n    import Regex\n\n    fromString : String -> Maybe Regex.Regex\n    fromString string =\n        fromStringWith { caseInsensitive = False } string\n\n> In Elm 0.19, there is also a `multiline` option, but it is not practical\n> to back-port this option to Elm 0.17.\n\n",
        "type": "Regex019.Options -> String -> Maybe.Maybe Regex.Regex"
      },
      {
        "name": "never",
        "comment": " A regular expression that never matches any string.\n",
        "type": "Regex.Regex"
      },
      {
        "name": "split",
        "comment": " Split a string. The following example will split on commas and tolerate\nwhitespace on either side of the comma:\n\n    import Regex\n\n    comma : Regex.Regex\n    comma =\n        Maybe.withDefault Regex.never <|\n            Regex.fromString \" *, *\"\n\n\n    -- Regex.split comma \"tom,99,90,85\"     == [\"tom\",\"99\",\"90\",\"85\"]\n    -- Regex.split comma \"tom, 99, 90, 85\"  == [\"tom\",\"99\",\"90\",\"85\"]\n    -- Regex.split comma \"tom , 99, 90, 85\" == [\"tom\",\"99\",\"90\",\"85\"]\n\nIf you want some really fancy splits, a library like\n[`elm/parser`][parser] will probably be easier to use.\n\n[parser]: /packages/elm/parser/latest\n\n",
        "type": "Regex.Regex -> String -> List String"
      },
      {
        "name": "splitAtMost",
        "comment": " Just like `split` but it stops after some number of matches.\n\nA library like [`elm/parser`][parser] will probably lead to better code in\nthe long run.\n\n[parser]: /packages/elm/parser/latest\n\n",
        "type": "Int -> Regex.Regex -> String -> List String"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Tuple018",
    "comment": " The `Tuple` module was new in Elm 0.18. So, here it is!\n\n@docs first, second, mapFirst, mapSecond\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "first",
        "comment": " Extract the first value from a tuple.\n\n    first (3, 4) == 3\n    first (\"john\", \"doe\") == \"john\"\n\n",
        "type": "( a1, a2 ) -> a1"
      },
      {
        "name": "mapFirst",
        "comment": " Transform the first value in a tuple.\n\n    import String\n\n    mapFirst String.reverse (\"stressed\", 16) == (\"desserts\", 16)\n    mapFirst String.length (\"stressed\", 16) == (8, 16)\n\n",
        "type": "(a -> b) -> ( a, a2 ) -> ( b, a2 )"
      },
      {
        "name": "mapSecond",
        "comment": " Transform the second value in a tuple.\n\n    import String\n\n    mapSecond sqrt (\"stressed\", 16) == (\"stressed\", 4)\n    mapSecond (\\x -> x + 1) (\"stressed\", 16) == (\"stressed\", 17)\n\n",
        "type": "(a -> b) -> ( a1, a ) -> ( a1, b )"
      },
      {
        "name": "second",
        "comment": " Extract the second value from a tuple.\n\n    second (3, 4) == 4\n    second (\"john\", \"doe\") == \"doe\"\n\n",
        "type": "( a1, a2 ) -> a2"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Maybe018",
    "comment": " Elm 0.18 flipped the arguments to `andThen`, for the sake of ease\nof use in pipelines.\n\n@docs andThen\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together many computations that may fail. It is helpful to see its\ndefinition:\n\n    andThen : (a -> Maybe b) -> Maybe a -> Maybe b\n    andThen callback maybe =\n        case maybe of\n            Just value ->\n                callback value\n\n            Nothing ->\n                Nothing\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`head : List Int -> Maybe Int`) to get the\nfirst month from a `List` and then make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Maybe Int\n    toValidMonth month =\n        if month >= 1 && month <= 12 then\n            Just month\n        else\n            Nothing\n\n    getFirstMonth : List Int -> Maybe Int\n    getFirstMonth months =\n        head months\n            |> andThen toValidMonth\n\nIf `head` fails and results in `Nothing` (because the `List` was `empty`),\nthis entire chain of operations will short-circuit and result in `Nothing`.\nIf `toValidMonth` results in `Nothing`, again the chain of computations\nwill result in `Nothing`.\n\n",
        "type": "(a -> Maybe.Maybe b) -> Maybe.Maybe a -> Maybe.Maybe b"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Basics019",
    "comment": " Elm 0.19 renamed these two functions, so here they are with their\nnew names.\n\n@docs modBy, remainderBy\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "modBy",
        "comment": " Perform [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\nA common trick is to use (n mod 2) to detect even and odd numbers:\n\n    modBy 2 0 --> 0\n\n    modBy 2 1 --> 1\n\n    modBy 2 2 --> 0\n\n    modBy 2 3 --> 1\n\nOur `modBy` function works in the typical mathematical way when you run into\nnegative numbers:\n\n    List.map (modBy 4)\n        [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n        --> [  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1 ]\n\nUse [`remainderBy`](#remainderBy) for a different treatment of negative numbers,\nor read Daan Leijen’s [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "remainderBy",
        "comment": " Get the remainder after division. Here are bunch of examples of dividing by four:\n\n    List.map (remainderBy 4)\n        [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n        --> [ -1,  0, -3, -2, -1,  0,  1,  2,  3,  0,  1 ]\n\nUse [`modBy`](#modBy) for a different treatment of negative numbers,\nor read Daan Leijen’s [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n\n",
        "type": "Int -> Int -> Int"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Result018",
    "comment": " `formatError` was renamed to `mapError` in Elm 0.18, and\nthe parameters of `andThen` were flipped.\n\n@docs andThen, mapError\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together a sequence of computations that may fail. It is helpful\nto see its definition:\n\n    andThen : (a -> Result e b) -> Result e a -> Result e b\n    andThen callback result =\n        case result of\n          Ok value -> callback value\n          Err msg -> Err msg\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -> Result String Int`) to parse\na month and make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Result String Int\n    toValidMonth month =\n        if month >= 1 && month <= 12\n            then Ok month\n            else Err \"months must be between 1 and 12\"\n\n    toMonth : String -> Result String Int\n    toMonth rawString =\n        toInt rawString\n          |> andThen toValidMonth\n\n    -- toMonth \"4\" == Ok 4\n    -- toMonth \"9\" == Ok 9\n    -- toMonth \"a\" == Err \"cannot parse to an Int\"\n    -- toMonth \"0\" == Err \"months must be between 1 and 12\"\n\nThis allows us to come out of a chain of operations with quite a specific error\nmessage. It is often best to create a custom type that explicitly represents\nthe exact ways your computation may fail. This way it is easy to handle in your\ncode.\n",
        "type": "(a -> Result.Result x b) -> Result.Result x a -> Result.Result x b"
      },
      {
        "name": "mapError",
        "comment": " Transform an `Err` value. For example, say the errors we get have too much\ninformation:\n\n    parseInt : String -> Result ParseError Int\n\n    type alias ParseError =\n        { message : String\n        , code : Int\n        , position : (Int,Int)\n        }\n\n    mapError .message (parseInt \"123\") == Ok 123\n    mapError .message (parseInt \"abc\") == Err \"char 'a' is not a number\"\n",
        "type": "(x -> y) -> Result.Result x a -> Result.Result y a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Tuple019",
    "comment": " Elm 0.19 added `pair` and `mapBoth`.\n\n@docs pair, mapBoth\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "mapBoth",
        "comment": " Transform both parts of a tuple.\n\n    import String\n\n    mapBoth String.reverse sqrt  (\"stressed\", 16) --> (\"desserts\", 4)\n\n    mapBoth String.length negate (\"stressed\", 16) --> (8, -16)\n\n",
        "type": "(a -> x) -> (b -> y) -> ( a, b ) -> ( x, y )"
      },
      {
        "name": "pair",
        "comment": " Create a 2-tuple.\n\n    pair 3 4 --> (3, 4)\n\n    zip : List a -> List b -> List (a, b)\n    zip xs ys =\n      List.map2 Tuple.pair xs ys\n\n",
        "type": "a -> b -> ( a, b )"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Char019",
    "comment": " Elm 0.19 added a few new functions.\n\n@docs isAlpha, isAlphaNum\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "isAlpha",
        "comment": " Detect upper case and lower case ASCII characters.\n\n    isAlpha 'a' --> True\n\n    isAlpha 'b' --> True\n\n    isAlpha 'E' --> True\n\n    isAlpha 'Y' --> True\n\n    isAlpha '0' --> False\n\n    isAlpha '-' --> False\n\n    isAlpha 'π' --> False\n\n",
        "type": "Char -> Bool"
      },
      {
        "name": "isAlphaNum",
        "comment": " Detect upper case and lower case ASCII characters.\n\n    isAlphaNum 'a' --> True\n\n    isAlphaNum 'b' --> True\n\n    isAlphaNum 'E' --> True\n\n    isAlphaNum 'Y' --> True\n\n    isAlphaNum '0' --> True\n\n    isAlphaNum '7' --> True\n\n    isAlphaNum '-' --> False\n\n    isAlphaNum 'π' --> False\n\n",
        "type": "Char -> Bool"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "List018",
    "comment": " Elm 0.18 added a couple of functions to `List`. Enjoy!\n\n@docs range, singleton\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "range",
        "comment": " Create a list of numbers, every element increasing by one.\nYou give the lowest and highest number that should be in the list.\n\n    range 3 6 == [3, 4, 5, 6]\n    range 3 3 == [3]\n    range 6 3 == []\n\n",
        "type": "Int -> Int -> List Int"
      },
      {
        "name": "singleton",
        "comment": " Create a list with only one element:\n\n    singleton 1234 == [1234]\n    singleton \"hi\" == [\"hi\"]\n\n",
        "type": "a -> List a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Debug019",
    "comment": " Elm 0.19 moved `toString` to the `Debug` module, and renamed\n`crash` to `todo`.\n\n@docs toString, todo\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "toString",
        "comment": " Turn any kind of value into a string.\n\n    Debug019.toString 42                --> \"42\"\n\n    Debug019.toString [1,2]             --> \"[1,2]\"\n\n    Debug019.toString ('a', \"cat\", 13)  --> \"('a',\\\"cat\\\",13)\"\n\n    Debug019.toString \"he said, \\\"hi\\\"\" --> \"\\\"he said, \\\\\\\"hi\\\\\\\"\\\"\"\n\nNotice that with strings, this is not the `identity` function. It escapes\ncharacters so if you say `Html.text (toString \"he said, \\\"hi\\\"\")` it will\nshow `\"he said, \\\"hi\\\"\"` rather than `he said, \"hi\"`. This makes it nice\nfor viewing Elm data structures.\n\n",
        "type": "a -> String"
      },
      {
        "name": "todo",
        "comment": " This is a placeholder for code that you will write later.\n\nFor example, if you are working with a large union type and have partially\ncompleted a case expression, it may make sense to do this:\n\n    type Entity = Ship | Fish | Captain | Seagull\n\n    drawEntity entity =\n      case entity of\n        Ship ->\n          ...\n\n        Fish ->\n          ...\n\n        _ ->\n          Debug.todo \"handle Captain and Seagull\"\n\nThe Elm compiler recognizes each `Debug.todo` so if you run into it, you get\nan **uncatchable runtime exception** that includes the module name and line\nnumber.\n\n**Note:** For the equivalent of try/catch error handling in Elm, use modules\nlike [`Maybe`](#Maybe) and [`Result`](#Result) which guarantee that no error\ngoes unhandled!\n\n",
        "type": "String -> a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Bitwise018",
    "comment": " Several functions were replaced with \"flipped\" versions in Elm 0.18 --\nhere are the new versions.\n\n@docs shiftLeftBy, shiftRightBy, shiftRightZfBy\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "shiftLeftBy",
        "comment": " Shift bits to the left by a given offset, filling new bits with zeros.\nThis can be used to multiply numbers by powers of two.\n\n    shiftLeftBy 1 5 == 10\n    shiftLeftBy 5 1 == 32\n\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "shiftRightBy",
        "comment": " Shift bits to the right by a given offset, filling new bits with\nwhatever is the topmost bit. This can be used to divide numbers by powers of two.\n\n    shiftRightBy 1 32 == 16\n    shiftRightBy 2 32 == 8\n    shiftRightBy 1 -32 == -16\n\nThis is called an [arithmetic right shift][ars], often written (>>), and\nsometimes called a sign-propagating right shift because it fills empty spots\nwith copies of the highest bit.\n\n[ars]: <http://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift>\n\n",
        "type": "Int -> Int -> Int"
      },
      {
        "name": "shiftRightZfBy",
        "comment": " Shift bits to the right by a given offset, filling new bits with zeros.\n\n    shiftRightZfBy 1 32 == 16\n    shiftRightZfBy 2 32 == 8\n    shiftRightZfBy 1 -32 == 2147483632\n\nThis is called an [logical right shift][lrs], often written (>>>), and\nsometimes called a zero-fill right shift because it fills empty spots with\nzeros.\n\n[lrs]: <http://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift>\n\n",
        "type": "Int -> Int -> Int"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  },
  {
    "name": "Basics018",
    "comment": " The `never` function was new in Elm 0.18, so here it is.\n\n@docs never\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "never",
        "comment": " A function that can never be called. Seems extremely pointless, but it\n*can* come in handy. Imagine you have some HTML that should never produce any\nmessages. And say you want to use it in some other HTML that *does* produce\nmessages. You could say:\n\n    import Html exposing (..)\n\n    embedHtml : Html Never -> Html msg\n    embedHtml staticStuff =\n        div []\n            [ text \"hello\"\n            , Html.map never staticStuff\n            ]\n\nSo the `never` function is basically telling the type system, make sure no one\never calls me!\n\n",
        "type": "Basics.Never -> a"
      }
    ],
    "generated-with-elm-version": "0.17.1"
  }
]