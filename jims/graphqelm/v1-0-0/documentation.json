[
  {
    "name": "Graphqelm.Http",
    "comment": " Send requests to your GraphQL endpoint. See [this live code demo](https://rebrand.ly/graphqelm)\nor the [`examples/`](https://github.com/dillonkearns/graphqelm/tree/master/examples)\nfolder for some end-to-end examples.\nThe builder syntax is inspired by Luke Westby's\n[elm-http-builder package](http://package.elm-lang.org/packages/lukewestby/elm-http-builder/latest).\n\n\n## Data Types\n\n@docs Request, Error\n\n\n## Begin `Request` Pipeline\n\n@docs queryRequest, mutationRequest, queryRequestWithHttpGet\n@docs QueryRequestMethod\n\n\n## Configure `Request` Options\n\n@docs withHeader, withTimeout, withCredentials, withQueryParams\n\n\n## Perform `Request`\n\n@docs send, toTask\n\n\n## Map `Error`s\n\n@docs mapError, ignoreParsedErrorData\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Error",
        "comment": " Represents the two types of errors you can get, an Http error or a GraphQL error.\nSee the `Graphqelm.Http.GraphqlError` module docs for more details.\n",
        "args": [
          "parsedData"
        ],
        "cases": [
          [
            "GraphqlError",
            [
              "Graphqelm.Http.GraphqlError.PossiblyParsedData parsedData",
              "List Graphqelm.Http.GraphqlError.GraphqlError"
            ]
          ],
          [
            "HttpError",
            [
              "Http.Error"
            ]
          ]
        ]
      },
      {
        "name": "QueryRequestMethod",
        "comment": " Union type to pass in to `queryRequestWithHttpGet`. Only applies to queries.\nMutations don't accept this configuration option and will always use POST.\n",
        "args": [],
        "cases": [
          [
            "AlwaysGet",
            []
          ],
          [
            "GetIfShortEnough",
            []
          ]
        ]
      },
      {
        "name": "Request",
        "comment": " An internal request as it's built up. Once it's built up, send the\nrequest with `Graphqelm.Http.send`.\n",
        "args": [
          "decodesTo"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "ignoreParsedErrorData",
        "comment": " Useful when you don't want to deal with the recovered data if there is `ParsedData`.\nJust a shorthand for `mapError` that will turn any `ParsedData` into `()`.\n",
        "type": "Graphqelm.Http.Error parsedData -> Graphqelm.Http.Error ()"
      },
      {
        "name": "mapError",
        "comment": " Map the error data if it is `ParsedData`.\n",
        "type": "(a -> b) -> Graphqelm.Http.Error a -> Graphqelm.Http.Error b"
      },
      {
        "name": "mutationRequest",
        "comment": " Initialize a basic request from a Mutation. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphqelm.Http.send`.\n",
        "type": "String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootMutation -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "queryRequest",
        "comment": " Initialize a basic request from a Query. You can add on options with `withHeader`,\n`withTimeout`, `withCredentials`, and send it with `Graphqelm.Http.send`.\n",
        "type": "String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "queryRequestWithHttpGet",
        "comment": " Exactly like `queryRequest`, but with an option to use the HTTP GET request\nmethod. You will probably want to use `GetIfShortEnough`, which uses GET if the\nfull URL ends up being under 2000 characters, or POST otherwise, since [some browsers\ndon't support URLs over a certain length](https://stackoverflow.com/questions/812925/what-is-the-maximum-possible-length-of-a-query-string?noredirect=1&lq=1).\n`GetIfShortEnough` will typically do what you need. If you must use GET no matter\nwhat when hitting your endpoint, you can use `AlwaysGet`.\n\n`queryRequest` always uses POST since some GraphQL API's don't support GET\nrequests (for example, the Github API assumes that you are doing an introspection\nquery if you make a GET request). But for semantic reasons, GET requests\nare sometimes useful for sending GraphQL Query requests. That is, a GraphQL Query\ndoes not perform side-effects on the server like a Mutation does, so a GET\nindicates this and allows some servers to cache requests. See\n[this github thread from the Apollo project](https://github.com/apollographql/apollo-client/issues/813)\nfor more details.\n\n",
        "type": "String -> Graphqelm.Http.QueryRequestMethod -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "send",
        "comment": " Send the `Graphqelm.Request`\nYou can use it on its own, or with a library like\n[RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/latest/).\n\n    import Graphqelm.Http\n    import Graphqelm.OptionalArgument exposing (OptionalArgument(Null, Present))\n    import RemoteData exposing (RemoteData)\n\n    type Msg\n        = GotResponse RemoteData Graphqelm.Http.Error Response\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://graphqelm.herokuapp.com/\"\n            |> Graphqelm.Http.withHeader \"authorization\" \"Bearer abcdefgh12345678\"\n            -- If you're not using remote data, it's just\n            -- |> Graphqelm.Http.send GotResponse\n            -- With remote data, it's as below\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\nIf any errors are present, you will get a `GraphqlError` that includes the details.\nGraphQL allows for partial data to be returned in the case of errors so you can\ninspect the data returned in the `GraphqlError` if you would like to try to recover\nany data that made it through in the response.\n\n",
        "type": "(Result.Result (Graphqelm.Http.Error decodesTo) decodesTo -> msg) -> Graphqelm.Http.Request decodesTo -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "toTask",
        "comment": " Convert a Request to a Task. See `Graphqelm.Http.send` for an example of\nhow to build up a Request.\n",
        "type": "Graphqelm.Http.Request decodesTo -> Task.Task (Graphqelm.Http.Error decodesTo) decodesTo"
      },
      {
        "name": "withCredentials",
        "comment": " Set with credentials to true.\n",
        "type": "Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withHeader",
        "comment": " Add a header.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphqelm.Http.withHeader \"authorization\" \"Bearer <my token>\"\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\n",
        "type": "String -> String -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withQueryParams",
        "comment": " Add query params. The values will be Uri encoded.\n\n    makeRequest : Cmd Msg\n    makeRequest =\n        query\n            |> Graphqelm.Http.queryRequest \"https://api.github.com/graphql\"\n            |> Graphqelm.Http.withQueryParams [ ( \"version\", \"1.2.3\" ) ]\n            |> Graphqelm.Http.send (RemoteData.fromResult >> GotResponse)\n\n",
        "type": "List ( String, String ) -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      },
      {
        "name": "withTimeout",
        "comment": " Add a timeout.\n",
        "type": "Time.Time -> Graphqelm.Http.Request decodesTo -> Graphqelm.Http.Request decodesTo"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Subscription",
    "comment": " _Warning_ The Subscriptions functionality in this package is in a highly experimental stage\nand may change rapidly or have issues that make it not ready for production code yet.\n\n@docs Model, Msg, Status, init, onStatusChanged, sendMutation, listen, update\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Model",
        "comment": " Model\n",
        "args": [
          "msg",
          "decodesTo"
        ],
        "cases": []
      },
      {
        "name": "Msg",
        "comment": " An opaque type that needs to be passed through to the `Subscription.update` function\nin your program's `update`.\n\n    type Msg\n        = GraphqlSubscriptionMsg (Graphqelm.Subscription.Msg ChatMessage)\n        | SubscriptionDataReceived ChatMessage\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n        case msg of\n            GraphqlSubscriptionMsg graphqlSubscriptionMsg ->\n                Graphqelm.Subscription.update graphqlSubscriptionMsg model\n\n            SubscriptionDataReceived newData ->\n                ( { model | data = newData :: model.data }, Cmd.none )\n\n    subscriptions : Model -> Sub Msg\n    subscriptions model =\n        Graphqelm.Subscription.subscription model.graphqlSubscriptionModel GraphqlSubscriptionMsg socketUrl document\n\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "Status",
        "comment": " The Subscription connection status. Use `onStatusChanged` to register a Msg to listen for this.\n",
        "args": [],
        "cases": [
          [
            "Uninitialized",
            []
          ],
          [
            "Connected",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "init",
        "comment": " Initialize a Subscription. You will need a `Graphqelm.Subscription.Protocol`\ndata structure (the `Protocol` module contains `Protocol`s for some\nGraphQL server implementations).\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol decodesTo -> String -> Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootSubscription -> (decodesTo -> msg) -> ( Graphqelm.Subscription.Model msg decodesTo , Platform.Cmd.Cmd msg )"
      },
      {
        "name": "listen",
        "comment": " Add this to your subscriptions.\n",
        "type": "(Graphqelm.Subscription.Msg decodesTo -> msg) -> Graphqelm.Subscription.Model msg decodesTo -> Platform.Sub.Sub msg"
      },
      {
        "name": "onStatusChanged",
        "comment": " Register a Msg to receive when a connection is established.\n\n    init : ( Model, Cmd Msg )\n    init =\n        let\n            ( graphqlSubscriptionModel, graphqlSubscriptionCmd ) =\n                Graphqelm.Subscription.init protocol socketUrl subscriptionDocument SubscriptionDataReceived\n        in\n        ( { data = []\n          , subscriptionStatus = Graphqelm.Subscription.Uninitialized\n          , graphqlSubscriptionModel =\n                graphqlSubscriptionModel\n                    |> Graphqelm.Subscription.onStatusChanged SubscriptionStatusChanged\n          }\n        , graphqlSubscriptionCmd\n        )\n\n",
        "type": "(Graphqelm.Subscription.Status -> msg) -> Graphqelm.Subscription.Model msg decodesTo -> Graphqelm.Subscription.Model msg decodesTo"
      },
      {
        "name": "sendMutation",
        "comment": " Performs the mutation over the websocket. If the connection is uninitialized,\nit will be dropped.\nTODO: should it always be queued? Or should it optionally be queued?\n",
        "type": "Graphqelm.Subscription.Model msg decodesTo -> Graphqelm.SelectionSet.SelectionSet mutationDecodesTo Graphqelm.Operation.RootMutation -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "update",
        "comment": " Needs to be called from your program's `update` function in order to listen\nfor and respond to Subscription communications.\n",
        "type": "Graphqelm.Subscription.Msg decodesTo -> Graphqelm.Subscription.Model msg decodesTo -> ( Graphqelm.Subscription.Model msg decodesTo , Platform.Cmd.Cmd msg )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Builder.Object",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `graphqelm` CLI.\n@docs fieldDecoder, selection, selectionField, interfaceSelection, unionSelection\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "fieldDecoder",
        "comment": " Refer to a field in auto-generated code.\n",
        "type": "String -> List Graphqelm.Internal.Builder.Argument.Argument -> Json.Decode.Decoder decodesTo -> Graphqelm.Field.Field decodesTo lockedTo"
      },
      {
        "name": "interfaceSelection",
        "comment": " Used to create the `selection` functions in auto-generated code for interfaces.\n",
        "type": "List (Graphqelm.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a -> b) -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock"
      },
      {
        "name": "selection",
        "comment": " Used to create the `selection` functions in auto-generated code.\n",
        "type": "(a -> constructor) -> Graphqelm.SelectionSet.SelectionSet (a -> constructor) typeLock"
      },
      {
        "name": "selectionField",
        "comment": " Refer to an object in auto-generated code.\n",
        "type": "String -> List Graphqelm.Internal.Builder.Argument.Argument -> Graphqelm.SelectionSet.SelectionSet a objectTypeLock -> (Json.Decode.Decoder a -> Json.Decode.Decoder b) -> Graphqelm.Field.Field b lockedTo"
      },
      {
        "name": "unionSelection",
        "comment": " Used to create the `selection` functions in auto-generated code for unions.\n",
        "type": "List (Graphqelm.SelectionSet.FragmentSelectionSet typeSpecific typeLock) -> (Maybe.Maybe typeSpecific -> a) -> Graphqelm.SelectionSet.SelectionSet a typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Document",
    "comment": " You'll usually want to use `Graphqelm.Http` to perform your queries directly.\nThis package provides low-level functions for generating GraphQL documents that\nare helpful for debugging and demo purposes.\n\n@docs Operation, serialize, serializeQuery, serializeMutation, serializeSubscription, serializeQueryForUrl, decoder\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Operation",
        "comment": " An enum used to describe the type of operation for use in `serialize`.\n",
        "args": [],
        "cases": [
          [
            "Query",
            []
          ],
          [
            "Mutation",
            []
          ],
          [
            "Subscription",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "decoder",
        "comment": " Decoder a response from the server. This low-level function shouldn't be needed\nin the majority of cases. Instead, the high-level functions in `Graphqelm.Http`\nshould be used.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo typeLock -> Json.Decode.Decoder decodesTo"
      },
      {
        "name": "serialize",
        "comment": " Serialize any type of selection set into a string for a GraphQL endpoint.\nThis is useful if you're writing a function that operates on any type of\nselection set that needs to serialize its results.\n",
        "type": "Graphqelm.Document.Operation -> Graphqelm.SelectionSet.SelectionSet decodesTo typeLock -> String"
      },
      {
        "name": "serializeMutation",
        "comment": " Serialize a mutation selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootMutation -> String"
      },
      {
        "name": "serializeQuery",
        "comment": " Serialize a query selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> String"
      },
      {
        "name": "serializeQueryForUrl",
        "comment": " Serialize a query selection set into a string with minimal whitespace. For\nuse with a GET request as a query param.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootQuery -> String"
      },
      {
        "name": "serializeSubscription",
        "comment": " Serialize a subscription selection set into a string for a GraphQL endpoint.\n",
        "type": "Graphqelm.SelectionSet.SelectionSet decodesTo Graphqelm.Operation.RootSubscription -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.SelectionSet",
    "comment": " The auto-generated code from the `graphqelm` CLI will provide `selection`\nfunctions for Objects, Interfaces, and Unions in your GraphQL schema.\nThese functions build up a `Graphqelm.SelectionSet` which describes a set\nof fields to retrieve. The `SelectionSet` is built up in a pipeline similar to how\n[`Json.Decode.Pipeline`](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest)\nbuilds up decoders.\n\nFor example, if you had a top-level query `human(id: ID!)` which returns an object\nof type `Human`, you could build the following GraphQL query document:\n\n    query {\n      human(id: 1001) {\n        name\n        id\n      }\n    }\n\nIn this example, the `SelectionSet` on `human` is:\n\n    {\n      name\n      id\n    }\n\nYou could build up the above `SelectionSet` with the following `Graphqelm` code:\n\n    import Api.Object\n    import Api.Object.Human as Human\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    type alias Human =\n        { name : String\n        , id : String\n        }\n\n    hero : SelectionSet Hero Api.Interface.Human\n    hero =\n        Human.selection Human\n            |> with Human.name\n            |> with Human.id\n\nNote that all of the modules under `Api.` in this case are generated by running\nthe `graphqelm` command line tool.\n\nThe query itself is also a `SelectionSet` so it is built up similarly.\nSee [this live code demo](https://rebrand.ly/graphqelm) for an example.\n\n@docs with, hardcoded, empty, map, succeed\n\n\n## Types\n\nThese types are built for you by the code generated by the `graphqelm` command line tool.\n\n@docs SelectionSet, FragmentSelectionSet\n\n",
    "aliases": [],
    "types": [
      {
        "name": "FragmentSelectionSet",
        "comment": " FragmentSelectionSet type\n",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "FragmentSelectionSet",
            [
              "String",
              "List Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      },
      {
        "name": "SelectionSet",
        "comment": " SelectionSet type\n",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "SelectionSet",
            [
              "List Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "empty",
        "comment": " Useful for Mutations when you don't want any data back.\n\n    import Api.Mutation as Mutation\n    import Graphqelm.Operation exposing (RootMutation)\n    import Graphqelm.SelectionSet as SelectionSet exposing (SelectionSet, with)\n\n    sendChatMessage : String -> SelectionSet () RootMutation\n    sendChatMessage message =\n        Mutation.selection identity\n            |> with (Mutation.sendMessage { message = message } SelectionSet.empty)\n\n",
        "type": "Graphqelm.SelectionSet.SelectionSet () typeLock"
      },
      {
        "name": "hardcoded",
        "comment": " Include a hardcoded value.\n\n        import Api.Enum.Episode as Episode exposing (Episode)\n        import Api.Object\n        import Graphqelm.SelectionSet exposing (SelectionSet, with, hardcoded)\n\n        type alias Hero =\n            { name : String\n            , movie : String\n            }\n\n        hero : SelectionSet Hero Api.Interface.Character\n        hero =\n            Character.commonSelection Hero\n                |> with Character.name\n                |> hardcoded \"Star Wars\"\n\n",
        "type": "a -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock -> Graphqelm.SelectionSet.SelectionSet b typeLock"
      },
      {
        "name": "map",
        "comment": " Apply a function to change the result of decoding the `SelectionSet`.\n",
        "type": "(a -> b) -> Graphqelm.SelectionSet.SelectionSet a typeLock -> Graphqelm.SelectionSet.SelectionSet b typeLock"
      },
      {
        "name": "succeed",
        "comment": " Instead of hardcoding a field like `hardcoded`, `SelectionSet.succeed` hardcodes\nan entire `SelectionSet`. This can be useful if you want hardcoded data based on\nonly the type when using a polymorphic type (Interface or Union).\n\n    type alias Character =\n        { details : Maybe HumanOrDroid\n        , name : String\n        }\n\n    type HumanOrDroid\n        = Human\n        | Droid\n\n    hero : SelectionSet Character Swapi.Interface.Character\n    hero =\n        Character.selection Character\n            [ Character.onDroid (SelectionSet.succeed Droid)\n            , Character.onHuman (SelectionSet.succeed Human)\n            ]\n            |> with Character.name\n\n",
        "type": "a -> Graphqelm.SelectionSet.SelectionSet a typeLock"
      },
      {
        "name": "with",
        "comment": " Used to pick out fields on an object.\n\n    import Api.Enum.Episode as Episode exposing (Episode)\n    import Api.Object\n    import Api.Scalar\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    type alias Hero =\n        { name : String\n        , id : Api.Scalar.Id\n        , appearsIn : List Episode\n        }\n\n    hero : SelectionSet Hero Api.Interface.Character\n    hero =\n        Character.commonSelection Hero\n            |> with Character.name\n            |> with Character.id\n            |> with Character.appearsIn\n\n",
        "type": "Graphqelm.Field.Field a typeLock -> Graphqelm.SelectionSet.SelectionSet (a -> b) typeLock -> Graphqelm.SelectionSet.SelectionSet b typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Field",
    "comment": " `Field`s are automatically generated by the `graphqelm` CLI command.\nYou can use `Graphqelm.Field.map` to transform a value.\n\n\n## Safe Transformations\n\n@docs map\n\n\n## Result (`...OrFail`) Transformations\n\n**Warning** When you use these functions, you lose the guarantee that the\nserver response will decode successfully.\n\nThese helpers, though convenient, will cause your entire decoder to fail if\nit ever maps to an `Err` instead of an `Ok` `Result`.\n\n@docs mapOrFail, nonNullOrFail, nonNullElementsOrFail\n\n\n## Types\n\n@docs Field\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Field",
        "comment": " ",
        "args": [
          "decodesTo",
          "typeLock"
        ],
        "cases": [
          [
            "Field",
            [
              "Graphqelm.RawField.RawField",
              "Json.Decode.Decoder decodesTo"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "map",
        "comment": " Maps the data coming back from the GraphQL endpoint. In this example,\n`User.name` is a function that the `graphqelm` CLI tool created which tells us\nthat the `name` field on a `User` object is a String according to your GraphQL\nschema.\n\n    import Api.Object\n    import Api.Object.User as User\n    import Graphqelm.Field as Field\n    import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n    human : SelectionSet String Api.Object.User\n    human =\n        User.selection identity\n            |> with\n                (User.name\n                    |> Field.map String.toUpper\n                )\n\nYou can also map to values of a different type (`String -> Int`, for example), see\n[`examples/StarWars.elm`](https://github.com/dillonkearns/graphqelm/blob/master/examples/src/Starwars.elm) for more advanced example.\n\n",
        "type": "(decodesTo -> mapsTo) -> Graphqelm.Field.Field decodesTo typeLock -> Graphqelm.Field.Field mapsTo typeLock"
      },
      {
        "name": "mapOrFail",
        "comment": " If the map function provided returns an `Ok` `Result`, it will map to that value.\nIf it returns an `Err`, the _entire_ response will fail to decode.\n\n    import Date exposing (Date)\n    import Github.Object\n    import Github.Object.Repository\n    import Github.Scalar\n    import Graphqelm.Field as Field exposing (Field)\n\n    createdAt : Field Date Github.Object.Repository\n    createdAt =\n        Github.Object.Repository.createdAt\n            |> Field.mapOrFail\n                (\\(Github.Scalar.DateTime dateTime) ->\n                    Date.fromString dateTime\n                )\n\n",
        "type": "(decodesTo -> Result.Result String mapsTo) -> Graphqelm.Field.Field decodesTo typeLock -> Graphqelm.Field.Field mapsTo typeLock"
      },
      {
        "name": "nonNullElementsOrFail",
        "comment": " Effectively turns a field that is `[String]` => `[String!]`, or `[User]` =>\n`[User!]` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if any elements in the list for this\nfield comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\nOften GraphQL schemas will contain things like `[String]` (i.e. a nullable list\nof nullable strings) when they really mean `[String!]!` (a non-nullable list of\nnon-nullable strings). You can chain together these nullable helpers if for some\nreason you can't go in and fix this in the schema, for example:\n\n    releases : SelectionSet (List Release) Github.Object.ReleaseConnection\n    releases =\n        Github.Object.ReleaseConnection.selection identity\n            |> with\n                (Github.Object.ReleaseConnection.nodes release\n                    |> Field.nonNullOrFail\n                    |> Field.nonNullElementsOrFail\n                )\n\nWithout the `Field.nonNull...` transformations here, the type would be\n`SelectionSet (Maybe (List (Maybe Release))) Github.Object.ReleaseConnection`.\n\n",
        "type": "Graphqelm.Field.Field (List (Maybe.Maybe decodesTo)) typeLock -> Graphqelm.Field.Field (List decodesTo) typeLock"
      },
      {
        "name": "nonNullOrFail",
        "comment": " Effectively turns an attribute that is `String` => `String!`, or `User` =>\n`User!` (if you're not familiar with the GraphQL type language notation, learn more\n[here](http://graphql.org/learn/schema/#type-language)).\n\nThis will cause your _entire_ decoder to fail if the field comes back as null.\nIt's far better to fix your schema then to use this escape hatch!\n\n",
        "type": "Graphqelm.Field.Field (Maybe.Maybe decodesTo) typeLock -> Graphqelm.Field.Field decodesTo typeLock"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Builder.Argument",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\nInternal functions for use by auto-generated code from the `graphqelm` CLI.\n@docs Argument, optional, required\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Argument",
        "comment": " Argument type.\n",
        "args": [],
        "cases": [
          [
            "Argument",
            [
              "String",
              "Graphqelm.Internal.Encode.Value"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "optional",
        "comment": " Used for passing optional arguments in generated code.\n",
        "type": "String -> Graphqelm.OptionalArgument.OptionalArgument a -> (a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe Graphqelm.Internal.Builder.Argument.Argument"
      },
      {
        "name": "required",
        "comment": " Used for passing required arguments in generated code.\n",
        "type": "String -> a -> (a -> Graphqelm.Internal.Encode.Value) -> Graphqelm.Internal.Builder.Argument.Argument"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Subscription.Protocol",
    "comment": " You will need a Protocol data structure that fills in the low-level details about\nyour server's GraphQL Subscription protocol. Ideally these will be published here,\nor in an external package by community members so that the protocols for each framework\nis easily accessible, less error-prone, and more stable.\n\n@docs Protocol, phoenixAbsinthe, rails, Response\n\n",
    "aliases": [
      {
        "name": "Protocol",
        "comment": " This encapsulates the Subscriptions protocol for a specific framework, like Phoenix/Absinthe.\nThe low-level details of how to initiate a connection and check that it was successful, etc., can be\nvery different between GraphQL server implementations. Here is an example for the Absinthe framework\nfor Elixir/Phoenix:\n\n        frameworkKnowledge : Graphqelm.Subscription.Protocol subscriptionDecodesTo\n        frameworkKnowledge =\n        { initMessage =\n        Encode.list\n            [ Encode.string \"1\"\n            , Encode.string \"1\"\n            , Encode.string \"__absinthe__:control\"\n            , Encode.string \"phx_join\"\n            , Encode.object []\n            ]\n        , heartBeatMessage =\n        Encode.list\n            [ Encode.null\n            , Encode.string \"1\"\n            , Encode.string \"phoenix\"\n            , Encode.string \"heartbeat\"\n            , Encode.object []\n            ]\n        , documentRequest =\n        \\operation ->\n            Encode.list\n                [ Encode.string \"1\"\n                , Encode.string \"1\"\n                , Encode.string \"__absinthe__:control\"\n                , Encode.string \"doc\"\n                , Encode.object [ ( \"query\", operation |> Encode.string ) ]\n                ]\n        , subscriptionDecoder =\n        \\decoder ->\n            subscriptionResponseDecoder\n                (decoder\n                    |> Decode.field \"result\"\n                    |> Decode.index 4\n                )\n        }\n\n",
        "args": [
          "subscriptionDecodesTo"
        ],
        "type": "{ documentRequest : Int -> String -> Json.Encode.Value , heartBeatMessage : Int -> Json.Encode.Value , initMessage : Int -> Json.Encode.Value , subscriptionDecoder : Json.Decode.Decoder subscriptionDecodesTo -> Json.Decode.Decoder (Graphqelm.Subscription.Protocol.Response subscriptionDecodesTo) }"
      }
    ],
    "types": [
      {
        "name": "Response",
        "comment": " Low-level type used for building Protocol. Represents incoming server messages.\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "SubscriptionDataReceived",
            [
              "a"
            ]
          ],
          [
            "HealthStatus",
            []
          ],
          [
            "Ignored",
            [
              "String"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "phoenixAbsinthe",
        "comment": " `Protocol` for the [Absinthe framework](http://absinthe-graphql.org/)\nwith Elixir/Phoenix.\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol subscriptionDecodesTo"
      },
      {
        "name": "rails",
        "comment": " `Protocol` for [graphql-ruby](https://github.com/rmosolgo/graphql-ruby/).\n",
        "type": "Graphqelm.Subscription.Protocol.Protocol subscriptionDecodesTo"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Http.GraphqlError",
    "comment": "\n\n@docs GraphqlError, decoder, Location, PossiblyParsedData\n\n",
    "aliases": [
      {
        "name": "GraphqlError",
        "comment": " Represents an error from the GraphQL endpoint. Also see `Graphqelm.Http`.\n\nThe code generated by Graphqelm\nguarantees that your requests are valid according to the server's schema, so\nthe two cases where you will get a GraphqlError are 1) when there is an implicit\nconstraint that the schema doesn't specify, or 2) when your generated code is\nout of date with the schema.\n\nSee the\n[Errors section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Errors).\nfor more details about GraphQL errors.\n\n",
        "args": [],
        "type": "{ message : String , locations : Maybe.Maybe (List Graphqelm.Http.GraphqlError.Location) , details : Dict.Dict String Json.Decode.Value }"
      },
      {
        "name": "Location",
        "comment": " The location in the GraphQL query document where the error occured\n",
        "args": [],
        "type": "{ line : Int, column : Int }"
      }
    ],
    "types": [
      {
        "name": "PossiblyParsedData",
        "comment": " Represents the `data` field in cases where there is an error present, see\n[the error section in the GraphQL spec](http://facebook.github.io/graphql/October2016/#sec-Data).\nIf the decoder succeeds you will end up with `ParsedData`. If it fails, you\nwill get an `UnparsedData` with a `Json.Decode.Value` containing the raw, undecoded\n`data` field. You're likely to end up with `UnparsedData` since\n[GraphQL will return `null` if there is an error on a non-nullable field](http://facebook.github.io/graphql/October2016/#sec-Errors-and-Non-Nullability)\n, which will cause the decode pipeline to fail and give you `UnparsedData`.\n",
        "args": [
          "parsed"
        ],
        "cases": [
          [
            "ParsedData",
            [
              "parsed"
            ]
          ],
          [
            "UnparsedData",
            [
              "Json.Decode.Value"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "decoder",
        "comment": " For internal use only.\n",
        "type": "Json.Decode.Decoder (List Graphqelm.Http.GraphqlError.GraphqlError)"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Internal.Encode",
    "comment": " **WARNING** `Graphqelm.Interal` modules are used by the `graphqelm` command line\ncode generator tool. They should not be consumed through hand-written code.\n\n`Graphqelm.Internal.Encode.Value`s are low-level details used by generated code.\nThey are only used by the code generated by the `graphqelm` CLI tool.\n\n@docs null, bool, enum, int, list, string, object, maybe, maybeObject, optional, float\n@docs serialize\n@docs Value\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Value",
        "comment": " Represents an encoded Value\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "bool",
        "comment": " Encode a bool\n",
        "type": "Bool -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "enum",
        "comment": " Encode an enum. The first argument is the toString function for that enum.\n",
        "type": "(a -> String) -> a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "float",
        "comment": " Encode a float\n",
        "type": "Float -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "int",
        "comment": " Encode an int\n",
        "type": "Int -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "list",
        "comment": " Encode a list of Values\n",
        "type": "(a -> Graphqelm.Internal.Encode.Value) -> List a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "maybe",
        "comment": " Encode a Maybe. Uses encoder for `Just`, or `Encode.null` for `Nothing`.\n",
        "type": "(a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe a -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "maybeObject",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "List ( String, Maybe.Maybe Graphqelm.Internal.Encode.Value ) -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "null",
        "comment": " Encode null\n",
        "type": "Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "object",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "List ( String, Graphqelm.Internal.Encode.Value ) -> Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "optional",
        "comment": " Encode a list of key-value pairs into an object\n",
        "type": "Graphqelm.OptionalArgument.OptionalArgument a -> (a -> Graphqelm.Internal.Encode.Value) -> Maybe.Maybe Graphqelm.Internal.Encode.Value"
      },
      {
        "name": "serialize",
        "comment": " Low-level function for serializing a `Graphqelm.Internal.Encode.Value`s.\n",
        "type": "Graphqelm.Internal.Encode.Value -> String"
      },
      {
        "name": "string",
        "comment": " Encode a string\n",
        "type": "String -> Graphqelm.Internal.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.OptionalArgument",
    "comment": "\n\n@docs OptionalArgument\n@docs fromMaybe\n\n",
    "aliases": [],
    "types": [
      {
        "name": "OptionalArgument",
        "comment": " This type is used to create values to pass in optional arguments.\n\n      import Api.Enum.Episode as Episode exposing (Episode)\n      import Api.Query as Query\n      import Graphqelm.Operation exposing (RootQuery)\n      import Graphqelm.OptionalArgument exposing (OptionalArgument(Null, Present))\n      import Graphqelm.SelectionSet exposing (SelectionSet, with)\n\n\n      query : SelectionSet Response RootQuery\n      query =\n          Query.selection Response\n              |> with (Query.human { id = \"1004\" } human)\n              |> with (Query.human { id = \"1001\" } human)\n              |> with\n                  (Query.hero\n                      (\\optionals ->\n                          { optionals\n                              | episode = Present Episode.EMPIRE\n                          }\n                      )\n                      hero\n                  )\n\nAn optional argument can be either present, absent, or null, so using a Maybe does not\nfully capture the GraphQL concept of an optional argument. For example, you could have\na mutation that deletes an entry if a null argument is provided, or does nothing if\nthe argument is absent. See\n[The official GraphQL spec section on null](http://facebook.github.io/graphql/October2016/#sec-Null-Value)\nfor details.\n\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "Present",
            [
              "a"
            ]
          ],
          [
            "Absent",
            []
          ],
          [
            "Null",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "fromMaybe",
        "comment": " Convert a `Maybe` to an OptionalArgument.\n",
        "type": "Maybe.Maybe a -> Graphqelm.OptionalArgument.OptionalArgument a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Graphqelm.Operation",
    "comment": " This module contains types used to annotate top-level queries which can be\nbuilt up using functions in code generated by the `graphqelm` command line tool\nand sent using functions in the `Graphqelm.Http` module.\n\n@docs RootMutation, RootQuery, RootSubscription\n\n",
    "aliases": [],
    "types": [
      {
        "name": "RootMutation",
        "comment": " Type for top-level mutations which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RootQuery",
        "comment": " Type for top-level queries which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "RootSubscription",
        "comment": " Type for top-level mutations which can be sent using functions\nfrom `Graphqelm.Http`.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [],
    "generated-with-elm-version": "0.18.0"
  }
]