[
  {
    "name": "SelectList",
    "comment": " Yet another SelectList implementation\n\nA SelectList is a non-empty list which always has exactly one element selected.\nIt is an example of a list zipper.\n\nInspired by these modules\n\n  - [rtfeldman/selectlist](http://package.elm-lang.org/packages/rtfeldman/selectlist/latest)\n  - [turboMaCk/lazy-tree-with-zipper](http://package.elm-lang.org/packages/turboMaCk/lazy-tree-with-zipper/latest)\n\n[`mapBy`](#mapBy) is the main function in this package.\nUse [`mapBy`](#mapBy) in view.\n\n    view : SelectList String -> Html Msg\n    view selectList =\n        ul [] <|\n            SelectList.mapBy\n                (\\position item ->\n                    li [ onClick (Set item) ]\n                        [ text <| toString <| SelectList.index item\n                        , toString <| SelectList.selected item\n                        ]\n                )\n                selectList\n\n\n# Type\n\n@docs SelectList, fromLists, fromList, singleton\n\n\n# Query\n\n@docs toList, selected, before, after, index, isHead, isLast\n@docs length, afterLength, beforeLength\n\n\n# Operations\n\n@docs attempt, append, prepend\n@docs Direction\n@docs modify, set, insert, delete\n\n\n# Step\n\n@docs step, steps, moveToHead, moveToLast\n\n\n# Transformations\n\n@docs selectAll, map, Position, mapBy, mapBy_\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Direction",
        "comment": " `Direction`\n",
        "args": [],
        "cases": [
          [
            "After",
            []
          ],
          [
            "Before",
            []
          ]
        ]
      },
      {
        "name": "Position",
        "comment": " `Position` is used with [`mapBy`](#mapBy).\n\n`Position` is Selected if the selected element,\nBeforeSelected if an element before the selected element,\nand AfterSelected if an element after the selected element.\n\n",
        "args": [],
        "cases": [
          [
            "BeforeSelected",
            []
          ],
          [
            "Selected",
            []
          ],
          [
            "AfterSelected",
            []
          ]
        ]
      },
      {
        "name": "SelectList",
        "comment": " A nonempty list which always has exactly one element selected.\n\nCreate one using `fromLists`, `fromList` or `singleton`.\n\n",
        "args": [
          "a"
        ],
        "cases": [
          [
            "SelectList",
            [
              "List a",
              "a",
              "List a"
            ]
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "after",
        "comment": " Return the elements after the selected element.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> after\n        == [ 5, 6 ]\n\n",
        "type": "SelectList.SelectList a -> List a"
      },
      {
        "name": "afterLength",
        "comment": " Length of the elements after the selected element\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> afterLength\n        == 2\n\n",
        "type": "SelectList.SelectList a -> Int"
      },
      {
        "name": "append",
        "comment": " Add elements to the end of a `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> append [ 7, 8 ]\n        |> toList\n        == [ 1, 2, 3, 4, 5, 6, 7, 8 ]\n\n",
        "type": "List a -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "attempt",
        "comment": " Attempt to perform action over selectList and return original `SelectList`\nin cases where this action returns `Nothing`.\n\n    attempt f selectList =\n        f selectList\n            |> Maybe.withDefault selectList\n\n",
        "type": "(SelectList.SelectList a -> Maybe.Maybe (SelectList.SelectList a)) -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "before",
        "comment": " Return the elements before the selected element.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> before\n        == [ 1, 2, 3 ]\n\n",
        "type": "SelectList.SelectList a -> List a"
      },
      {
        "name": "beforeLength",
        "comment": " Length of the elements before the selected element\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> beforeLength\n        == 3\n\n",
        "type": "SelectList.SelectList a -> Int"
      },
      {
        "name": "delete",
        "comment": " Delete the selected element, then select `After`/`Before` element.\n\nReturns Nothing if list of `After`/`Before` elements is empty.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> delete After\n        == Just (fromLists [ 1, 2, 3 ] 5 [ 6 ])\n\n    fromLists [ 1, 2, 3 ] 4 []\n        |> delete After\n        == Nothing\n\n",
        "type": "SelectList.Direction -> SelectList.SelectList a -> Maybe.Maybe (SelectList.SelectList a)"
      },
      {
        "name": "fromList",
        "comment": " A `SelectList` if list has elements.\n\nIf empty, `Nothing`.\n\n    fromList [] == Nothing\n    fromList [2, 3, 4] == Just (fromLists [] 2 [ 3, 4 ])\n\n",
        "type": "List a -> Maybe.Maybe (SelectList.SelectList a)"
      },
      {
        "name": "fromLists",
        "comment": " A `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> selected\n        == 4\n\n",
        "type": "List a -> a -> List a -> SelectList.SelectList a"
      },
      {
        "name": "index",
        "comment": " Index of the selected element.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> index\n        == 3\n\n",
        "type": "SelectList.SelectList a -> Int"
      },
      {
        "name": "insert",
        "comment": " Insert the new selected element, then move the old `After`/`Before`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> insert After 8\n        == fromLists [ 1, 2, 3 ] 8 [ 4, 5, 6 ]\n\n",
        "type": "SelectList.Direction -> a -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "isHead",
        "comment": " Check if the selected element is first element.\n\n    fromLists [] 4 [ 5, 6 ]\n        |> isHead\n        == True\n\n",
        "type": "SelectList.SelectList a -> Bool"
      },
      {
        "name": "isLast",
        "comment": " Check if the selected element is last element.\n\n    fromLists [ 1, 2, 3 ] 4 []\n        |> isLast\n        == True\n\n",
        "type": "SelectList.SelectList a -> Bool"
      },
      {
        "name": "length",
        "comment": " Length of `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> length\n        == 6\n\n",
        "type": "SelectList.SelectList a -> Int"
      },
      {
        "name": "map",
        "comment": " Transform each element of the `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> map (\\num -> num * 2)\n        == fromLists [ 2, 4, 6 ] 8 [ 10, 12 ]\n\n",
        "type": "(a -> b) -> SelectList.SelectList a -> SelectList.SelectList b"
      },
      {
        "name": "mapBy",
        "comment": " Transform each element of the `SelectList`.\n\nThe transform function receives a `Position`\nand `SelectList` which selects a transformed element.\n\n[`mapBy`](#mapBy) is the main function in this package.\nUse [`mapBy`](#mapBy) in view.\n\n    view : SelectList String -> Html Msg\n    view selectList =\n        ul [] <|\n            SelectList.mapBy\n                (\\position item ->\n                    li [ onClick (Set item) ]\n                        [ text <| toString <| SelectList.index item\n                        , toString <| SelectList.selected item\n                        ]\n                )\n                selectList\n\nIf you can not use non-empty list, use [`mapBy_`](#mapBy_) that receives `List` instead of `SelectList`.\n\n",
        "type": "(SelectList.Position -> SelectList.SelectList a -> b) -> SelectList.SelectList a -> List b"
      },
      {
        "name": "mapBy_",
        "comment": " This receives `List` instead of `SelectList`.\n",
        "type": "(SelectList.Position -> SelectList.SelectList a -> b) -> List a -> List b"
      },
      {
        "name": "modify",
        "comment": " Modify the selected element using given function.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> modify (\\selected -> 2 * selected)\n        == fromLists [ 1, 2, 3 ] 8 [ 5, 6 ]\n\n",
        "type": "(a -> a) -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "moveToHead",
        "comment": " A selectList selects the first element of a selectList.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> moveToHead\n        == fromLists [] 1 [ 2, 3, 4, 5, 6 ]\n\n",
        "type": "SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "moveToLast",
        "comment": " A selectList selects the last element of a selectList.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> moveToHead\n        == fromLists [] 1 [ 2, 3, 4, 5, 6 ]\n\n",
        "type": "SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "prepend",
        "comment": " Add elements to the beginning of a `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> prepend [ 7, 8 ]\n        |> toList\n        == [ 7, 8, 1, 2, 3, 4, 5, 6 ]\n\n",
        "type": "List a -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "selectAll",
        "comment": " List of all selectList.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        == [ fromLists [] 1 [ 2, 3, 4, 5, 6 ]\n           , fromLists [ 1 ] 2 [ 3, 4, 5, 6 ]\n           , fromLists [ 1, 2 ] 3 [ 4, 5, 6 ]\n           , fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n           , fromLists [ 1, 2, 3, 4 ] 5 [ 6 ]\n           , fromLists [ 1, 2, 3, 4, 5 ] 6 []\n           ]\n\n",
        "type": "SelectList.SelectList a -> List (SelectList.SelectList a)"
      },
      {
        "name": "selected",
        "comment": " Return the selected element.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> selected\n        == 4\n\n",
        "type": "SelectList.SelectList a -> a"
      },
      {
        "name": "set",
        "comment": " Replace the selected element with new one.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> set 10\n        == fromLists [ 1, 2, 3 ] 10 [ 5, 6 ]\n\n",
        "type": "a -> SelectList.SelectList a -> SelectList.SelectList a"
      },
      {
        "name": "singleton",
        "comment": " A `SelectList` containing exactly one element.\n\n    singleton 3 == fromLists [] 3 []\n\n",
        "type": "a -> SelectList.SelectList a"
      },
      {
        "name": "step",
        "comment": " A selectList selects a `Direction` element by a step.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> step After\n        == Just (fromLists [ 1, 2, 3, 4 ] 5 [ 6 ])\n\n    fromLists [ 1, 2, 3 ] 4 []\n        |> step After\n        == Nothing\n\n",
        "type": "SelectList.Direction -> SelectList.SelectList a -> Maybe.Maybe (SelectList.SelectList a)"
      },
      {
        "name": "steps",
        "comment": " A selectList selects a `Direction` element by `n` steps.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> steps After 2\n        == Just (fromLists [ 1, 2, 3, 4, 5 ] 6 [])\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> steps After 3\n        == Nothing\n\n",
        "type": "SelectList.Direction -> Int -> SelectList.SelectList a -> Maybe.Maybe (SelectList.SelectList a)"
      },
      {
        "name": "toList",
        "comment": " Return a `List` containing the elements in a `SelectList`.\n\n    fromLists [ 1, 2, 3 ] 4 [ 5, 6 ]\n        |> toList\n        == [ 1, 2, 3, 4, 5, 6 ]\n\n",
        "type": "SelectList.SelectList a -> List a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]